
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Monster &amp; Flower">
    <title>OpenCV 随笔记录 - Monster &amp; Flower</title>
    <meta name="author" content="Tianyou Pan">
    
    
        <link rel="icon" href="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/favicon.jpg">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="CSDN 博客搬家">
<meta name="keywords" content="opencv">
<meta property="og:type" content="blog">
<meta property="og:title" content="OpenCV 随笔记录">
<meta property="og:url" content="sherry0429.github.io/2018/02/11/OpenCV-随笔记录/index.html">
<meta property="og:site_name" content="Monster &amp; Flower">
<meta property="og:description" content="CSDN 博客搬家">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://img.blog.csdn.net/20140707151208062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxNDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="http://docs.opencv.org/_images/math/5ca28093f0a8eca32bcf6d54a644b4bcaa07ad72.png">
<meta property="og:image" content="http://docs.opencv.org/_images/math/160c3479896ac799bb5c7d260a052e6b35c463ef.png">
<meta property="og:image" content="http://docs.opencv.org/_images/Sobel_Derivatives_Tutorial_Result.jpg">
<meta property="og:image" content="http://pic002.cnblogs.com/images/2012/372204/2012112220142684.jpg">
<meta property="og:image" content="http://docs.opencv.org/_images/math/d1340f7bb6665e67c94c196809095f23054fca2c.png">
<meta property="og:image" content="http://docs.opencv.org/_images/math/b95a5073fc087b8fc404bc7795982e1570891bd3.png">
<meta property="og:image" content="http://docs.opencv.org/_images/math/8d762e1a527b3613404ec26a98faffd43d1ceb78.png">
<meta property="og:updated_time" content="2018-02-12T03:48:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OpenCV 随笔记录">
<meta name="twitter:description" content="CSDN 博客搬家">
<meta name="twitter:image" content="http://img.blog.csdn.net/20140707151208062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxNDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
    
    
        
    
    
        <meta property="og:image" content="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/handface.jpg"/>
    
    
    
        <meta property="og:image" content="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/transport.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/transport.png" />
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-eonj0pe2aabccyzjrtkp7h1yt1tl45l2v3xwpl2nilpuholcj85zrpl3eiid.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Monster &amp; Flower</a>
    </div>
    
        
            <a  class="header-right-icon "
                href="#about">
        
        
            <i class="fa fa-lg fa-question"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/handface.jpg" alt="author‘s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Tianyou Pan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>光阴似箭，日月如梭，然而，人可以老，力可以衰，心却不能死，理想也不能灭…</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/sherry0429" target="_blank" rel="noopener" title="Github">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Github</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/users/5557569/sherry0429" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-left
                    post-header-cover--full"
             style="background-image:url('https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/transport.png');"
             data-behavior="4">
            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaOut
                        ">
                
<article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            OpenCV 随笔记录
        </h1>
    
    
        <div class="post-meta">
    <time itemprop="datePublished" datetime="2018-02-11T14:52:18+08:00">
	
		    2月 11, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/think/">think</a>


    
</div>

    
</div>
    
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <!-- excerpt -->
<p>在实验室里听一点记一点，到时候再总结整理吧。先记下来再说。</p>
<p>一定要记住的page：<a href="http://wiki.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">http://wiki.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     IplImage * test=NULL;</span><br><span class="line">     test = cvLoadImage (&quot;D:\\demo.jpg&quot;);</span><br><span class="line">     cvNamedWindow(&quot;test_demo&quot;,1);</span><br><span class="line">	 cvMoveWindow(&quot;test_demo&quot;,800,10);</span><br><span class="line">     cvShowImage(&quot;test_demo&quot;,test);</span><br><span class="line">     cvWaitKey(0);</span><br><span class="line">     cvDestroyWindow(&quot;test_demo&quot;);</span><br><span class="line">     cvReleaseImage(&amp;test);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已知函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.IplImage *p=NULL;定义图像指针</span><br></pre></td></tr></table></figure>
<p>IplImage是一个类，它包含以下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IplImage</span><br><span class="line">    &#123;</span><br><span class="line">        int  nSize;         /* IplImage大小，=sizeof(IplImage)*/</span><br><span class="line">        int  ID;            /* 版本 (=0)*/</span><br><span class="line">        int  nChannels;     /* 大多数OPENCV函数支持1,2,3 或 4 个通道 */</span><br><span class="line">        int  alphaChannel;  /* 被OpenCV忽略 */</span><br><span class="line">        int  depth;         /* 像素的位深度: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U,</span><br><span class="line">                               IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F 可支持 */</span><br><span class="line">        char colorModel[4]; /* 被OpenCV忽略 */</span><br><span class="line">        char channelSeq[4]; /* 被OpenCV忽略 */</span><br><span class="line">        int  dataOrder;     /* 0 - 交叉存取颜色通道，对三通道RGB图像，像素存储顺序为BGR BGR BGR ... BGR；</span><br><span class="line">                                     1 - 分开的颜色通道，对三通道RGB图像，像素存储顺序为RRR...R GGG...G BBB...B。</span><br><span class="line">                                  cvCreateImage只能创建交叉存取图像 */</span><br><span class="line">        int  origin;        /* 0 - 顶—左结构,</span><br><span class="line">                               1 - 底—左结构 (Windows bitmaps 风格) */</span><br><span class="line">        int  align;         /* 图像行排列 (4 or 8). OpenCV 忽略它，使用 widthStep 代替 */</span><br><span class="line">        int  width;         /* 图像宽像素数 */</span><br><span class="line">        int  height;        /* 图像高像素数*/</span><br><span class="line">        struct _IplROI *roi;/* 图像感兴趣区域. 当该值非空只对该区域进行处理 */</span><br><span class="line">        struct _IplImage *maskROI; /* 在 OpenCV中必须置NULL */</span><br><span class="line">        void  *imageId;     /* 同上*/</span><br><span class="line">        struct _IplTileInfo *tileInfo; /*同上*/</span><br><span class="line">        int  imageSize;     /* 图像数据大小(在交叉存取格式下imageSize=image-&gt;height*image-&gt;widthStep），单位字节*/</span><br><span class="line">        char *imageData;  /* 指向排列的图像数据 */</span><br><span class="line">        int  widthStep;   /* 排列的图像行大小，以字节为单位 */</span><br><span class="line">        int  BorderMode[4]; /* 边际结束模式, 被OpenCV忽略 */</span><br><span class="line">        int  BorderConst[4]; /* 同上 */</span><br><span class="line">        char *imageDataOrigin; /* 指针指向一个不同的图像数据结构（不是必须排列的），是为了纠正图像内存分配准备的 */</span><br><span class="line">    &#125;</span><br><span class="line">    IplImage;</span><br></pre></td></tr></table></figure>
<p>每定义一个IplImage指针，就定义了一个矩形，矩形的每一行依次为nsize,ID……等等。如图：</p>
<p><img src="http://img.blog.csdn.net/20140707151208062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxNDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.cvLoadImage()</span><br></pre></td></tr></table></figure>
<p>cvLoadImage( filename, -1 ); 默认读取图像的原通道数，filename为图像路径</p>
<p>cvLoadImage( filename, 0 ); 强制转化读取图像为灰度图</p>
<p>cvLoadImage( filename, 1 ); 读取彩色图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.cvNameWindow(&quot;Image&quot;,1);命名图像空间</span><br></pre></td></tr></table></figure>
<p>int cvNamedWindow( const char* name, int flags=CV_WINDOW_AUTOSIZE );</p>
<p>函数cvNamedWindow创建一个可以放置图像的窗口.</p>
<p>被创建的窗口可以通过它们的名字被引用.</p>
<p>如果已经存在这个名字的窗口，这个函数将不做任何事情.</p>
<p>若为0表示以固定尺寸显示,此时可以用cvResizeWindow控制窗口大小，这时图像根据窗口大小进行调整，且全铺在窗口上。可以用鼠标拉伸。</p>
<p>若为1，窗口以图像大小进行调整（即使先前设置过窗口大小），也会根据图像大小进行调整，且不可拉伸。</p>
<p><em>*</em>使用了这个函数后，即使没有图像指针，在编译完成后也会生成一个窗口（灰色）。</p>
<p>关于cvResizeWindow(需要注意，这个函数是用来改变窗口大小的，而非改变图像大小。之所以看似图像大小也改变了，实际上是因为在NamedWindow参数里，设置为图像根据窗口进行调整。换句话说，它的原理是通过改变窗口大小——让图像跟着窗口变化——进而改变图像大小，而非直接改变图像大小。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvResizeWindow( const char* name, int width, int height );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>name </p>
<p>将被设置窗口的名字。</p>
</li>
<li><p>width </p>
<p>新的窗口宽度。</p>
</li>
<li><p>height </p>
<p>新的窗口高度。</p>
</li>
</ul>
<p>函数cvResizeWindow改变窗口的大小。</p>
<p>如果想要直接改变图像大小，需要resize函数或者图像金字塔pyrDown,pyrUp(不改变长宽比，一次面积放大4倍或者缩小4分之一）</p>
<p>以下为转载：</p>
<hr>
<p>OpenCV改变图像大小的操作有两类：resize与图像金字塔，但是这两类操作差别还是比较大的。</p>
<p>一、resize</p>
<p>函数原型</p>
<p>void resize(InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR )</p>
<p>各个参数的意义比较直观，但是需要注意的是dsize与fx和fy必须不能同时为零，也就是说要么dsize不为零而fx与fy同时可以为0，要么dsize为0而fx与fy不同时为0；resize函数的目标大小可以是任意的大小，可以不保持长宽比率，删除的像素或者新增的像素值通过interpolation（内插）控制；</p>
<p>二、图像金字塔</p>
<p>pyrDown与pyrUp分别表示向下降采样与向上升采样，但是二者并不是互为逆操作；</p>
<p>void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize=Size(), int border-</p>
<p>Type=BORDER_DEFAULT )</p>
<p>void pyrUp(InputArray src, OutputArray dst, const Size&amp; dstsize=Size(), int border-</p>
<p>Type=BORDER_DEFAULT )</p>
<p>这两个操作实现图像金字塔的经典操作，他们仅仅是分别代表一次采样操作，也就是说，向下(或者向上)进行相邻层次的金字塔采样，调用一次pyrDown函数只能降低到原图像尺寸的1/2;反之，调用pyrUp目标图像则为原图像尺寸的2倍。因为它们内部都给定了一次采样尺寸的约束。也就是说采样之后，长宽比基本是不变的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void ResizeDemo()</span><br><span class="line">&#123;</span><br><span class="line">         Mat img1=imread(&quot;person_org.jpg&quot;);</span><br><span class="line">         Mat img2;</span><br><span class="line">//将原图像变为32*32，长宽比被改变了</span><br><span class="line">         resize(img1,img2,Size(32,32),0,0,CV_INTER_LINEAR);</span><br><span class="line">         namedWindow(&quot;WindowOrg&quot;);</span><br><span class="line">         namedWindow(&quot;WindowNew&quot;);</span><br><span class="line">         imshow(&quot;WindowOrg&quot;,img1);</span><br><span class="line">         imshow(&quot;WindowNew&quot;,img2);</span><br><span class="line"> </span><br><span class="line">         waitKey(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage *Image;</span><br><span class="line">	IplImage *NewImage;</span><br><span class="line">	Image = cvLoadImage(&quot;D:\\1234.jpg&quot;,1);</span><br><span class="line"></span><br><span class="line">	CvSize sz;</span><br><span class="line">	sz = cvGetSize(Image);</span><br><span class="line">	sz.height /= 2;</span><br><span class="line">	sz.width /= 2;</span><br><span class="line">	//if pyrup,</span><br><span class="line">	//sz.height*=2;</span><br><span class="line">	//sz.width*=2;</span><br><span class="line">	//setting height and width.</span><br><span class="line"></span><br><span class="line">	NewImage = cvCreateImage(sz,IPL_DEPTH_8U, 3);</span><br><span class="line">	//Create Image</span><br><span class="line"></span><br><span class="line">	cvPyrDown(Image, NewImage, 7);</span><br><span class="line">	//cvPryup(Image,NewImage,7);</span><br><span class="line">	//若使用这个函数，需要事先建立好一个尺寸为原图一半的图并用IplImage指针指向它.7相当于CV_GAUSSIAN_5x5.</span><br><span class="line"></span><br><span class="line">	cvNamedWindow(&quot;graph1&quot;, 1);</span><br><span class="line">	cvNamedWindow(&quot;graph2&quot;, 1);</span><br><span class="line">	cvShowImage(&quot;graph1&quot;, Image);</span><br><span class="line">	cvShowImage(&quot;graph2&quot;, NewImage);</span><br><span class="line">	cvWaitKey(0);</span><br><span class="line">	cvDestroyAllWindows();</span><br><span class="line">	return 0;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：resize可以一次性将原图像变为任意不为0的尺寸，适合用来做归一化图像操作；而pyrDown与pyrUp适合做长宽比率不变得操作，且调用一次只能长和宽只能变为原来的1/2或者2倍，也即是说面积变为原来的1/4或者4倍。</p>
<p>转载自<a href="http://blog.sina.com.cn/s/blog_4b0020f30101cgok.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b0020f30101cgok.html</a></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.void cvShowImage( const char* name, const CvArr* image );</span><br></pre></td></tr></table></figure>
<p>Example:</p>
<p>cvShowImage(“Image”,p);</p>
<p>函数cvShowImage 在指定窗口中显示图像.如果窗口创建的时候被设定标志CV_WINDOW_AUTOSIZE,</p>
<p>那么图像将以原始尺寸显示；否则，图像将被伸缩以适合窗口大小.</p>
<p>一条语句只显示一次图像，若后面的语句没有cvWaitKey(0)的话，图像一闪而过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.cvWaitKey(delay)</span><br></pre></td></tr></table></figure>
<p>Example:</p>
<p>cvWaitKey(0);</p>
<p>函数的功能是不断刷新图像，频率时间为delay，单位为ms。</p>
<p>delay为&lt;=0时，无限制等待按键。按键后（在显示出的图片里进行按键），才执行WaitKey之后的语句。另外注意WaitKey单位为毫秒！它的功能可以理解为延时X毫秒后，执行接下来的语句。</p>
<p>函数cvWaitKey无限制的等待按键事件（delay&lt;=0时）；或者延迟”delay”毫秒。返回值为被按键的值，如果超过指定时间则返回-1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.void cvDestroyWindow( const char* name );</span><br></pre></td></tr></table></figure>
<p>Example;</p>
<p>cvDestroyWindow(“Image”);</p>
<p>销毁指定窗口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.cvReleaseImage(&amp;p);//销毁指针</span><br></pre></td></tr></table></figure>
<p>cvReleaseImage函数只是将IplImage*型的变量值赋为NULL，而这个变量本身还是存在的并且在内存中的存储位置不变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.void cvMoveWindow( const char* name, int x, int y );</span><br></pre></td></tr></table></figure>
<p>设定窗口的位置。</p>
<p>name 将被设置的窗口的名字。</p>
<p>x 窗口左上角的x坐标。</p>
<p>y 窗口左上角的y坐标。</p>
<p>函数cvMoveWindow改变窗口的位置。</p>
<p>cvActionTargetMod()</p>
<p>Example:</p>
<p> cv</p>
<p>Get</p>
<p>2D</p>
<p> cv</p>
<p>Create</p>
<p>Image</p>
<p> cv</p>
<p>Name</p>
<p>Window</p>
<p>CV_bitdepth()</p>
<p>S=符号整型</p>
<p>U=无符号整型</p>
<p>F=浮点型</p>
<p>CV_8（位数）U（类型）G（矩阵）1（通道） 一个8位无符号整形单通道矩阵</p>
<p>CV_32FG2 32位浮点型双通道矩阵</p>
<p>图像数据类型：</p>
<p>IPL<em>DEPTH</em><bit_depth>(S|U|F)</bit_depth></p>
<p>IPL_DEPTH_8U 8位无符号整型</p>
<p>头文件：</p>
<cv.h>

<cvaux.h>

<highgui.h>

<ml.h>

<cxcore.h>

<p>基础结构：</p>
<ul>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint" target="_blank" rel="noopener">1 CvPoint</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint2D32f" target="_blank" rel="noopener">2 CvPoint2D32f</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint3D32f" target="_blank" rel="noopener">3 CvPoint3D32f</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSize" target="_blank" rel="noopener">4 CvSize</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSize2D32f" target="_blank" rel="noopener">5 CvSize2D32f</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvRect" target="_blank" rel="noopener">6 CvRect</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvScalar" target="_blank" rel="noopener">7 CvScalar</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvTermCriteria" target="_blank" rel="noopener">8 CvTermCriteria</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvMat" target="_blank" rel="noopener">9 CvMat</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvMatND" target="_blank" rel="noopener">10 CvMatND</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSparseMat" target="_blank" rel="noopener">11 CvSparseMat</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#IplImage" target="_blank" rel="noopener">12 IplImage</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvArr" target="_blank" rel="noopener">13 CvArr</a></li>
</ul>
<p>其中，CvPoint为二维坐标点整型，2D32F为2维浮点型，以此类推。</p>
<p>CyScalar是一个颜色结构体类，有四个数组元素，分别代表R,G,B,第四个元素通常用来表示透明色.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CvScalar</span><br><span class="line"> &#123;</span><br><span class="line">  double val[4]</span><br><span class="line"> &#125;</span><br><span class="line"> CvScalar;</span><br></pre></td></tr></table></figure>
<p>扩展——</p>
<p>其中Cvpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inline CvPoint cvPoint( int x, int y );</span><br><span class="line">inline CvPoint cvPointFrom32f( CvPoint2D32f point )</span><br></pre></td></tr></table></figure>
<p>分别作用为：返回一个cvPoint值，</p>
<p>将一个2D32f值转换为cvPoint值并返回。</p>
<p>函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvLine( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure>
<p>功能：绘制连接两个点的线段</p>
<ul>
<li><p>img 图像。</p>
</li>
<li><p>pt1 线段的第一个端点。</p>
</li>
<li><p>pt2 线段的第二个端点。</p>
</li>
<li><p>color 线段的颜色。</p>
</li>
<li><p>thickness 线段的粗细程度。</p>
</li>
<li><p>line_type 线段的类型。</p>
<p>8 (or 0) - 8-connected line（8邻接)连接 线。</p>
<p>4 - 4-connected line(4邻接)连接线。</p>
<p>CV_AA - antialiased 线条。</p>
</li>
</ul>
<p>shift 坐标点的小数点位数。</p>
<p>函数cvLine 在图像中的点1和点2之间画一条线段。线段被图像或感兴趣的矩形(ROI rectangle)所裁剪。对于具有整数坐标的non-antialiasing 线条，使用8-连接或者4-连接Bresenham 算法。画粗线条时结尾是圆形的。画 antialiased 线条使用高斯滤波。要指定线段颜色，用户可以使用使用宏CV_RGB( r, g, b )。</p>
<p>而且指定线条颜色的时候用到的宏CV_RGB(r，g，b)定义为#define CV_RGB( r, g, b ) cvScalar( (b), (g), (r), 0 )，由此可见，实际上起作用的颜色是看cvScalar中的b，g，r顺序，线段颜色就不言而喻了</p>
<p>利用CvScalar，CvLine画线:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// qwsds.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;highgui.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CvPoint pt1;</span><br><span class="line">	pt1=cvPoint(100,200);</span><br><span class="line">	printf(&quot;x:%d,y:%d\n&quot;,pt1.x,pt1.y);</span><br><span class="line"></span><br><span class="line">	CvPoint pt2;</span><br><span class="line">	pt2=cvPoint(200,320);</span><br><span class="line">	printf(&quot;x:%d,y:%d\n&quot;,pt2.x,pt2.y);</span><br><span class="line"></span><br><span class="line">	CvScalar color;</span><br><span class="line">	color=cvScalar(100,0,200);//蓝 绿 红。RGB</span><br><span class="line">	printf(&quot;v1:%f v2:%f v3:%f\n&quot;,color.val[0],color.val[1],color.val[2]);</span><br><span class="line"></span><br><span class="line">	IplImage *img=0;</span><br><span class="line">	img=cvLoadImage(&quot;D:\\Blue hills.jpg&quot;);</span><br><span class="line"></span><br><span class="line">	cvLine(img,pt1,pt2,color,2);</span><br><span class="line"></span><br><span class="line">	cvNamedWindow(&quot;draw&quot;);</span><br><span class="line"></span><br><span class="line">	cvShowImage(&quot;draw&quot;,img);</span><br><span class="line"></span><br><span class="line">	cvWaitKey();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/pre&gt;&lt;pre code_snippet_id=&quot;421021&quot; snippet_file_name=&quot;blog_20140707_14_8402014&quot; name=&quot;code&quot; class=&quot;cpp&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;CvLine&lt;/span&gt;&lt;/strong&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void cvLine( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color,</span><br><span class="line">             int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>img</p>
<p>图像。</p>
</li>
<li><p>pt1</p>
<p>线段的第一个端点。</p>
</li>
<li><p>pt2</p>
<p>线段的第二个端点。</p>
</li>
<li><p>color</p>
<p>线段的颜色。</p>
</li>
<li><p>thickness</p>
<p>线段的粗细程度。</p>
</li>
<li><p>line_type</p>
<p>线段的类型。8 (or 0) - 8-connected line（8邻接)连接 线。4 - 4-connected line(4邻接)连接线。CV_AA - antialiased 线条。</p>
</li>
</ul>
<ul>
<li><p>shift</p>
<p>坐标点的小数点位数。</p>
</li>
</ul>
<p>函数cvLine 在图像中的点1和点2之间画一条线段。线段被图像或感兴趣的矩形(ROI rectangle)所裁剪。对于具有整数坐标的non-antialiasing 线条，使用8-连接或者4-连接Bresenham 算法。画粗线条时结尾是圆形的。画 antialiased 线条使用高斯滤波。要指定线段颜色，用户可以使用使用宏CV_RGB( r, g, b )。</p>
<p>CvSize sz;</p>
<p>设置一个矩形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CvSize sz;</span><br><span class="line">sz=cvSize(640,480);</span><br><span class="line">printf(&quot;width:%d,height:%d\n&quot;,sz.width,sz.height);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IplImage *p;</span><br><span class="line">p=cvCreateImage(sz,IPL_DEPTH_8U,3);//sz矩形的宽，高（将结构体传进去）,深度,颜色通道数）</span><br><span class="line">cvNamedWindow(&quot;Image&quot;);</span><br><span class="line">cvShowImage(&quot;Image&quot;,p);</span><br><span class="line">cvWaitKey(0);</span><br></pre></td></tr></table></figure>
<p>其中cvCreateImage创建了一个矩形！</p>
<p>CvRect矩阵框的偏移量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CvRect</span><br><span class="line"> &#123;</span><br><span class="line">  int x; /* 方形的最左角的x-坐标  */</span><br><span class="line">  int y; /* 方形的最上或者最下角的y-坐标 */</span><br><span class="line">  int width; /* 宽 */</span><br><span class="line">  int height; /* 高 */</span><br><span class="line"> &#125;</span><br><span class="line"> CvRect;</span><br></pre></td></tr></table></figure>
<p>应用：（利用了CvRectangle）</p>
<p>CvRectangle：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void cvRectangle( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color,</span><br><span class="line">                  int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>img</p>
<p>图像.</p>
</li>
<li><p>pt1</p>
<p>矩形的一个顶点。</p>
</li>
<li><p>pt2</p>
<p>矩形对角线上的另一个顶点</p>
</li>
<li><p>color</p>
<p>线条颜色 (RGB) 或亮度（灰度图像 ）(grayscale image）。</p>
</li>
<li><p>thickness</p>
<p>组成矩形的线条的粗细程度。取负值时（如 CV_FILLED）函数绘制填充了色彩的矩形。</p>
</li>
<li><p>line_type</p>
<p>线条的类型。见cvLine的描述</p>
</li>
<li><p>shift</p>
<p>坐标点的小数点位数。</p>
</li>
</ul>
<p>函数 cvRectangle 通过对角线上的两个顶点绘制矩形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;highgui.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	CvSize sz;//CvSize 数据类型 C大写,定义。</span><br><span class="line">	sz=cvSize(640,480);//给sz赋值。</span><br><span class="line">	printf(&quot;width:%d,height:%d\n&quot;,sz.width,sz.height);</span><br><span class="line">	IplImage *img=0;</span><br><span class="line">	img=cvCreateImage(sz,IPL_DEPTH_8U,3);//创建而不是载入。</span><br><span class="line">	CvRect rect;</span><br><span class="line">	rect=cvRect(50,30,100,150);//左上坐标，长度，宽度。</span><br><span class="line">	CvPoint pt1=cvPoint(rect.x,rect.y);</span><br><span class="line">	CvPoint pt2=cvPoint(rect.x+rect.width,rect.y+rect.height);</span><br><span class="line">	cvRectangle(img,pt1,pt2,cvScalar(0,0,255),2);</span><br><span class="line">	cvNamedWindow(&quot;create&quot;);</span><br><span class="line">	cvShowImage(&quot;create&quot;,img);</span><br><span class="line">	cvWaitKey();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中cvRectangle利用apt1,apt2两个点，和颜色方案cvScalar，以及粗细程度2，将绘制的矩形传递给指针p2,然后在建立的图案区域AAA内显示矩形。</p>
<p>复制图像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IplImage *mp1=cvCloneImage(img);//把图像img复制给mp1.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;para&quot; style=&quot;margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif; font-size:14px&quot;&gt;&lt;pre code_snippet_id=&quot;421021&quot; snippet_file_name=&quot;blog_20140707_20_810661&quot; name=&quot;code&quot; class=&quot;cpp&quot; style=&quot;color: rgb(51, 51, 51);&quot;&gt;	cvNamedWindow(&quot;create&quot;);</span><br><span class="line">	cvShowImage(&quot;create&quot;,img);//img需要事先指向图像</span><br><span class="line">	IplImage *p2=cvCloneImage(img);</span><br><span class="line">	cvNamedWindow(&quot;clone&quot;);</span><br><span class="line">	cvShowImage(&quot;clone&quot;,p2);</span><br><span class="line">	cvWaitKey();</span><br></pre></td></tr></table></figure>
<p>​      保存图像到文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int cvSaveImage( const char* filename, const CvArr* image );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>filename </p>
<p>文件名，如果对应的文件已经存在，则将被复盖。</p>
</li>
<li><p>image </p>
<p>要保存的图像。</p>
</li>
</ul>
<p>函数cvSaveImage保存图像到指定文件。图像格式的的选择依赖于filename的扩展名，请参考cvLoadImage。只有8位单通道或者3通道（通道顺序为’BGR’ ）可以使用这个函数保存。如果格式，深度或者通道不符合要求，请先用cvCvtScale 和cvCvtColor转换；或者使用通用的cvSave保存图像为XML或者YAML格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     IplImage * test=NULL;</span><br><span class="line">     test = cvLoadImage (&quot;D:\\demo.jpg&quot;);</span><br><span class="line">     cvNamedWindow(&quot;test_demo&quot;,1);</span><br><span class="line">	 cvMoveWindow(&quot;test_demo&quot;,800,10);</span><br><span class="line">     cvShowImage(&quot;test_demo&quot;,test);</span><br><span class="line">	 cvSaveImage(&quot;D:\\123.jpg&quot;,test);</span><br><span class="line">     cvWaitKey(0);</span><br><span class="line">     cvDestroyWindow(&quot;test_demo&quot;);</span><br><span class="line">     cvReleaseImage(&amp;test);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>OpenCV里有两个单词，Image，Window，它们各自代表的是载入的图像(用IplImage指针表示)，放置图像的窗口。<br>1.在存在Window的前提下,即cvNamedWindow(“窗口名”,是否根据Image进行调整的指标.)，<br>2.让IplImage指针指向Image,即cvLoadImage(“Image”,指针名).除去载入的方法外,也可以创建:<br>(1).定义一个CvSize类型的矩形sz.<br>(2).赋予其宽,高.sz=CvSize(640,480)<br>(3).p=cvCreateImage(sz,IPL_DEPTH_8U,3).第二个参数为深度,例为8位无符号整型,3通道.<br>3.再将Image导入Window，才能让Image显示出来,即cvShowImage(Window,image的指针).</p>
<p>另外，除了必要的知识外，大部分函数在使用的时候可以直接在博客开头的Page手册里查阅使用方案，系统全面的文档提供了很高的支持。感觉和Linux查阅技术文档来进行操作有些相同之处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#iclude&lt;stdio.h&gt;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp;                  /*定义一个文件指针*/</span><br><span class="line">	int i;</span><br><span class="line">	fp=fopen(&quot;CLIB&quot;, &quot;rb&quot;);    /*打开当前目录名为CLIB的文件只读*/ </span><br><span class="line">	if(fp==NULL)               /*判断文件是否打开成功*/</span><br><span class="line">		puts(&quot;File open error&quot;);/*提示打开不成功*/</span><br><span class="line">	i=fclose(fp);              /*关闭打开的文件*/</span><br><span class="line">	if(i==0)                   /*判断文件是否关闭成功*/</span><br><span class="line">		printf(&quot;O.K&quot;);           /*提示关闭成功*/</span><br><span class="line">	else                </span><br><span class="line">		puts(&quot;File close error&quot;);/*提示关闭不成功*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> int fprintf(FILE <em>stream, char </em>format, <variable-list>);<br>​        int fputs(char <em>string, FILE </em>steam);<br>int fputc(intch, FILE *steam);<br>fprintf() 函数的返回值为实际写入文件中的字符个数(字节数)。如果写错误, 则返回一个负数； fputs()函数返回0时表明将string指针所指的字符串写入文件中的操作成功, 返回非0时,表明写操作失败。  fputc()函数返回一个向文件所写字符的值, 此时写操作成功,否则返回EOF(文件结束结束其值为-1, 在stdio.h中定义)表示写操作错误。   fprintf( ) 函数中格式化的规定与printf( ) 函数相同,所不同的只是fprintf()函数是向文件中写入。而printf()是向屏幕输出。<br>4.文件的顺序读操作函数<br>​        fscanf()、fgets()和fgetc()函数<br>函数fscanf()、fgets()和fgetc()均为文件的顺序读操作函数, 其调用格式 如下:</variable-list></p>
<p>int fscanf(FILE <em>stream, char </em>format, <address-list>);<br>​        char fgets(char <em>string, int n, FILE </em>steam);<br>​        int fgetc(FILE *steam);<br>fscanf()函数的用法与scanf()函数相似,只是它是从文件中读到信息。 fscanf()函数的返回值为EOF(即-1), 表明读错误, 否则读数据成功。  fgets()函数从文件中读取至多n-1个字符(n用来指定字符数), 并把它们放入string指向的字符串中, 在读入之后自动向字符串未尾加一个空字符, 读成功返回string指针,  失败返回一个空指针。  fgetc()函数返回文件当前位置的一个字符,读错误时返回EOF。 </address-list></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void cvSmooth( const CvArr* src, CvArr* dst,</span><br><span class="line">               int smoothtype=CV_GAUSSIAN,</span><br><span class="line">               int param1=3, int param2=0, double param3=0, double param4=0 );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>src</p>
<p>输入图像.</p>
</li>
<li><p>dst</p>
<p>输出图像.</p>
</li>
<li><p>smoothtype</p>
<p>平滑方法:CV_BLUR_NO_SCALE (简单不带尺度变换的模糊) - 对每个象素的 param1×param2 领域求和。如果邻域大小是变化的，可以事先利用函数 cvIntegral 计算积分图像。CV_BLUR (simple blur) - 对每个象素param1×param2邻域 求和并做尺度变换 1/(param1•param2).CV_GAUSSIAN (gaussian blur) - 对图像进行核大小为 param1×param2 的高斯卷积CV_MEDIAN (median blur) - 对图像进行核大小为param1×param1 的中值滤波 (i.e. 邻域是方的).CV_BILATERAL (双向滤波) - 应用双向 3x3 滤波，彩色 sigma=param1，空间 sigma=param2. 关于双向滤波，可参考<a href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html" target="_blank" rel="noopener">http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a></p>
</li>
</ul>
<ul>
<li><p>param1</p>
<p>平滑操作的第一个参数.</p>
</li>
<li><p>param2</p>
<p>平滑操作的第二个参数. 对于简单/非尺度变换的高斯模糊的情况，如果param2的值 为零，则表示其被设定为param1。</p>
</li>
<li><p>param3</p>
<p>对应高斯参数的 Gaussian sigma (标准差). 如果为零，则标准差由下面的核尺寸计算：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigma = (n/2 - 1)*0.3 + 0.8, 其中 n=param1 对应水平核,</span><br><span class="line">                                 n=param2 对应垂直核.</span><br></pre></td></tr></table></figure>
<p>对小的卷积核 (3×3 to 7×7) 使用如上公式所示的标准 sigma 速度会快。如果 param3 不为零，而 param1 和 param2 为零，则核大小有 sigma 计算 (以保证足够精确的操作).</p>
<p>函数 cvSmooth 可使用上面任何一种方法平滑图像。每一种方法都有自己的特点以及局限。</p>
<p>没有缩放的图像平滑仅支持单通道图像，并且支持8位到16位的转换(与cvSobel和cvaplace相似)和32位浮点数到32位浮点数的变换格式。</p>
<p>简单模糊和高斯模糊支持 1- 或 3-通道, 8-比特 和 32-比特 浮点图像。这两种方法可以（in-place）方式处理图像。</p>
<p>中值和双向滤波工作于 1- 或 3-通道， 8-位图像，但是不能以 in-place 方式处理图像.</p>
<ul>
<li><p>中值滤波</p>
<p>中值滤波法是一种非线性平滑技术，它将每一象素点的灰度值设置为该点某邻域窗口内的所有象素点灰度值的中值。实现方法：</p>
</li>
</ul>
<ol>
<li>通过从图像中的某个采样窗口取出奇数个数据进行排序</li>
<li>用排序后的中值取代要处理的数据即可</li>
</ol>
<p>中值滤波法对消除椒盐噪音非常有效，在光学测量条纹图象的相位分析处理方法中有特殊作用，但在条纹中心分析方法中作用不大。中值滤波在图像处理中,常用于用来保护边缘信息,是经典的平滑噪声的方法</p>
<ul>
<li>中值滤波原理</li>
</ul>
<p>中值滤波是基于排序统计理论的一种能有效抑制噪声的非线性信号处理技术，中值滤波的基本原理是把数字图像或数字序列中一点的值用该点的一个拎域中各点值的中值代替，让周围的像素值接近的值，从而消除孤立的噪声点。方法是去某种结构的二维滑动模板，将板内像素按照像素值的大小进行排序，生成单调上升（或下降）的为二维数据序列。二维中值滤波输出为g（x,y）=med{f(x-k,y-l),(k,l∈W)} ，其中,f(x,y)，g(x,y)分别为原始图像和处理后图像。W为二维模板，通常为2<em>2，3</em>3区域，也可以是不同的的形状，如线状，圆形，十字形，圆环形等。</p>
<ul>
<li>高斯滤波</li>
</ul>
<p>高斯滤波实质上是一种信号的滤波器，其用途是信号的平滑处理，我们知道数字图像用于后期应用，其噪声是最大的问题，由于误差会累计传递等原因，很多图像处理教材会在很早的时候介绍Gauss滤波器，用于得到信噪比SNR较高的图像（反应真实信号）。于此相关的有Gauss-Lapplace变换，其实就是为了得到较好的图像边缘，先对图像做Gauss平滑滤波，剔除噪声，然后求二阶导矢，用二阶导的过零点确定边缘，在计算时也是频域乘积=&gt;空域卷积。</p>
<p>滤波器就是建立的一个数学模型，通过这个模型来将图像数据进行能量转化，能量低的就排除掉，噪声就是属于低能量部分</p>
<p>其实编程运算的话就是一个模板运算，拿图像的八连通区域来说，中间点的像素值就等于八连通区的像素值的均值，这样达到平滑的效果</p>
<p>若使用理想滤波器，会在图像中产生振铃现象。采用高斯滤波器的话，系统函数是平滑的，避免了振铃现象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例程序：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage *p = cvLoadImage(&quot;D:\\1234.jpg&quot;, 1);</span><br><span class="line">	IplImage *out = cvCreateImage(cvGetSize(p), IPL_DEPTH_8U, 3);</span><br><span class="line">	cvNamedWindow(&quot;cv_in&quot;, 1);</span><br><span class="line">	cvNamedWindow(&quot;cv_out&quot;, 1);</span><br><span class="line">	</span><br><span class="line">	cvShowImage(&quot;cv_in&quot;, p);</span><br><span class="line">	cvWaitKey(1024);</span><br><span class="line">	</span><br><span class="line">	cvSmooth(p, out, CV_GAUSSIAN, 3, 3);//from head file &lt;cv.h&gt;.</span><br><span class="line">	cvShowImage(&quot;cv_out&quot;, out);</span><br><span class="line">	cvWaitKey(1024);</span><br><span class="line"></span><br><span class="line">	//cvReleaseImage(&amp;p);</span><br><span class="line">	cvReleaseImage(&amp;out);</span><br><span class="line">	//加上上述两行就会报错，原因：</span><br><span class="line">	/*</span><br><span class="line">	在写相关程序的时候，在程序的结尾处释放前段自定义的变量。使用函数cvReleaseImage(&amp;pFrame);时程序在调试结束后报错，</span><br><span class="line">	指明是在释放内存时出错。经过看前辈们遇到的相同的问题。先总结如下：</span><br><span class="line"></span><br><span class="line">    cvReleaseImage()和cvCreateImage()相对应的。在程序中如果没有“创建”就不能“释放”。</span><br><span class="line">	所以，如果我们使用的指针不是用cvCreateImage()创建的。</span><br><span class="line">	如果使用cvReleaseImage()就会出现错误。如果大家担心指针不释放会引发内存的错误。</span><br><span class="line">	可以使用pFrame = NULL;来释放内存。</span><br><span class="line">	因为cvReleaseImage()的作用就是将作为参数的那个指针设置为NULL;</span><br><span class="line"></span><br><span class="line">	如修改后，只ReleaseOUT就不会出错.</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	cvDestroyAllWindows();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CvCapture 视频获取结构</span><br></pre></td></tr></table></figure>
<h2 id="cvCreateFileCapture"><a href="#cvCreateFileCapture" class="headerlink" title="cvCreateFileCapture"></a>cvCreateFileCapture</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CvCapture* cvCreateFileCapture( const char* filename );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>filename </p>
<p>视频文件名。</p>
</li>
</ul>
<p>函数cvCreateFileCapture给指定文件中的视频流分配和初始化CvCapture结构。</p>
<p>当分配的结构不再使用的时候，它应该使用cvReleaseCapture函数释放掉。</p>
<h2 id="cvReleaseCapture"><a href="#cvReleaseCapture" class="headerlink" title="cvReleaseCapture"></a>cvReleaseCapture</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvReleaseCapture( CvCapture** capture );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>capture </p>
<p>视频获取结构指针。</p>
</li>
</ul>
<p>函数cvReleaseCapture释放由函数cvCreateFileCapture或者cvCreateCameraCapture分配的CvCapture结构。</p>
<p>注:若从capture中使用cvQueryFrame获取图像指针，在releaseCapture的时候同时函数释放图像指针，用户不用再自己释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage *p; </span><br><span class="line">	CvCapture *capture = cvCreateFileCapture(&quot;D:\\123.avi&quot;);</span><br><span class="line">	cvNamedWindow(&quot;Image&quot;, 1);</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		p = cvQueryFrame(capture);</span><br><span class="line">		if (!p)</span><br><span class="line">			break;//if can&apos;t load image,p is NULL,and break.</span><br><span class="line">		cvShowImage(&quot;Image&quot;, p);</span><br><span class="line">		char c = cvWaitKey(1024);</span><br><span class="line">		if (c == 27)</span><br><span class="line">			break;//if you press Esc,c will get 27.</span><br><span class="line">	&#125;</span><br><span class="line">	cvReleaseCapture(&amp;capture);</span><br><span class="line">	cvReleaseImage(&amp;p);</span><br><span class="line">	cvDestroyWindow(Image);</span><br><span class="line">	return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像像素的获取：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 访问图像像素.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//way:</span><br><span class="line">//IplImage *Img = cvCreateImage(cvSize(640, 580), IPL_DEPTH_8U, 3);</span><br><span class="line">//1.间接访问:get*D,set*D...</span><br><span class="line">//2.直接访问:((*uchar)ImageData+i*Image-&gt;width)[j]=111;</span><br><span class="line">/*</span><br><span class="line">单通道：</span><br><span class="line">IplImage*img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,1);</span><br><span class="line">int height     =img-&gt;height; </span><br><span class="line">int width=img-&gt;width;  </span><br><span class="line">int step       =img-&gt;widthStep/sizeof(uchar); </span><br><span class="line">uchar* data    =(uchar*)img-&gt;imageData; </span><br><span class="line">data[i*step+j]=111;</span><br><span class="line">多通道：</span><br><span class="line">IplImage*img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,3);  </span><br><span class="line">int height     =img-&gt;height; </span><br><span class="line">int width      =img-&gt;width;  </span><br><span class="line">int step       =img-&gt;widthStep/sizeof(uchar); </span><br><span class="line">int channels   =img-&gt;nChannels;  </span><br><span class="line">uchar* data    =(uchar*)img-&gt;imageData; </span><br><span class="line">data[i*step+j*channels+k]=111;</span><br><span class="line">如果为浮点型矩阵，而非字节型，那就把uchar改为float.</span><br><span class="line">*/</span><br><span class="line">//3.利用宏:CV_IMAGE_ELEM</span><br><span class="line">//单通道:CV_IMAGE_ELEM(img,uchar,i,j)=111; img为IplImage指针</span><br><span class="line">//多通道:CV_IMAGE_ELEM(srcimg,uchar,i,j*3+0)=111;</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage *Image = cvCreateImage(cvSize(640,480), IPL_DEPTH_8U, 3);</span><br><span class="line">	CvScalar color;</span><br><span class="line">	int i, j;</span><br><span class="line">	for (i = 0; i &lt; 50; i++)//循环使i*j区域内的点全部变为黑色.</span><br><span class="line">	&#123;</span><br><span class="line">		for (j = 50; j &lt; 100; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			color = cvGet2D(Image, i, j);//get(x,y)&apos;s color.cal[0],color.cal[1].</span><br><span class="line"></span><br><span class="line">			//printf(&quot;cal0:%d\ncal1:%d\ncal2:%d\n&quot;, color.val[0], color.val[1], color.val[2]);</span><br><span class="line">			//若为单通道图像，只修改color.val[0]即可.</span><br><span class="line">			color.val[0] = 0;</span><br><span class="line">			color.val[1] = 0;</span><br><span class="line">			color.val[2] = 0;</span><br><span class="line">			cvSet2D(Image, i, j, color);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cvNamedWindow(&quot;ImageA&quot;, 1);</span><br><span class="line">	cvShowImage(&quot;ImageA&quot;, Image);</span><br><span class="line">	cvWaitKey(0);</span><br><span class="line">	cvDestroyAllWindows();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而cvSetXD中，固定参数为IplImage指针，X个Int类型的参数表示图上的坐标，以及可以将每个坐标的颜色分配修改的Scalar类。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像的边缘检测（根据像素梯度）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage *Image;</span><br><span class="line">	IplImage *out;</span><br><span class="line">	Image = cvLoadImage(&quot;D:\\1234.jpg&quot;, 0);</span><br><span class="line">	out = cvCreateImage(cvGetSize(Image), IPL_DEPTH_8U, 1);</span><br><span class="line">	cvNamedWindow(&quot;ImageA&quot;, 1);</span><br><span class="line">	cvNamedWindow(&quot;ImageB&quot;, 1);</span><br><span class="line">	cvCanny(Image, out, 50, 75, 3);</span><br><span class="line">	//cvCanny的第一个第二个参数均为指向单通道图片的IplImage.</span><br><span class="line">	//第三,第四个参数为阀值，一个大一个小，应当根据图像的梯度设定.</span><br><span class="line">	//第五个参数为canny算子3.</span><br><span class="line">	cvShowImage(&quot;ImageB&quot;, out);</span><br><span class="line">	cvWaitKey(0);</span><br><span class="line">	cvDestroyAllWindows();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>canny算子实质：如果一个像素的梯度大与上限值，则被认为是边缘像素，如果小于下限阈值，则被抛弃，那么如果该点的梯度位于两者之间，则当其与高于上限值的像素点连接时我们才保留，否则删除。另：当两个阀值等比例同时增大时（比如从50，150增加到100，300，比例并未改变），则图像上的杂点变少（边缘更加清晰）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于梯度的计算：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用自：http://www.cnblogs.com/justany/archive/2012/11/23/2782660.html</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像的边缘图像的边缘从数学上是如何表示的呢？图像的边缘上，邻近的像素值应当显著地改变了。而在数学上，导数是表示改变快慢的一种方法。梯度值的大变预示着图像中内容的显著变化了。用更加形象的图像来解释,假设我们有一张一维图形。下图中灰度值的“跃升”表示边缘的存在：　　　　使用一阶微分求导我们可以更加清晰的看到边缘“跃升”的存在(这里显示为高峰值)：　　　　由此我们可以得出：边缘可以通过定位梯度值大于邻域的相素的方法找到。 卷积卷积可以近似地表示求导运算。那么卷积是什么呢？卷积是在每一个图像块与某个算子（核）之间进行的运算。核？！核就是一个固定大小的数值数组。该数组带有一个锚点 ，一般位于数组中央。 可是这怎么运算啊？假如你想得到图像的某个特定位置的卷积值，可用下列方法计算：将核的锚点放在该特定位置的像素上，同时，核内的其他值与该像素邻域的各像素重合；将核内各值与相应像素值相乘，并将乘积相加；将所得结果放到与锚点对应的像素上；对图像所有像素重复上述过程。用公式表示上述过程如下：　　　　在图像边缘的卷积怎么办呢？计算卷积前，OpenCV通过复制源图像的边界创建虚拟像素，这样边缘的地方也有足够像素计算卷积了。 近似梯度比如内核为3时。首先对x方向计算近似导数：然后对y方向计算近似导数：然后计算梯度：当然你也可以写成：求梯度的例程序：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;#include &quot;opencv2/imgproc/imgproc.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int main( int argc, char** argv )&#123;</span><br><span class="line"></span><br><span class="line">    Mat src, src_gray;</span><br><span class="line">    Mat grad;</span><br><span class="line">    char* window_name = &quot;求解梯度&quot;;</span><br><span class="line">    int scale = 1;</span><br><span class="line">    int delta = 0;</span><br><span class="line">    int ddepth = CV_16S;</span><br><span class="line"></span><br><span class="line">    int c;</span><br><span class="line"></span><br><span class="line">    src = imread( argv[1] );</span><br><span class="line"></span><br><span class="line">    if( !src.data )&#123; </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //高斯模糊</span><br><span class="line">    GaussianBlur( src, src, Size(3,3), 0, 0, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">    //转成灰度图</span><br><span class="line">    cvtColor( src, src_gray, CV_RGB2GRAY );</span><br><span class="line"></span><br><span class="line">    namedWindow( window_name, CV_WINDOW_AUTOSIZE );</span><br><span class="line"></span><br><span class="line">    Mat grad_x, grad_y;</span><br><span class="line">    Mat abs_grad_x, abs_grad_y;</span><br><span class="line"></span><br><span class="line">    Sobel( src_gray, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_x, abs_grad_x );</span><br><span class="line"></span><br><span class="line">    Sobel( src_gray, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_y, abs_grad_y );</span><br><span class="line"></span><br><span class="line">    addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );</span><br><span class="line"></span><br><span class="line">    imshow( window_name, grad );</span><br><span class="line"></span><br><span class="line">    waitKey(0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>Sobel函数</p>
<blockquote>
<p>索贝尔算子（Sobel operator）计算。</p>
<ul>
<li>C++:<code></code>void <code>Sobel</code>(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize=3, double scale=1, double delta=0, intborderType=BORDER_DEFAULT )</li>
</ul>
</blockquote>
<p>代码注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在x方向求图像近似导数</span><br><span class="line">Sobel( src_gray, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">//在y方向求图像近似导数</span><br><span class="line">Sobel( src_gray, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT );</span><br></pre></td></tr></table></figure>
<p>如果我们打印上面两个输出矩阵，可以看到grad_x和grad_y中的元素有正有负。</p>
<p>当然，正方向递增就是正的，正方向递减则是负值。</p>
<p>这很重要，我们可以用来判断梯度方向。</p>
<p>convertScaleAbs函数</p>
<blockquote>
<p>线性变换转换输入数组元素成8位无符号整型。</p>
<ul>
<li>C++:<code></code>void <code>convertScaleAbs</code>(InputArray src, OutputArray dst, double alpha=1, double beta=0)</li>
</ul>
<p>对于每个输入数组的元素函数<code>convertScaleAbs</code> 进行三次操作依次是：缩放，得到一个绝对值，转换成无符号8位类型。</p>
<p><img src="http://docs.opencv.org/_images/math/5ca28093f0a8eca32bcf6d54a644b4bcaa07ad72.png" alt="\texttt{dst} (I)= \texttt{saturate\_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} +  \texttt{beta} |)"></p>
<p>对于多通道矩阵，该函数对各通道独立处理。如果输出不是8位，将调用<code>Mat::convertTo</code>方法并计算结果的绝对值，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mat_&lt;float&gt; A(30,30);</span><br><span class="line">&gt; randu(A, Scalar(-100), Scalar(100));</span><br><span class="line">&gt; Mat_&lt;float&gt; B = A*5 + 3;</span><br><span class="line">&gt; B = abs(B);</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>为了能够用图像显示，提供一个直观的图形，我们利用该方法，将-256 — 255的导数值，转成0 — 255的无符号8位类型。</p>
<p>addWeighted函数</p>
<blockquote>
<p>计算两个矩阵的加权和。</p>
<ul>
<li>C++:<code></code>void <code>addWeighted</code>(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, intdtype=-1)</li>
</ul>
<p>函数<code>addWeighted</code> 两个数组的加权和公式如下：</p>
<p>　　　　<img src="http://docs.opencv.org/_images/math/160c3479896ac799bb5c7d260a052e6b35c463ef.png" alt="\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +  \texttt{gamma} )"></p>
<p>在多通道情况下，每个通道是独立处理的，该函数可以被替换成一个函数表达式：</p>
<p>　　　　dst = src1<em>alpha + src2</em>beta + gamma;</p>
</blockquote>
<p>利用convertScaleAbs和addWeighted，我们可以对梯度进行一个可以用图像显示的近似表达。</p>
<p>这样我们就可以得到下面的效果：</p>
<p><img src="http://docs.opencv.org/_images/Sobel_Derivatives_Tutorial_Result.jpg" alt="Result of applying Sobel operator to lena.jpg"></p>
<p>梯度方向</p>
<p>但有时候边界还不够，我们希望得到图片色块之间的关系，或者研究样本的梯度特征来对机器训练识别物体时候，我们还需要梯度的方向。</p>
<p>二维平面的梯度定义为：</p>
<p>　　　　<img src="http://pic002.cnblogs.com/images/2012/372204/2012112220142684.jpg" alt="img"></p>
<p>这很好理解，其表明颜色增长的方向与x轴的夹角。</p>
<p>但Sobel算子对于沿x轴和y轴的排列表示的较好，但是对于其他角度表示却不够精确。这时候我们可以使用Scharr滤波器。</p>
<p>Scharr滤波器的内核为：</p>
<p>　　　　<img src="http://docs.opencv.org/_images/math/d1340f7bb6665e67c94c196809095f23054fca2c.png" alt="G_{x} = \begin{bmatrix}-3 &amp; 0 &amp; +3  \\-10 &amp; 0 &amp; +10  \\-3 &amp; 0 &amp; +3\end{bmatrix}G_{y} = \begin{bmatrix}-3 &amp; -10 &amp; -3  \\0 &amp; 0 &amp; 0  \\+3 &amp; +10 &amp; +3\end{bmatrix}"></p>
<p>这样能提供更好的角度信息，现在我们修改原程序，改为使用Scharr滤波器进行计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;#include &quot;opencv2/imgproc/imgproc.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int main( int argc, char** argv )&#123;</span><br><span class="line"></span><br><span class="line">    Mat src, src_gray;</span><br><span class="line">    Mat grad;</span><br><span class="line">    char* window_name = &quot;梯度计算&quot;;</span><br><span class="line">    int scale = 1;</span><br><span class="line">    int delta = 0;</span><br><span class="line">    int ddepth = CV_16S;</span><br><span class="line"></span><br><span class="line">    int c;</span><br><span class="line"></span><br><span class="line">    src = imread( argv[1] );</span><br><span class="line"></span><br><span class="line">    if( !src.data )&#123; </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GaussianBlur( src, src, Size(3,3), 0, 0, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">    cvtColor( src, src_gray, CV_RGB2GRAY );</span><br><span class="line"></span><br><span class="line">    namedWindow( window_name, CV_WINDOW_AUTOSIZE );</span><br><span class="line"></span><br><span class="line">    Mat grad_x, grad_y;</span><br><span class="line">    Mat abs_grad_x, abs_grad_y;</span><br><span class="line"></span><br><span class="line">    //改为Scharr滤波器计算x轴导数</span><br><span class="line">    Scharr( src_gray, grad_x, ddepth, 1, 0, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_x, abs_grad_x );</span><br><span class="line"></span><br><span class="line">    //改为Scharr滤波器计算y轴导数</span><br><span class="line">    Scharr( src_gray, grad_y, ddepth, 0, 1, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_y, abs_grad_y );</span><br><span class="line"></span><br><span class="line">    addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );</span><br><span class="line"></span><br><span class="line">    imshow( window_name, grad );</span><br><span class="line"></span><br><span class="line">    waitKey(0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;&lt;/span&gt;&lt;strong style=&quot;font-size:24px;&quot;&gt;</span><br><span class="line">&lt;/strong&gt;</span><br></pre></td></tr></table></figure>
<p>Scharr函数接受参数与Sobel函数相似，这里就不叙述了。</p>
<p>下面我们通过divide函数就能得到一个x/y的矩阵。</p>
<blockquote>
<p>对两个输入数组的每个元素执行除操作。</p>
<ul>
<li>C++:<code></code>void <code>divide</code>(InputArray src1, InputArray src2, OutputArray dst, double scale=1, int dtype=-1)</li>
</ul>
<ul>
<li>C++:<code></code>void <code>divide</code>(double scale, InputArray src2, OutputArray dst, int dtype=-1)</li>
</ul>
<p>该函数对两个数组进行除法：</p>
<p>　　<img src="http://docs.opencv.org/_images/math/b95a5073fc087b8fc404bc7795982e1570891bd3.png" alt="\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}"></p>
<p>或则只是缩放系数除以一个数组：</p>
<p>　　<img src="http://docs.opencv.org/_images/math/8d762e1a527b3613404ec26a98faffd43d1ceb78.png" alt="\texttt{dst(I) = saturate(scale/src2(I))}"></p>
<p>这种情况如果src2是0，那么dst也是0。不同的通道是独立处理的。</p>
</blockquote>
</cxcore.h></ml.h></highgui.h></cvaux.h></cv.h>
            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/opencv/">opencv</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/11/AC自动机/" data-tooltip="AC自动机" aria-label="Prev: AC自动机">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">Prev</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/11/HDU-1247-字典树/" data-tooltip="HDU 1247 字典树" aria-label="Next: HDU 1247 字典树">
                
                    <span class="hide-xs hide-sm text-small icon-mr">Next</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/" title="分享到 Facebook">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/" title="分享到 Twitter">
                    <i class="fa fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/" title="分享到 Google+">
                    <i class="fa fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/&amp;title=OpenCV 随笔记录" title="分享到 QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#gitment">
                         <i class="fa fa-comment-o"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="gitment"></div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 Tianyou Pan. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/11/AC自动机/" data-tooltip="AC自动机" aria-label="Prev: AC自动机">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">Prev</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/02/11/HDU-1247-字典树/" data-tooltip="HDU 1247 字典树" aria-label="Next: HDU 1247 字典树">
                
                    <span class="hide-xs hide-sm text-small icon-mr">Next</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/" title="分享到 Facebook">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/" title="分享到 Twitter">
                    <i class="fa fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/" title="分享到 Google+">
                    <i class="fa fa-google-plus" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/&amp;title=OpenCV 随笔记录" title="分享到 QQ">
                    <i class="fa fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/" title="分享到 Qzone">
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#gitment">
                         <i class="fa fa-comment-o"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-close"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/">
                    <i class="fa fa-facebook-official" aria-hidden="true"></i><span>分享到 Facebook</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/">
                    <i class="fa fa-twitter" aria-hidden="true"></i><span>分享到 Twitter</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/">
                    <i class="fa fa-google-plus" aria-hidden="true"></i><span>分享到 Google+</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/&amp;title=OpenCV 随笔记录">
                    <i class="fa fa-qq" aria-hidden="true"></i><span>分享到 QQ</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=sherry0429.github.io/2018/02/11/OpenCV-随笔记录/">
                    <i class="fa fa-star" aria-hidden="true"></i><span>分享到 Qzone</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/handface.jpg" alt="author‘s picture"/>
        
            <h4 id="about-card-name">Tianyou Pan</h4>
        
            <div id="about-card-bio"><p>光阴似箭，日月如梭，然而，人可以老，力可以衰，心却不能死，理想也不能灭…</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Python Developer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                China.SiChuan
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/zongsi.png');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-t6ztvrkwotqq30w08guadl2mq4yn3gvnrzqwy1ojd4f6nrkqjn6kcdzdwznj.min.js"></script>
<!--SCRIPTS END-->

    
        <script type="text/javascript">
            (function() {
                function render() {
                    new Gitment({
                        id: 'sherry0429.github.io/2018/02/11/OpenCV-随笔记录/',
                        owner: 'sherry0429',
                        repo: 'gitment-comments',
                        oauth: {
                            client_id: '8682c4503f3fef4dd481',
                            client_secret: '184d8c122cd7cc7253584abe91ea240109a98738',
                        }
                    }).render('gitment');
                }
                var gc = document.createElement('script');
                gc.type = 'text/javascript';
                gc.src = '//sherry0429.github.io/gitment.browser.js';
                gc.charset = 'UTF-8';
                gc.onload = render;
                gc.async = true;
                document.querySelector('body').appendChild(gc);
                var gcs = document.createElement('link');
                gcs.href = '//imsun.github.io/gitment/style/default.css';
                gcs.type = 'text/css';
                gcs.rel = 'stylesheet';
                gcs.media = 'screen,print';
                document.querySelector('head').appendChild(gcs);
            })();
	    </script>
    



    </body>
</html>
