<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Monster &amp; Flower</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="sherry0429.github.io/"/>
  <updated>2018-02-11T09:05:39.271Z</updated>
  <id>sherry0429.github.io/</id>
  
  <author>
    <name>Tianyou Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KMP</title>
    <link href="sherry0429.github.io/2018/02/11/KMP/"/>
    <id>sherry0429.github.io/2018/02/11/KMP/</id>
    <published>2018-02-11T07:19:59.000Z</published>
    <updated>2018-02-11T09:05:39.271Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 100000</span></span><br><span class="line"><span class="keyword">int</span> T[MAXN],P[MAXM],Next[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeNext</span><span class="params">(<span class="keyword">int</span> M)</span><span class="comment">//找到一个匹配位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;M)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span> || P[i]==P[j])</span><br><span class="line">&#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">            <span class="keyword">if</span>(P[i]!=P[j])</span><br><span class="line">Next[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">Next[i] = Next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">j = Next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span> M)</span><span class="comment">//进行匹配</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;N &amp;&amp; j&lt;M)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[i]==P[j] || j==<span class="number">-1</span>)</span><br><span class="line">i++,j++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">j = Next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==M)</span><br><span class="line"><span class="keyword">return</span> i-M+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,M,C;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;C);</span><br><span class="line">    <span class="keyword">while</span>(C--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;N,&amp;M);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T[i]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;P[i]);</span><br><span class="line">        <span class="keyword">if</span>(M&gt;N)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">            MakeNext(M);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,KMP(N,M));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="code_template" scheme="sherry0429.github.io/categories/code-template/"/>
    
    
      <category term="c, kmp" scheme="sherry0429.github.io/tags/c-kmp/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode #003 Longest Substring Without Repeating Characters</title>
    <link href="sherry0429.github.io/2018/02/11/LeetCode-003-Longest-Substring-Without-Repeating-Characters/"/>
    <id>sherry0429.github.io/2018/02/11/LeetCode-003-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2018-02-11T06:58:00.000Z</published>
    <updated>2018-02-11T09:05:53.328Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><p>#003 Longest Substring Without Repeating Characters</p><blockquote><p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p><p>Input: abcabccbb<br>Output: 3<br>题意：找到一个字符串中，没有重复字符的最长子串，返回它的长度</p><p>#####思路：</p><ol><li>做一个一维数组HashTable，下标为字符的ASCII码，值为这个字符在字符串中的位置，初始化为-1</li><li>设置一个变量LastPosition表示不重复最长串的第一个元素的下标</li><li>遍历字符串，依次检测该字符是否存在HashTable中，例：<br><code>HashTable[&#39;a&#39;]=-1</code>表示该字符第一次出现。<br><code>HashTable[&#39;a&#39;]=2</code>表示该字符上一次出现的位置在str[2].</li><li>如果第一次出现该字符a，HashTable[‘a’]=字符’a’在字符串中的位置.</li><li>如果已经出现过字符’a’，如果上一次’a’在目前检测串中，则置LastPosition为a的下标（即上一次LastPostion）。否则置LastPosition为当前检测字符的下标（HashTable[temp]）。<br>该下标一定为：<code>LastPosition=std::max(LastPosition,HashTable[temp]);</code></li><li>Max为<code>HashTable[temp]-LastPostion</code>所能得到的最大值<br>| a | b | c | d | a |<br>| – |</li></ol></blockquote><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>5</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>#####代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> LastPosition=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> HashTable[<span class="number">255</span>]=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=(<span class="keyword">int</span>)s[i];</span><br><span class="line">            <span class="keyword">if</span>(HashTable[temp]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                LastPosition=<span class="built_in">std</span>::max(LastPosition,HashTable[temp]);</span><br><span class="line">            &#125;</span><br><span class="line">            HashTable[temp]=i+<span class="number">1</span>;</span><br><span class="line">            Max=<span class="built_in">std</span>::max(Max,HashTable[temp]-LastPosition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>#####知识点</p><ol><li>字符串中寻找最长符合要求的子串</li><li>难点：当检测到重复字符时，应该从何处继续检测</li><li>还有一种DP解法如下，其实上面的代码也是DP，DP指通过状态转移来解决问题的一种思路，每一种状态的决定总是与上一次状态有联系，以下代码中，Flag数组就是一种记录状态，而Longest每次依赖于上一次Longest还有Flag数组中的状态，因此说这种解决思路是一种DP思路。这个代码由LeetCode上的prime_tang所写，此处为引用。我询问后，他对DP思路的描述原文如下：<blockquote><p>In my understanding, the dynamic programming is: every decision depends on the current status, and immediately cause the transfer of status. In this problem, flag is the status, and we can get the longest every time depends on the previous longest and the flag, so I think it also can be seen as DP solution, even though not obvious compared to the Maximum Subarray problem.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, longest = <span class="number">0</span>, len = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[s[i]] &gt;= start) &#123;</span><br><span class="line">                longest = <span class="built_in">std</span>::max(longest, i - start);</span><br><span class="line">                start = flag[s[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(longest, len - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;p&gt;#003 Longest Substring Without Repeating Characters&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a string, find the length of the 
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, leetcode" scheme="sherry0429.github.io/tags/c-leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode #002 Add Two Numbers</title>
    <link href="sherry0429.github.io/2018/02/11/LeetCode-002-Add-Two-Numbers/"/>
    <id>sherry0429.github.io/2018/02/11/LeetCode-002-Add-Two-Numbers/</id>
    <published>2018-02-11T06:57:37.000Z</published>
    <updated>2018-02-11T09:05:50.579Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><p>#002 Add Two Numbers</p><blockquote><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p><p>#####思路：</p><ol><li>建立一个新的链表List</li><li>依次检测两个链表节点是否为空，不为空则检测值</li><li>如果检测到值，<code>int value = val1 + val2 + remain;</code></li><li>val1=l1-&gt;val,val2=l2-&gt;val,它们被初始化为0,remain为进位值.</li><li>将value存入List节点里<br>#####代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> remain = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//new list</span></span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//head node,it is empty.</span></span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="literal">NULL</span> &amp;&amp; l2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1==<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> ||  l2 != <span class="literal">NULL</span>)<span class="comment">//only two list get end,while will be finish.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = <span class="number">0</span>, val2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            val1 = l1-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            val2 = l2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = val1 + val2 + remain;</span><br><span class="line">        remain = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(value &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            value -= <span class="number">10</span>;<span class="comment">//value = value % 10</span></span><br><span class="line">            remain = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//build List</span></span><br><span class="line">        ListNode * pos = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">        p-&gt;next = pos;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if ABCDE</span></span><br><span class="line"><span class="comment">    if FGHIG</span></span><br><span class="line"><span class="comment">    AND IF E+G&gt;10</span></span><br><span class="line"><span class="comment">    we need make a new node,it's val is (E+G)%10.</span></span><br><span class="line"><span class="comment">    like this:</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(remain != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pos = <span class="keyword">new</span> ListNode(remain);</span><br><span class="line">        p-&gt;next = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    <span class="comment">//!!!__Don't return head because head is empty,head-&gt;next is first node with val.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>#####知识点</p><ol><li>如何用尾插法建立链表</li><li>同时遍历两个链表并进行相应处理（均遍历到结尾时处理才结束）</li><li>当遍历A节点时，得到需要处理A-&gt;next的信息，如何在遍历时延后一步处理。<ol><li>方案1：用一个Bool量标记是否应当处理，在建表后的语句中加入处理语句</li><li>方案2：类似这种求和，将信息保留在remain中，每次加上remain，无信息则remain=0,否则remain=溢出数.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案1</span></span><br><span class="line"><span class="keyword">bool</span> deal=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">....<span class="comment">//here you build list</span></span><br><span class="line"><span class="keyword">if</span>(deal)&#123;</span><br><span class="line">....<span class="comment">//here you deal something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方案2</span></span><br><span class="line"><span class="keyword">int</span> value = val1 + val2 + remain;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;p&gt;#002 Add Two Numbers&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given two linked lists representing two non-negative numbers. 
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, leetcode" scheme="sherry0429.github.io/tags/c-leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode #001 Two Num</title>
    <link href="sherry0429.github.io/2018/02/11/LeetCode-001-Two-Num/"/>
    <id>sherry0429.github.io/2018/02/11/LeetCode-001-Two-Num/</id>
    <published>2018-02-11T06:57:22.000Z</published>
    <updated>2018-02-11T09:05:47.149Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><p>#01 Two Num</p><blockquote><p>Given an array of integers, find two numbers such that they add up to a specific target number.<br>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br>You may assume that each input would have exactly one solution.</p><p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p><p>#####思路1：</p><ol><li>用STL Map，将数据存入Map，而后查找First和Target-First是否都存在，如都存在，输出他们的下标。（即First，Target-First对应的Value）.</li><li>迭代器iterator两个域,iterator-&gt;first对应Key,iterator-&gt;second对应Value.</li><li>循环遍历Nums，检测Map，跳过Nums下标为Map-Value的元素。（重要）<br>#####代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Map;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> solve;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            Map[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (Map[temp]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="comment">//this if is important</span></span><br><span class="line">                <span class="keyword">if</span>(i == Map[temp])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//Map's value don't need in 'for' fuction.</span></span><br><span class="line">                &#125;</span><br><span class="line">                solve.push_back(i+<span class="number">1</span>);</span><br><span class="line">                solve.push_back(Map[temp]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> solve;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> solve;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>####思路2</p><ol><li>分配一个数组空间，将数据拷贝至A</li><li>将A数组排序</li><li>建立两个查找指针头指针X,尾指针Y,依次相加比较指针所指的值E,F</li><li>E大于F Y++</li><li>E小于F X++</li><li>当指针相等或相交时退出循环</li><li>提前退出循环说明找到了E+F=target</li><li>遍历nums，当值与找到的E,F相等时,将相应的下标Push进Vector</li></ol><p>#####代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt;temp;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;index;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; len;i++)</span></span><br><span class="line">        <span class="comment">//  temp.push_back(nums[i]);</span></span><br><span class="line">        <span class="comment">//sort(temp.begin(),temp.end());</span></span><br><span class="line">        qsort(temp,len,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),compare);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((temp[left] + temp[right]) &gt; target)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((temp[left] + temp[right]) &lt; target)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == temp[left] || nums[i] == temp[right])</span><br><span class="line">                index.push_back(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> []temp;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>#####知识点</p><ol><li>在一个数组中查找指定元素</li><li>对数组元素进行排序</li><li>得到排序数组中比某数小或大的区域（该数不一定存在在数组内）</li><li>知道一组值，求与这组值有关的另一组值</li><li>方法2的一种特殊思路.</li></ol><p>#####官网给出的Solution</p><blockquote><p>####O(n2) runtime, O(1) space – Brute force:</p><p>The brute force approach is simple. Loop through each element x and find if there is another value that equals to target – x. As finding another value requires looping through the rest of array, its runtime complexity is O(n2).</p><p>####O(n) runtime, O(n) space – Hash table:</p><p>We could reduce the runtime complexity of looking up a value to O(1) using a hash map that maps a value to its index.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;p&gt;#01 Two Num&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an array of integers, find two numbers such that they add up to a specifi
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, leetcode" scheme="sherry0429.github.io/tags/c-leetcode/"/>
    
  </entry>
  
  <entry>
    <title>C++文件流 总结</title>
    <link href="sherry0429.github.io/2018/02/11/C-%E6%96%87%E4%BB%B6%E6%B5%81-%E6%80%BB%E7%BB%93/"/>
    <id>sherry0429.github.io/2018/02/11/C-文件流-总结/</id>
    <published>2018-02-11T06:54:35.000Z</published>
    <updated>2018-02-11T09:04:33.945Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><h1 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h1><p>首先，需要加<fstream>头文件。（即file stream），在包含这个头文件后，可使用三种类：</fstream></p><ul><li>ofstream  写文件  （Output File Stream）  <ul><li>使用方法: 文件名&lt;&lt;内容&lt;&lt;endl;</li></ul></li><li>ifstream   读文件 （Input File Stream）  <ul><li>使用方法:文件名&gt;&gt;内容;</li></ul></li><li>fstream  打开文件供读写  （File Stream） <ul><li>利用各种参数达到控制文件读写的目的</li></ul></li></ul><h1 id="Same"><a href="#Same" class="headerlink" title="Same"></a>Same</h1><p>每个类都有相同的两种函数功能：</p><ul><li>X.open(“String”);   <ul><li>//String为路径，也可以string str；X.open(str);(用string类，没有引号，但是string本身内容里最后4个单位应为.txt）</li><li>如果用fstream创建文件 必须加Ios::out.</li></ul></li><li>X.close();</li></ul><p>同一时间，同一文件只能由一种类进行操作。若需要换，必须先将此类指针关闭，再用需要的类的指针Open目标文件。</p><h1 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h1><p>fstream的open函数的参数定义了文件的打开模式。总共有如下模式：</p><ul><li>ios::in 读</li><li>ios::out 写</li><li>ios::app 从文件末尾开始写</li><li>ios::binary       二进制模式</li><li>ios::nocreate 打开一个文件时，如果文件不存在，不创建文件。</li><li>ios::noreplace  打开一个文件时，如果文件不存在，创建该文件</li><li>ios::trunc 打开一个文件，然后清空内容</li><li>ios::ate 打开一个文件时，将位置移动到文件尾</li></ul><p>使用方式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.open(<span class="string">"file.ext"</span>,iso::in|ios::out)</span><br></pre></td></tr></table></figure><ul><li>默认模式是文本</li><li>默认如果文件不存在，那么创建一个新的</li><li>多种模式可以混合，用|(按位或)</li><li>文件的byte索引从0开始。（就像数组一样）</li></ul><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><ul><li>good()<ul><li>如果文件打开成功</li></ul></li><li>bad() <ul><li>打开文件时发生错误</li></ul></li><li>eof() <ul><li>到达文件尾</li></ul></li></ul><h2 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h2><ul><li>seekg() </li><li>tellg()</li><li>seekp()          </li><li>tellq()</li></ul><p>以g结尾的，处理get指针（ifstream），以p结尾的，处理put指针（ofstream）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seekg/p(X,INF);</span><br></pre></td></tr></table></figure><p>X为一个数，可为正可为负，INF为一个参数，该参数可为以下：</p><ul><li>ios::beg  文件头</li><li>ios::end  文件尾</li><li>ios::cur  当前位置</li></ul><p>整个函数表示将指针从INF处，移动X个单位。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seekg(<span class="number">-1</span>,ios::end);<span class="comment">//把指针从文件尾向前移动一个字节</span></span><br></pre></td></tr></table></figure><p>tellg, tellp : 返回一个数，表示此时指针所在的位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;h1 id=&quot;Prepare&quot;&gt;&lt;a href=&quot;#Prepare&quot; class=&quot;headerlink&quot; title=&quot;Prepare&quot;&gt;&lt;/a&gt;Prepare&lt;/h1&gt;&lt;p&gt;首先，需要加&lt;fstream&gt;头文件。（即fil
      
    
    </summary>
    
      <category term="think" scheme="sherry0429.github.io/categories/think/"/>
    
    
      <category term="c++, file" scheme="sherry0429.github.io/tags/c-file/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="sherry0429.github.io/2018/02/11/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>sherry0429.github.io/2018/02/11/AC自动机/</id>
    <published>2018-02-11T06:52:54.000Z</published>
    <updated>2018-02-11T09:04:27.247Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><p>source link: <a href="http://blog.csdn.net/niushuai666/article/details/7002823" target="_blank" rel="noopener">http://blog.csdn.net/niushuai666/article/details/7002823</a></p><h1 id="AC自动机简介："><a href="#AC自动机简介：" class="headerlink" title="AC自动机简介："></a>AC自动机简介：</h1><p>##AC自动机的构造：</p><ul><li><p>构造一棵Trie，作为AC自动机的搜索数据结构。</p></li><li><p>构造fail指针，使当前字符失配时跳转到具有最长公共前后缀的字符继续匹配。</p><p>如同 KMP算法一样， AC自动机在匹配时如果当前字符匹配失败，那么利用fail指针进行跳转。由此可知如果跳转，跳转后的串的前缀，必为跳转前的模式串的后缀并且跳转的新位置的深度（匹配字符个数）一定小于跳之前的节点。所以我们可以利用 bfs在 Trie上面进行 fail指针的求解。</p></li><li><p>扫描主串进行匹配。</p></li></ul><h2 id="AC自动机详讲："><a href="#AC自动机详讲：" class="headerlink" title="AC自动机详讲："></a>AC自动机详讲：</h2><p>我们给出5个单词，say，she，shr，he，her。给定字符串为yasherhs。问多少个单词在字符串中出现过。</p><p><strong>一、Trie</strong></p><p>首先我们需要建立一棵Trie。但是这棵Trie不是普通的Trie，而是带有一些特殊的性质。</p><p>首先会有3个重要的指针，分别为p, p-&gt;fail, temp。</p><p>1.指针p，指向当前匹配的字符。若p指向root，表示当前匹配的字符序列为空。（root是Trie入口，没有实际含义）。</p><p>2.指针p-&gt;fail，p的失败指针，指向与字符p相同的结点，若没有，则指向root。</p><p>3.指针temp，测试指针（自己命名的，容易理解！~），在建立fail指针时有寻找与p字符匹配的结点的作用，在扫描时作用最大，也最不好理解。</p><p>对于Trie树中的一个节点，对应一个序列s[1…m]。此时，p指向字符s[m]。若在下一个字符处失配，即p-&gt;next[s[m+1]] == NULL，则由失配指针跳到另一个节点(p-&gt;fail)处，该节点对应的序列为s[i…m]。若继续失配，则序列依次跳转直到序列为空或出现匹配。在此过程中，p的值一直在变化，但是p对应节点的字符没有发生变化。在此过程中，我们观察可知，最终求得得序列s则为最长公共后缀。另外，由于这个序列是从root开始到某一节点，则说明这个序列有可能是某些序列的前缀。</p><p>再次讨论p指针转移的意义。如果p指针在某一字符s[m+1]处失配(即p-&gt;next[s[m+1]] == NULL)，则说明没有单词s[1…m+1]存在。此时，如果p的失配指针指向root，则说明当前序列的任意后缀不会是某个单词的前缀。如果p的失配指针不指向root，则说明序列s[i…m]是某一单词的前缀，于是跳转到p的失配指针，以s[i…m]为前缀继续匹配s[m+1]。</p><p>对于已经得到的序列s[1…m]，由于s[i…m]可能是某单词的后缀，s[1…j]可能是某单词的前缀，所以s[1…m]中可能会出现单词。此时，p指向已匹配的字符，不能动。于是，令temp = p，然后依次测试s[1…m], s[i…m]是否是单词。</p><p>构造的Trie为：</p><p><img src="http://www.cppblog.com/images/cppblog_com/mythit/ac1.jpg" alt="img"></p><p><strong>二、构造失败指针</strong></p><p>用BFS来构造失败指针，与KMP算法相似的思想。</p><p>首先，root入队，第1次循环时处理与root相连的字符，也就是各个单词的第一个字符h和s，因为第一个字符不匹配需要重新匹配，所以第一个字符都指向root（root是Trie入口，没有实际含义）失败指针的指向对应下图中的(1)，(2)两条虚线；第2次进入循环后，从队列中先弹出h，接下来p指向h节点的fail指针指向的节点，也就是root；p=p-&gt;fail也就是p=NULL说明匹配序列为空，则把节点e的fail指针指向root表示没有匹配序列，对应图-2中的(3)，然后节点e进入队列；第3次循环时，弹出的第一个节点a的操作与上一步操作的节点e相同，把a的fail指针指向root，对应图-2中的(4)，并入队；第4次进入循环时，弹出节点h(图中左边那个)，这时操作略有不同。由于p-&gt;next[i]!=NULL(root有h这个儿子节点，图中右边那个)，这样便把左边那个h节点的失败指针指向右边那个root的儿子节点h，对应图-2中的(5)，然后h入队。以此类推：在循环结束后，所有的失败指针就是图-2中的这种形式。</p><p><img src="http://www.cppblog.com/images/cppblog_com/mythit/ac2.JPG" alt="img"></p><p><strong>三、扫描</strong></p><p>构造好Trie和失败指针后，我们就可以对主串进行扫描了。这个过程和KMP算法很类似，但是也有一定的区别，主要是因为AC自动机处理的是多串模式，需要防止遗漏某个单词，所以引入temp指针。</p><p>匹配过程分两种情况：(1)当前字符匹配，表示从当前节点沿着树边有一条路径可以到达目标字符，此时只需沿该路径走向下一个节点继续匹配即可，目标字符串指针移向下个字符继续匹配；(2)当前字符不匹配，则去当前节点失败指针所指向的字符继续匹配，匹配过程随着指针指向root结束。重复这2个过程中的任意一个，直到模式串走到结尾为止。</p><p> 对照上图，看一下模式匹配这个详细的流程，其中模式串为yasherhs。对于i=0,1。Trie中没有对应的路径，故不做任何操作；i=2,3,4时，指针p走到左下节点e。因为节点e的count信息为1，所以cnt+1，并且讲节点e的count值设置为-1，表示改单词已经出现过了，防止重复计数，最后temp指向e节点的失败指针所指向的节点继续查找，以此类推，最后temp指向root，退出while循环，这个过程中count增加了2。表示找到了2个单词she和he。当i=5时，程序进入第5行，p指向其失败指针的节点，也就是右边那个e节点，随后在第6行指向r节点，r节点的count值为1，从而count+1，循环直到temp指向root为止。最后i=6,7时，找不到任何匹配，匹配过程结束。</p><p>到此，AC自动机入门知识就讲完了。HDU 2222入门题必须果断A掉，反正我是参考别人代码敲的。。。</p><p>AC自动机貌似还有很多需要优化的地方，等把基础搞定之后再学习一下怎么优化吧。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;p&gt;source link: &lt;a href=&quot;http://blog.csdn.net/niushuai666/article/details/7002823&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="reprint" scheme="sherry0429.github.io/categories/reprint/"/>
    
    
      <category term="acm, c" scheme="sherry0429.github.io/tags/acm-c/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 随笔记录</title>
    <link href="sherry0429.github.io/2018/02/11/OpenCV-%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    <id>sherry0429.github.io/2018/02/11/OpenCV-随笔记录/</id>
    <published>2018-02-11T06:52:18.000Z</published>
    <updated>2018-02-11T09:05:57.996Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><p>在实验室里听一点记一点，到时候再总结整理吧。先记下来再说。</p><p>一定要记住的page：<a href="http://wiki.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">http://wiki.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     IplImage * test=NULL;</span><br><span class="line">     test = cvLoadImage (&quot;D:\\demo.jpg&quot;);</span><br><span class="line">     cvNamedWindow(&quot;test_demo&quot;,1);</span><br><span class="line"> cvMoveWindow(&quot;test_demo&quot;,800,10);</span><br><span class="line">     cvShowImage(&quot;test_demo&quot;,test);</span><br><span class="line">     cvWaitKey(0);</span><br><span class="line">     cvDestroyWindow(&quot;test_demo&quot;);</span><br><span class="line">     cvReleaseImage(&amp;test);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.IplImage *p=NULL;定义图像指针</span><br></pre></td></tr></table></figure><p>IplImage是一个类，它包含以下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IplImage</span><br><span class="line">    &#123;</span><br><span class="line">        int  nSize;         /* IplImage大小，=sizeof(IplImage)*/</span><br><span class="line">        int  ID;            /* 版本 (=0)*/</span><br><span class="line">        int  nChannels;     /* 大多数OPENCV函数支持1,2,3 或 4 个通道 */</span><br><span class="line">        int  alphaChannel;  /* 被OpenCV忽略 */</span><br><span class="line">        int  depth;         /* 像素的位深度: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U,</span><br><span class="line">                               IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F 可支持 */</span><br><span class="line">        char colorModel[4]; /* 被OpenCV忽略 */</span><br><span class="line">        char channelSeq[4]; /* 被OpenCV忽略 */</span><br><span class="line">        int  dataOrder;     /* 0 - 交叉存取颜色通道，对三通道RGB图像，像素存储顺序为BGR BGR BGR ... BGR；</span><br><span class="line">                                     1 - 分开的颜色通道，对三通道RGB图像，像素存储顺序为RRR...R GGG...G BBB...B。</span><br><span class="line">                                  cvCreateImage只能创建交叉存取图像 */</span><br><span class="line">        int  origin;        /* 0 - 顶—左结构,</span><br><span class="line">                               1 - 底—左结构 (Windows bitmaps 风格) */</span><br><span class="line">        int  align;         /* 图像行排列 (4 or 8). OpenCV 忽略它，使用 widthStep 代替 */</span><br><span class="line">        int  width;         /* 图像宽像素数 */</span><br><span class="line">        int  height;        /* 图像高像素数*/</span><br><span class="line">        struct _IplROI *roi;/* 图像感兴趣区域. 当该值非空只对该区域进行处理 */</span><br><span class="line">        struct _IplImage *maskROI; /* 在 OpenCV中必须置NULL */</span><br><span class="line">        void  *imageId;     /* 同上*/</span><br><span class="line">        struct _IplTileInfo *tileInfo; /*同上*/</span><br><span class="line">        int  imageSize;     /* 图像数据大小(在交叉存取格式下imageSize=image-&gt;height*image-&gt;widthStep），单位字节*/</span><br><span class="line">        char *imageData;  /* 指向排列的图像数据 */</span><br><span class="line">        int  widthStep;   /* 排列的图像行大小，以字节为单位 */</span><br><span class="line">        int  BorderMode[4]; /* 边际结束模式, 被OpenCV忽略 */</span><br><span class="line">        int  BorderConst[4]; /* 同上 */</span><br><span class="line">        char *imageDataOrigin; /* 指针指向一个不同的图像数据结构（不是必须排列的），是为了纠正图像内存分配准备的 */</span><br><span class="line">    &#125;</span><br><span class="line">    IplImage;</span><br></pre></td></tr></table></figure><p>每定义一个IplImage指针，就定义了一个矩形，矩形的每一行依次为nsize,ID……等等。如图：</p><p><img src="http://img.blog.csdn.net/20140707151208062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxNDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.cvLoadImage()</span><br></pre></td></tr></table></figure><p>cvLoadImage( filename, -1 ); 默认读取图像的原通道数，filename为图像路径</p><p>cvLoadImage( filename, 0 ); 强制转化读取图像为灰度图</p><p>cvLoadImage( filename, 1 ); 读取彩色图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.cvNameWindow(&quot;Image&quot;,1);命名图像空间</span><br></pre></td></tr></table></figure><p>int cvNamedWindow( const char* name, int flags=CV_WINDOW_AUTOSIZE );</p><p>函数cvNamedWindow创建一个可以放置图像的窗口.</p><p>被创建的窗口可以通过它们的名字被引用.</p><p>如果已经存在这个名字的窗口，这个函数将不做任何事情.</p><p>若为0表示以固定尺寸显示,此时可以用cvResizeWindow控制窗口大小，这时图像根据窗口大小进行调整，且全铺在窗口上。可以用鼠标拉伸。</p><p>若为1，窗口以图像大小进行调整（即使先前设置过窗口大小），也会根据图像大小进行调整，且不可拉伸。</p><p><em>*</em>使用了这个函数后，即使没有图像指针，在编译完成后也会生成一个窗口（灰色）。</p><p>关于cvResizeWindow(需要注意，这个函数是用来改变窗口大小的，而非改变图像大小。之所以看似图像大小也改变了，实际上是因为在NamedWindow参数里，设置为图像根据窗口进行调整。换句话说，它的原理是通过改变窗口大小——让图像跟着窗口变化——进而改变图像大小，而非直接改变图像大小。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvResizeWindow( const char* name, int width, int height );</span><br></pre></td></tr></table></figure><ul><li><p>name </p><p>将被设置窗口的名字。</p></li><li><p>width </p><p>新的窗口宽度。</p></li><li><p>height </p><p>新的窗口高度。</p></li></ul><p>函数cvResizeWindow改变窗口的大小。</p><p>如果想要直接改变图像大小，需要resize函数或者图像金字塔pyrDown,pyrUp(不改变长宽比，一次面积放大4倍或者缩小4分之一）</p><p>以下为转载：</p><hr><p>OpenCV改变图像大小的操作有两类：resize与图像金字塔，但是这两类操作差别还是比较大的。</p><p>一、resize</p><p>函数原型</p><p>void resize(InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR )</p><p>各个参数的意义比较直观，但是需要注意的是dsize与fx和fy必须不能同时为零，也就是说要么dsize不为零而fx与fy同时可以为0，要么dsize为0而fx与fy不同时为0；resize函数的目标大小可以是任意的大小，可以不保持长宽比率，删除的像素或者新增的像素值通过interpolation（内插）控制；</p><p>二、图像金字塔</p><p>pyrDown与pyrUp分别表示向下降采样与向上升采样，但是二者并不是互为逆操作；</p><p>void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize=Size(), int border-</p><p>Type=BORDER_DEFAULT )</p><p>void pyrUp(InputArray src, OutputArray dst, const Size&amp; dstsize=Size(), int border-</p><p>Type=BORDER_DEFAULT )</p><p>这两个操作实现图像金字塔的经典操作，他们仅仅是分别代表一次采样操作，也就是说，向下(或者向上)进行相邻层次的金字塔采样，调用一次pyrDown函数只能降低到原图像尺寸的1/2;反之，调用pyrUp目标图像则为原图像尺寸的2倍。因为它们内部都给定了一次采样尺寸的约束。也就是说采样之后，长宽比基本是不变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void ResizeDemo()</span><br><span class="line">&#123;</span><br><span class="line">         Mat img1=imread(&quot;person_org.jpg&quot;);</span><br><span class="line">         Mat img2;</span><br><span class="line">//将原图像变为32*32，长宽比被改变了</span><br><span class="line">         resize(img1,img2,Size(32,32),0,0,CV_INTER_LINEAR);</span><br><span class="line">         namedWindow(&quot;WindowOrg&quot;);</span><br><span class="line">         namedWindow(&quot;WindowNew&quot;);</span><br><span class="line">         imshow(&quot;WindowOrg&quot;,img1);</span><br><span class="line">         imshow(&quot;WindowNew&quot;,img2);</span><br><span class="line"> </span><br><span class="line">         waitKey(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">IplImage *Image;</span><br><span class="line">IplImage *NewImage;</span><br><span class="line">Image = cvLoadImage(&quot;D:\\1234.jpg&quot;,1);</span><br><span class="line"></span><br><span class="line">CvSize sz;</span><br><span class="line">sz = cvGetSize(Image);</span><br><span class="line">sz.height /= 2;</span><br><span class="line">sz.width /= 2;</span><br><span class="line">//if pyrup,</span><br><span class="line">//sz.height*=2;</span><br><span class="line">//sz.width*=2;</span><br><span class="line">//setting height and width.</span><br><span class="line"></span><br><span class="line">NewImage = cvCreateImage(sz,IPL_DEPTH_8U, 3);</span><br><span class="line">//Create Image</span><br><span class="line"></span><br><span class="line">cvPyrDown(Image, NewImage, 7);</span><br><span class="line">//cvPryup(Image,NewImage,7);</span><br><span class="line">//若使用这个函数，需要事先建立好一个尺寸为原图一半的图并用IplImage指针指向它.7相当于CV_GAUSSIAN_5x5.</span><br><span class="line"></span><br><span class="line">cvNamedWindow(&quot;graph1&quot;, 1);</span><br><span class="line">cvNamedWindow(&quot;graph2&quot;, 1);</span><br><span class="line">cvShowImage(&quot;graph1&quot;, Image);</span><br><span class="line">cvShowImage(&quot;graph2&quot;, NewImage);</span><br><span class="line">cvWaitKey(0);</span><br><span class="line">cvDestroyAllWindows();</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：resize可以一次性将原图像变为任意不为0的尺寸，适合用来做归一化图像操作；而pyrDown与pyrUp适合做长宽比率不变得操作，且调用一次只能长和宽只能变为原来的1/2或者2倍，也即是说面积变为原来的1/4或者4倍。</p><p>转载自<a href="http://blog.sina.com.cn/s/blog_4b0020f30101cgok.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b0020f30101cgok.html</a></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.void cvShowImage( const char* name, const CvArr* image );</span><br></pre></td></tr></table></figure><p>Example:</p><p>cvShowImage(“Image”,p);</p><p>函数cvShowImage 在指定窗口中显示图像.如果窗口创建的时候被设定标志CV_WINDOW_AUTOSIZE,</p><p>那么图像将以原始尺寸显示；否则，图像将被伸缩以适合窗口大小.</p><p>一条语句只显示一次图像，若后面的语句没有cvWaitKey(0)的话，图像一闪而过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.cvWaitKey(delay)</span><br></pre></td></tr></table></figure><p>Example:</p><p>cvWaitKey(0);</p><p>函数的功能是不断刷新图像，频率时间为delay，单位为ms。</p><p>delay为&lt;=0时，无限制等待按键。按键后（在显示出的图片里进行按键），才执行WaitKey之后的语句。另外注意WaitKey单位为毫秒！它的功能可以理解为延时X毫秒后，执行接下来的语句。</p><p>函数cvWaitKey无限制的等待按键事件（delay&lt;=0时）；或者延迟”delay”毫秒。返回值为被按键的值，如果超过指定时间则返回-1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.void cvDestroyWindow( const char* name );</span><br></pre></td></tr></table></figure><p>Example;</p><p>cvDestroyWindow(“Image”);</p><p>销毁指定窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.cvReleaseImage(&amp;p);//销毁指针</span><br></pre></td></tr></table></figure><p>cvReleaseImage函数只是将IplImage*型的变量值赋为NULL，而这个变量本身还是存在的并且在内存中的存储位置不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.void cvMoveWindow( const char* name, int x, int y );</span><br></pre></td></tr></table></figure><p>设定窗口的位置。</p><p>name 将被设置的窗口的名字。</p><p>x 窗口左上角的x坐标。</p><p>y 窗口左上角的y坐标。</p><p>函数cvMoveWindow改变窗口的位置。</p><p>cvActionTargetMod()</p><p>Example:</p><p> cv</p><p>Get</p><p>2D</p><p> cv</p><p>Create</p><p>Image</p><p> cv</p><p>Name</p><p>Window</p><p>CV_bitdepth()</p><p>S=符号整型</p><p>U=无符号整型</p><p>F=浮点型</p><p>CV_8（位数）U（类型）G（矩阵）1（通道） 一个8位无符号整形单通道矩阵</p><p>CV_32FG2 32位浮点型双通道矩阵</p><p>图像数据类型：</p><p>IPL<em>DEPTH</em><bit_depth>(S|U|F)</bit_depth></p><p>IPL_DEPTH_8U 8位无符号整型</p><p>头文件：</p><cv.h><cvaux.h><highgui.h><ml.h><cxcore.h><p>基础结构：</p><ul><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint" target="_blank" rel="noopener">1 CvPoint</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint2D32f" target="_blank" rel="noopener">2 CvPoint2D32f</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint3D32f" target="_blank" rel="noopener">3 CvPoint3D32f</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSize" target="_blank" rel="noopener">4 CvSize</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSize2D32f" target="_blank" rel="noopener">5 CvSize2D32f</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvRect" target="_blank" rel="noopener">6 CvRect</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvScalar" target="_blank" rel="noopener">7 CvScalar</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvTermCriteria" target="_blank" rel="noopener">8 CvTermCriteria</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvMat" target="_blank" rel="noopener">9 CvMat</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvMatND" target="_blank" rel="noopener">10 CvMatND</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSparseMat" target="_blank" rel="noopener">11 CvSparseMat</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#IplImage" target="_blank" rel="noopener">12 IplImage</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvArr" target="_blank" rel="noopener">13 CvArr</a></li></ul><p>其中，CvPoint为二维坐标点整型，2D32F为2维浮点型，以此类推。</p><p>CyScalar是一个颜色结构体类，有四个数组元素，分别代表R,G,B,第四个元素通常用来表示透明色.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CvScalar</span><br><span class="line"> &#123;</span><br><span class="line">  double val[4]</span><br><span class="line"> &#125;</span><br><span class="line"> CvScalar;</span><br></pre></td></tr></table></figure><p>扩展——</p><p>其中Cvpoint</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inline CvPoint cvPoint( int x, int y );</span><br><span class="line">inline CvPoint cvPointFrom32f( CvPoint2D32f point )</span><br></pre></td></tr></table></figure><p>分别作用为：返回一个cvPoint值，</p><p>将一个2D32f值转换为cvPoint值并返回。</p><p>函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvLine( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure><p>功能：绘制连接两个点的线段</p><ul><li><p>img 图像。</p></li><li><p>pt1 线段的第一个端点。</p></li><li><p>pt2 线段的第二个端点。</p></li><li><p>color 线段的颜色。</p></li><li><p>thickness 线段的粗细程度。</p></li><li><p>line_type 线段的类型。</p><p>8 (or 0) - 8-connected line（8邻接)连接 线。</p><p>4 - 4-connected line(4邻接)连接线。</p><p>CV_AA - antialiased 线条。</p></li></ul><p>shift 坐标点的小数点位数。</p><p>函数cvLine 在图像中的点1和点2之间画一条线段。线段被图像或感兴趣的矩形(ROI rectangle)所裁剪。对于具有整数坐标的non-antialiasing 线条，使用8-连接或者4-连接Bresenham 算法。画粗线条时结尾是圆形的。画 antialiased 线条使用高斯滤波。要指定线段颜色，用户可以使用使用宏CV_RGB( r, g, b )。</p><p>而且指定线条颜色的时候用到的宏CV_RGB(r，g，b)定义为#define CV_RGB( r, g, b ) cvScalar( (b), (g), (r), 0 )，由此可见，实际上起作用的颜色是看cvScalar中的b，g，r顺序，线段颜色就不言而喻了</p><p>利用CvScalar，CvLine画线:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// qwsds.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;highgui.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">CvPoint pt1;</span><br><span class="line">pt1=cvPoint(100,200);</span><br><span class="line">printf(&quot;x:%d,y:%d\n&quot;,pt1.x,pt1.y);</span><br><span class="line"></span><br><span class="line">CvPoint pt2;</span><br><span class="line">pt2=cvPoint(200,320);</span><br><span class="line">printf(&quot;x:%d,y:%d\n&quot;,pt2.x,pt2.y);</span><br><span class="line"></span><br><span class="line">CvScalar color;</span><br><span class="line">color=cvScalar(100,0,200);//蓝 绿 红。RGB</span><br><span class="line">printf(&quot;v1:%f v2:%f v3:%f\n&quot;,color.val[0],color.val[1],color.val[2]);</span><br><span class="line"></span><br><span class="line">IplImage *img=0;</span><br><span class="line">img=cvLoadImage(&quot;D:\\Blue hills.jpg&quot;);</span><br><span class="line"></span><br><span class="line">cvLine(img,pt1,pt2,color,2);</span><br><span class="line"></span><br><span class="line">cvNamedWindow(&quot;draw&quot;);</span><br><span class="line"></span><br><span class="line">cvShowImage(&quot;draw&quot;,img);</span><br><span class="line"></span><br><span class="line">cvWaitKey();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/pre&gt;&lt;pre code_snippet_id=&quot;421021&quot; snippet_file_name=&quot;blog_20140707_14_8402014&quot; name=&quot;code&quot; class=&quot;cpp&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;CvLine&lt;/span&gt;&lt;/strong&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void cvLine( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color,</span><br><span class="line">             int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure><ul><li><p>img</p><p>图像。</p></li><li><p>pt1</p><p>线段的第一个端点。</p></li><li><p>pt2</p><p>线段的第二个端点。</p></li><li><p>color</p><p>线段的颜色。</p></li><li><p>thickness</p><p>线段的粗细程度。</p></li><li><p>line_type</p><p>线段的类型。8 (or 0) - 8-connected line（8邻接)连接 线。4 - 4-connected line(4邻接)连接线。CV_AA - antialiased 线条。</p></li></ul><ul><li><p>shift</p><p>坐标点的小数点位数。</p></li></ul><p>函数cvLine 在图像中的点1和点2之间画一条线段。线段被图像或感兴趣的矩形(ROI rectangle)所裁剪。对于具有整数坐标的non-antialiasing 线条，使用8-连接或者4-连接Bresenham 算法。画粗线条时结尾是圆形的。画 antialiased 线条使用高斯滤波。要指定线段颜色，用户可以使用使用宏CV_RGB( r, g, b )。</p><p>CvSize sz;</p><p>设置一个矩形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CvSize sz;</span><br><span class="line">sz=cvSize(640,480);</span><br><span class="line">printf(&quot;width:%d,height:%d\n&quot;,sz.width,sz.height);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IplImage *p;</span><br><span class="line">p=cvCreateImage(sz,IPL_DEPTH_8U,3);//sz矩形的宽，高（将结构体传进去）,深度,颜色通道数）</span><br><span class="line">cvNamedWindow(&quot;Image&quot;);</span><br><span class="line">cvShowImage(&quot;Image&quot;,p);</span><br><span class="line">cvWaitKey(0);</span><br></pre></td></tr></table></figure><p>其中cvCreateImage创建了一个矩形！</p><p>CvRect矩阵框的偏移量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CvRect</span><br><span class="line"> &#123;</span><br><span class="line">  int x; /* 方形的最左角的x-坐标  */</span><br><span class="line">  int y; /* 方形的最上或者最下角的y-坐标 */</span><br><span class="line">  int width; /* 宽 */</span><br><span class="line">  int height; /* 高 */</span><br><span class="line"> &#125;</span><br><span class="line"> CvRect;</span><br></pre></td></tr></table></figure><p>应用：（利用了CvRectangle）</p><p>CvRectangle：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void cvRectangle( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color,</span><br><span class="line">                  int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure><ul><li><p>img</p><p>图像.</p></li><li><p>pt1</p><p>矩形的一个顶点。</p></li><li><p>pt2</p><p>矩形对角线上的另一个顶点</p></li><li><p>color</p><p>线条颜色 (RGB) 或亮度（灰度图像 ）(grayscale image）。</p></li><li><p>thickness</p><p>组成矩形的线条的粗细程度。取负值时（如 CV_FILLED）函数绘制填充了色彩的矩形。</p></li><li><p>line_type</p><p>线条的类型。见cvLine的描述</p></li><li><p>shift</p><p>坐标点的小数点位数。</p></li></ul><p>函数 cvRectangle 通过对角线上的两个顶点绘制矩形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;highgui.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">CvSize sz;//CvSize 数据类型 C大写,定义。</span><br><span class="line">sz=cvSize(640,480);//给sz赋值。</span><br><span class="line">printf(&quot;width:%d,height:%d\n&quot;,sz.width,sz.height);</span><br><span class="line">IplImage *img=0;</span><br><span class="line">img=cvCreateImage(sz,IPL_DEPTH_8U,3);//创建而不是载入。</span><br><span class="line">CvRect rect;</span><br><span class="line">rect=cvRect(50,30,100,150);//左上坐标，长度，宽度。</span><br><span class="line">CvPoint pt1=cvPoint(rect.x,rect.y);</span><br><span class="line">CvPoint pt2=cvPoint(rect.x+rect.width,rect.y+rect.height);</span><br><span class="line">cvRectangle(img,pt1,pt2,cvScalar(0,0,255),2);</span><br><span class="line">cvNamedWindow(&quot;create&quot;);</span><br><span class="line">cvShowImage(&quot;create&quot;,img);</span><br><span class="line">cvWaitKey();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中cvRectangle利用apt1,apt2两个点，和颜色方案cvScalar，以及粗细程度2，将绘制的矩形传递给指针p2,然后在建立的图案区域AAA内显示矩形。</p><p>复制图像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IplImage *mp1=cvCloneImage(img);//把图像img复制给mp1.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;para&quot; style=&quot;margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif; font-size:14px&quot;&gt;&lt;pre code_snippet_id=&quot;421021&quot; snippet_file_name=&quot;blog_20140707_20_810661&quot; name=&quot;code&quot; class=&quot;cpp&quot; style=&quot;color: rgb(51, 51, 51);&quot;&gt;cvNamedWindow(&quot;create&quot;);</span><br><span class="line">cvShowImage(&quot;create&quot;,img);//img需要事先指向图像</span><br><span class="line">IplImage *p2=cvCloneImage(img);</span><br><span class="line">cvNamedWindow(&quot;clone&quot;);</span><br><span class="line">cvShowImage(&quot;clone&quot;,p2);</span><br><span class="line">cvWaitKey();</span><br></pre></td></tr></table></figure><p>​      保存图像到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int cvSaveImage( const char* filename, const CvArr* image );</span><br></pre></td></tr></table></figure><ul><li><p>filename </p><p>文件名，如果对应的文件已经存在，则将被复盖。</p></li><li><p>image </p><p>要保存的图像。</p></li></ul><p>函数cvSaveImage保存图像到指定文件。图像格式的的选择依赖于filename的扩展名，请参考cvLoadImage。只有8位单通道或者3通道（通道顺序为’BGR’ ）可以使用这个函数保存。如果格式，深度或者通道不符合要求，请先用cvCvtScale 和cvCvtColor转换；或者使用通用的cvSave保存图像为XML或者YAML格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     IplImage * test=NULL;</span><br><span class="line">     test = cvLoadImage (&quot;D:\\demo.jpg&quot;);</span><br><span class="line">     cvNamedWindow(&quot;test_demo&quot;,1);</span><br><span class="line"> cvMoveWindow(&quot;test_demo&quot;,800,10);</span><br><span class="line">     cvShowImage(&quot;test_demo&quot;,test);</span><br><span class="line"> cvSaveImage(&quot;D:\\123.jpg&quot;,test);</span><br><span class="line">     cvWaitKey(0);</span><br><span class="line">     cvDestroyWindow(&quot;test_demo&quot;);</span><br><span class="line">     cvReleaseImage(&amp;test);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：<br>OpenCV里有两个单词，Image，Window，它们各自代表的是载入的图像(用IplImage指针表示)，放置图像的窗口。<br>1.在存在Window的前提下,即cvNamedWindow(“窗口名”,是否根据Image进行调整的指标.)，<br>2.让IplImage指针指向Image,即cvLoadImage(“Image”,指针名).除去载入的方法外,也可以创建:<br>(1).定义一个CvSize类型的矩形sz.<br>(2).赋予其宽,高.sz=CvSize(640,480)<br>(3).p=cvCreateImage(sz,IPL_DEPTH_8U,3).第二个参数为深度,例为8位无符号整型,3通道.<br>3.再将Image导入Window，才能让Image显示出来,即cvShowImage(Window,image的指针).</p><p>另外，除了必要的知识外，大部分函数在使用的时候可以直接在博客开头的Page手册里查阅使用方案，系统全面的文档提供了很高的支持。感觉和Linux查阅技术文档来进行操作有些相同之处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#iclude&lt;stdio.h&gt;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;                  /*定义一个文件指针*/</span><br><span class="line">int i;</span><br><span class="line">fp=fopen(&quot;CLIB&quot;, &quot;rb&quot;);    /*打开当前目录名为CLIB的文件只读*/ </span><br><span class="line">if(fp==NULL)               /*判断文件是否打开成功*/</span><br><span class="line">puts(&quot;File open error&quot;);/*提示打开不成功*/</span><br><span class="line">i=fclose(fp);              /*关闭打开的文件*/</span><br><span class="line">if(i==0)                   /*判断文件是否关闭成功*/</span><br><span class="line">printf(&quot;O.K&quot;);           /*提示关闭成功*/</span><br><span class="line">else                </span><br><span class="line">puts(&quot;File close error&quot;);/*提示关闭不成功*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> int fprintf(FILE <em>stream, char </em>format, <variable-list>);<br>​        int fputs(char <em>string, FILE </em>steam);<br>int fputc(intch, FILE *steam);<br>fprintf() 函数的返回值为实际写入文件中的字符个数(字节数)。如果写错误, 则返回一个负数； fputs()函数返回0时表明将string指针所指的字符串写入文件中的操作成功, 返回非0时,表明写操作失败。  fputc()函数返回一个向文件所写字符的值, 此时写操作成功,否则返回EOF(文件结束结束其值为-1, 在stdio.h中定义)表示写操作错误。   fprintf( ) 函数中格式化的规定与printf( ) 函数相同,所不同的只是fprintf()函数是向文件中写入。而printf()是向屏幕输出。<br>4.文件的顺序读操作函数<br>​        fscanf()、fgets()和fgetc()函数<br>函数fscanf()、fgets()和fgetc()均为文件的顺序读操作函数, 其调用格式 如下:</variable-list></p><p>int fscanf(FILE <em>stream, char </em>format, <address-list>);<br>​        char fgets(char <em>string, int n, FILE </em>steam);<br>​        int fgetc(FILE *steam);<br>fscanf()函数的用法与scanf()函数相似,只是它是从文件中读到信息。 fscanf()函数的返回值为EOF(即-1), 表明读错误, 否则读数据成功。  fgets()函数从文件中读取至多n-1个字符(n用来指定字符数), 并把它们放入string指向的字符串中, 在读入之后自动向字符串未尾加一个空字符, 读成功返回string指针,  失败返回一个空指针。  fgetc()函数返回文件当前位置的一个字符,读错误时返回EOF。 </address-list></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void cvSmooth( const CvArr* src, CvArr* dst,</span><br><span class="line">               int smoothtype=CV_GAUSSIAN,</span><br><span class="line">               int param1=3, int param2=0, double param3=0, double param4=0 );</span><br></pre></td></tr></table></figure><ul><li><p>src</p><p>输入图像.</p></li><li><p>dst</p><p>输出图像.</p></li><li><p>smoothtype</p><p>平滑方法:CV_BLUR_NO_SCALE (简单不带尺度变换的模糊) - 对每个象素的 param1×param2 领域求和。如果邻域大小是变化的，可以事先利用函数 cvIntegral 计算积分图像。CV_BLUR (simple blur) - 对每个象素param1×param2邻域 求和并做尺度变换 1/(param1•param2).CV_GAUSSIAN (gaussian blur) - 对图像进行核大小为 param1×param2 的高斯卷积CV_MEDIAN (median blur) - 对图像进行核大小为param1×param1 的中值滤波 (i.e. 邻域是方的).CV_BILATERAL (双向滤波) - 应用双向 3x3 滤波，彩色 sigma=param1，空间 sigma=param2. 关于双向滤波，可参考<a href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html" target="_blank" rel="noopener">http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a></p></li></ul><ul><li><p>param1</p><p>平滑操作的第一个参数.</p></li><li><p>param2</p><p>平滑操作的第二个参数. 对于简单/非尺度变换的高斯模糊的情况，如果param2的值 为零，则表示其被设定为param1。</p></li><li><p>param3</p><p>对应高斯参数的 Gaussian sigma (标准差). 如果为零，则标准差由下面的核尺寸计算：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigma = (n/2 - 1)*0.3 + 0.8, 其中 n=param1 对应水平核,</span><br><span class="line">                                 n=param2 对应垂直核.</span><br></pre></td></tr></table></figure><p>对小的卷积核 (3×3 to 7×7) 使用如上公式所示的标准 sigma 速度会快。如果 param3 不为零，而 param1 和 param2 为零，则核大小有 sigma 计算 (以保证足够精确的操作).</p><p>函数 cvSmooth 可使用上面任何一种方法平滑图像。每一种方法都有自己的特点以及局限。</p><p>没有缩放的图像平滑仅支持单通道图像，并且支持8位到16位的转换(与cvSobel和cvaplace相似)和32位浮点数到32位浮点数的变换格式。</p><p>简单模糊和高斯模糊支持 1- 或 3-通道, 8-比特 和 32-比特 浮点图像。这两种方法可以（in-place）方式处理图像。</p><p>中值和双向滤波工作于 1- 或 3-通道， 8-位图像，但是不能以 in-place 方式处理图像.</p><ul><li><p>中值滤波</p><p>中值滤波法是一种非线性平滑技术，它将每一象素点的灰度值设置为该点某邻域窗口内的所有象素点灰度值的中值。实现方法：</p></li></ul><ol><li>通过从图像中的某个采样窗口取出奇数个数据进行排序</li><li>用排序后的中值取代要处理的数据即可</li></ol><p>中值滤波法对消除椒盐噪音非常有效，在光学测量条纹图象的相位分析处理方法中有特殊作用，但在条纹中心分析方法中作用不大。中值滤波在图像处理中,常用于用来保护边缘信息,是经典的平滑噪声的方法</p><ul><li>中值滤波原理</li></ul><p>中值滤波是基于排序统计理论的一种能有效抑制噪声的非线性信号处理技术，中值滤波的基本原理是把数字图像或数字序列中一点的值用该点的一个拎域中各点值的中值代替，让周围的像素值接近的值，从而消除孤立的噪声点。方法是去某种结构的二维滑动模板，将板内像素按照像素值的大小进行排序，生成单调上升（或下降）的为二维数据序列。二维中值滤波输出为g（x,y）=med{f(x-k,y-l),(k,l∈W)} ，其中,f(x,y)，g(x,y)分别为原始图像和处理后图像。W为二维模板，通常为2<em>2，3</em>3区域，也可以是不同的的形状，如线状，圆形，十字形，圆环形等。</p><ul><li>高斯滤波</li></ul><p>高斯滤波实质上是一种信号的滤波器，其用途是信号的平滑处理，我们知道数字图像用于后期应用，其噪声是最大的问题，由于误差会累计传递等原因，很多图像处理教材会在很早的时候介绍Gauss滤波器，用于得到信噪比SNR较高的图像（反应真实信号）。于此相关的有Gauss-Lapplace变换，其实就是为了得到较好的图像边缘，先对图像做Gauss平滑滤波，剔除噪声，然后求二阶导矢，用二阶导的过零点确定边缘，在计算时也是频域乘积=&gt;空域卷积。</p><p>滤波器就是建立的一个数学模型，通过这个模型来将图像数据进行能量转化，能量低的就排除掉，噪声就是属于低能量部分</p><p>其实编程运算的话就是一个模板运算，拿图像的八连通区域来说，中间点的像素值就等于八连通区的像素值的均值，这样达到平滑的效果</p><p>若使用理想滤波器，会在图像中产生振铃现象。采用高斯滤波器的话，系统函数是平滑的，避免了振铃现象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例程序：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">IplImage *p = cvLoadImage(&quot;D:\\1234.jpg&quot;, 1);</span><br><span class="line">IplImage *out = cvCreateImage(cvGetSize(p), IPL_DEPTH_8U, 3);</span><br><span class="line">cvNamedWindow(&quot;cv_in&quot;, 1);</span><br><span class="line">cvNamedWindow(&quot;cv_out&quot;, 1);</span><br><span class="line"></span><br><span class="line">cvShowImage(&quot;cv_in&quot;, p);</span><br><span class="line">cvWaitKey(1024);</span><br><span class="line"></span><br><span class="line">cvSmooth(p, out, CV_GAUSSIAN, 3, 3);//from head file &lt;cv.h&gt;.</span><br><span class="line">cvShowImage(&quot;cv_out&quot;, out);</span><br><span class="line">cvWaitKey(1024);</span><br><span class="line"></span><br><span class="line">//cvReleaseImage(&amp;p);</span><br><span class="line">cvReleaseImage(&amp;out);</span><br><span class="line">//加上上述两行就会报错，原因：</span><br><span class="line">/*</span><br><span class="line">在写相关程序的时候，在程序的结尾处释放前段自定义的变量。使用函数cvReleaseImage(&amp;pFrame);时程序在调试结束后报错，</span><br><span class="line">指明是在释放内存时出错。经过看前辈们遇到的相同的问题。先总结如下：</span><br><span class="line"></span><br><span class="line">    cvReleaseImage()和cvCreateImage()相对应的。在程序中如果没有“创建”就不能“释放”。</span><br><span class="line">所以，如果我们使用的指针不是用cvCreateImage()创建的。</span><br><span class="line">如果使用cvReleaseImage()就会出现错误。如果大家担心指针不释放会引发内存的错误。</span><br><span class="line">可以使用pFrame = NULL;来释放内存。</span><br><span class="line">因为cvReleaseImage()的作用就是将作为参数的那个指针设置为NULL;</span><br><span class="line"></span><br><span class="line">如修改后，只ReleaseOUT就不会出错.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">cvDestroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CvCapture 视频获取结构</span><br></pre></td></tr></table></figure><h2 id="cvCreateFileCapture"><a href="#cvCreateFileCapture" class="headerlink" title="cvCreateFileCapture"></a>cvCreateFileCapture</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CvCapture* cvCreateFileCapture( const char* filename );</span><br></pre></td></tr></table></figure><ul><li><p>filename </p><p>视频文件名。</p></li></ul><p>函数cvCreateFileCapture给指定文件中的视频流分配和初始化CvCapture结构。</p><p>当分配的结构不再使用的时候，它应该使用cvReleaseCapture函数释放掉。</p><h2 id="cvReleaseCapture"><a href="#cvReleaseCapture" class="headerlink" title="cvReleaseCapture"></a>cvReleaseCapture</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvReleaseCapture( CvCapture** capture );</span><br></pre></td></tr></table></figure><ul><li><p>capture </p><p>视频获取结构指针。</p></li></ul><p>函数cvReleaseCapture释放由函数cvCreateFileCapture或者cvCreateCameraCapture分配的CvCapture结构。</p><p>注:若从capture中使用cvQueryFrame获取图像指针，在releaseCapture的时候同时函数释放图像指针，用户不用再自己释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">IplImage *p; </span><br><span class="line">CvCapture *capture = cvCreateFileCapture(&quot;D:\\123.avi&quot;);</span><br><span class="line">cvNamedWindow(&quot;Image&quot;, 1);</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">p = cvQueryFrame(capture);</span><br><span class="line">if (!p)</span><br><span class="line">break;//if can&apos;t load image,p is NULL,and break.</span><br><span class="line">cvShowImage(&quot;Image&quot;, p);</span><br><span class="line">char c = cvWaitKey(1024);</span><br><span class="line">if (c == 27)</span><br><span class="line">break;//if you press Esc,c will get 27.</span><br><span class="line">&#125;</span><br><span class="line">cvReleaseCapture(&amp;capture);</span><br><span class="line">cvReleaseImage(&amp;p);</span><br><span class="line">cvDestroyWindow(Image);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像像素的获取：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 访问图像像素.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//way:</span><br><span class="line">//IplImage *Img = cvCreateImage(cvSize(640, 580), IPL_DEPTH_8U, 3);</span><br><span class="line">//1.间接访问:get*D,set*D...</span><br><span class="line">//2.直接访问:((*uchar)ImageData+i*Image-&gt;width)[j]=111;</span><br><span class="line">/*</span><br><span class="line">单通道：</span><br><span class="line">IplImage*img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,1);</span><br><span class="line">int height     =img-&gt;height; </span><br><span class="line">int width=img-&gt;width;  </span><br><span class="line">int step       =img-&gt;widthStep/sizeof(uchar); </span><br><span class="line">uchar* data    =(uchar*)img-&gt;imageData; </span><br><span class="line">data[i*step+j]=111;</span><br><span class="line">多通道：</span><br><span class="line">IplImage*img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,3);  </span><br><span class="line">int height     =img-&gt;height; </span><br><span class="line">int width      =img-&gt;width;  </span><br><span class="line">int step       =img-&gt;widthStep/sizeof(uchar); </span><br><span class="line">int channels   =img-&gt;nChannels;  </span><br><span class="line">uchar* data    =(uchar*)img-&gt;imageData; </span><br><span class="line">data[i*step+j*channels+k]=111;</span><br><span class="line">如果为浮点型矩阵，而非字节型，那就把uchar改为float.</span><br><span class="line">*/</span><br><span class="line">//3.利用宏:CV_IMAGE_ELEM</span><br><span class="line">//单通道:CV_IMAGE_ELEM(img,uchar,i,j)=111; img为IplImage指针</span><br><span class="line">//多通道:CV_IMAGE_ELEM(srcimg,uchar,i,j*3+0)=111;</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">IplImage *Image = cvCreateImage(cvSize(640,480), IPL_DEPTH_8U, 3);</span><br><span class="line">CvScalar color;</span><br><span class="line">int i, j;</span><br><span class="line">for (i = 0; i &lt; 50; i++)//循环使i*j区域内的点全部变为黑色.</span><br><span class="line">&#123;</span><br><span class="line">for (j = 50; j &lt; 100; j++)</span><br><span class="line">&#123;</span><br><span class="line">color = cvGet2D(Image, i, j);//get(x,y)&apos;s color.cal[0],color.cal[1].</span><br><span class="line"></span><br><span class="line">//printf(&quot;cal0:%d\ncal1:%d\ncal2:%d\n&quot;, color.val[0], color.val[1], color.val[2]);</span><br><span class="line">//若为单通道图像，只修改color.val[0]即可.</span><br><span class="line">color.val[0] = 0;</span><br><span class="line">color.val[1] = 0;</span><br><span class="line">color.val[2] = 0;</span><br><span class="line">cvSet2D(Image, i, j, color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cvNamedWindow(&quot;ImageA&quot;, 1);</span><br><span class="line">cvShowImage(&quot;ImageA&quot;, Image);</span><br><span class="line">cvWaitKey(0);</span><br><span class="line">cvDestroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而cvSetXD中，固定参数为IplImage指针，X个Int类型的参数表示图上的坐标，以及可以将每个坐标的颜色分配修改的Scalar类。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像的边缘检测（根据像素梯度）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">IplImage *Image;</span><br><span class="line">IplImage *out;</span><br><span class="line">Image = cvLoadImage(&quot;D:\\1234.jpg&quot;, 0);</span><br><span class="line">out = cvCreateImage(cvGetSize(Image), IPL_DEPTH_8U, 1);</span><br><span class="line">cvNamedWindow(&quot;ImageA&quot;, 1);</span><br><span class="line">cvNamedWindow(&quot;ImageB&quot;, 1);</span><br><span class="line">cvCanny(Image, out, 50, 75, 3);</span><br><span class="line">//cvCanny的第一个第二个参数均为指向单通道图片的IplImage.</span><br><span class="line">//第三,第四个参数为阀值，一个大一个小，应当根据图像的梯度设定.</span><br><span class="line">//第五个参数为canny算子3.</span><br><span class="line">cvShowImage(&quot;ImageB&quot;, out);</span><br><span class="line">cvWaitKey(0);</span><br><span class="line">cvDestroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>canny算子实质：如果一个像素的梯度大与上限值，则被认为是边缘像素，如果小于下限阈值，则被抛弃，那么如果该点的梯度位于两者之间，则当其与高于上限值的像素点连接时我们才保留，否则删除。另：当两个阀值等比例同时增大时（比如从50，150增加到100，300，比例并未改变），则图像上的杂点变少（边缘更加清晰）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于梯度的计算：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用自：http://www.cnblogs.com/justany/archive/2012/11/23/2782660.html</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像的边缘图像的边缘从数学上是如何表示的呢？图像的边缘上，邻近的像素值应当显著地改变了。而在数学上，导数是表示改变快慢的一种方法。梯度值的大变预示着图像中内容的显著变化了。用更加形象的图像来解释,假设我们有一张一维图形。下图中灰度值的“跃升”表示边缘的存在：　　　　使用一阶微分求导我们可以更加清晰的看到边缘“跃升”的存在(这里显示为高峰值)：　　　　由此我们可以得出：边缘可以通过定位梯度值大于邻域的相素的方法找到。 卷积卷积可以近似地表示求导运算。那么卷积是什么呢？卷积是在每一个图像块与某个算子（核）之间进行的运算。核？！核就是一个固定大小的数值数组。该数组带有一个锚点 ，一般位于数组中央。 可是这怎么运算啊？假如你想得到图像的某个特定位置的卷积值，可用下列方法计算：将核的锚点放在该特定位置的像素上，同时，核内的其他值与该像素邻域的各像素重合；将核内各值与相应像素值相乘，并将乘积相加；将所得结果放到与锚点对应的像素上；对图像所有像素重复上述过程。用公式表示上述过程如下：　　　　在图像边缘的卷积怎么办呢？计算卷积前，OpenCV通过复制源图像的边界创建虚拟像素，这样边缘的地方也有足够像素计算卷积了。 近似梯度比如内核为3时。首先对x方向计算近似导数：然后对y方向计算近似导数：然后计算梯度：当然你也可以写成：求梯度的例程序：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;#include &quot;opencv2/imgproc/imgproc.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int main( int argc, char** argv )&#123;</span><br><span class="line"></span><br><span class="line">    Mat src, src_gray;</span><br><span class="line">    Mat grad;</span><br><span class="line">    char* window_name = &quot;求解梯度&quot;;</span><br><span class="line">    int scale = 1;</span><br><span class="line">    int delta = 0;</span><br><span class="line">    int ddepth = CV_16S;</span><br><span class="line"></span><br><span class="line">    int c;</span><br><span class="line"></span><br><span class="line">    src = imread( argv[1] );</span><br><span class="line"></span><br><span class="line">    if( !src.data )&#123; </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //高斯模糊</span><br><span class="line">    GaussianBlur( src, src, Size(3,3), 0, 0, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">    //转成灰度图</span><br><span class="line">    cvtColor( src, src_gray, CV_RGB2GRAY );</span><br><span class="line"></span><br><span class="line">    namedWindow( window_name, CV_WINDOW_AUTOSIZE );</span><br><span class="line"></span><br><span class="line">    Mat grad_x, grad_y;</span><br><span class="line">    Mat abs_grad_x, abs_grad_y;</span><br><span class="line"></span><br><span class="line">    Sobel( src_gray, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_x, abs_grad_x );</span><br><span class="line"></span><br><span class="line">    Sobel( src_gray, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_y, abs_grad_y );</span><br><span class="line"></span><br><span class="line">    addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );</span><br><span class="line"></span><br><span class="line">    imshow( window_name, grad );</span><br><span class="line"></span><br><span class="line">    waitKey(0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>Sobel函数</p><blockquote><p>索贝尔算子（Sobel operator）计算。</p><ul><li>C++:<code></code>void <code>Sobel</code>(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize=3, double scale=1, double delta=0, intborderType=BORDER_DEFAULT )</li></ul></blockquote><p>代码注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在x方向求图像近似导数</span><br><span class="line">Sobel( src_gray, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">//在y方向求图像近似导数</span><br><span class="line">Sobel( src_gray, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT );</span><br></pre></td></tr></table></figure><p>如果我们打印上面两个输出矩阵，可以看到grad_x和grad_y中的元素有正有负。</p><p>当然，正方向递增就是正的，正方向递减则是负值。</p><p>这很重要，我们可以用来判断梯度方向。</p><p>convertScaleAbs函数</p><blockquote><p>线性变换转换输入数组元素成8位无符号整型。</p><ul><li>C++:<code></code>void <code>convertScaleAbs</code>(InputArray src, OutputArray dst, double alpha=1, double beta=0)</li></ul><p>对于每个输入数组的元素函数<code>convertScaleAbs</code> 进行三次操作依次是：缩放，得到一个绝对值，转换成无符号8位类型。</p><p><img src="http://docs.opencv.org/_images/math/5ca28093f0a8eca32bcf6d54a644b4bcaa07ad72.png" alt="\texttt{dst} (I)= \texttt{saturate\_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} +  \texttt{beta} |)"></p><p>对于多通道矩阵，该函数对各通道独立处理。如果输出不是8位，将调用<code>Mat::convertTo</code>方法并计算结果的绝对值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mat_&lt;float&gt; A(30,30);</span><br><span class="line">&gt; randu(A, Scalar(-100), Scalar(100));</span><br><span class="line">&gt; Mat_&lt;float&gt; B = A*5 + 3;</span><br><span class="line">&gt; B = abs(B);</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>为了能够用图像显示，提供一个直观的图形，我们利用该方法，将-256 — 255的导数值，转成0 — 255的无符号8位类型。</p><p>addWeighted函数</p><blockquote><p>计算两个矩阵的加权和。</p><ul><li>C++:<code></code>void <code>addWeighted</code>(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, intdtype=-1)</li></ul><p>函数<code>addWeighted</code> 两个数组的加权和公式如下：</p><p>　　　　<img src="http://docs.opencv.org/_images/math/160c3479896ac799bb5c7d260a052e6b35c463ef.png" alt="\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +  \texttt{gamma} )"></p><p>在多通道情况下，每个通道是独立处理的，该函数可以被替换成一个函数表达式：</p><p>　　　　dst = src1<em>alpha + src2</em>beta + gamma;</p></blockquote><p>利用convertScaleAbs和addWeighted，我们可以对梯度进行一个可以用图像显示的近似表达。</p><p>这样我们就可以得到下面的效果：</p><p><img src="http://docs.opencv.org/_images/Sobel_Derivatives_Tutorial_Result.jpg" alt="Result of applying Sobel operator to lena.jpg"></p><p>梯度方向</p><p>但有时候边界还不够，我们希望得到图片色块之间的关系，或者研究样本的梯度特征来对机器训练识别物体时候，我们还需要梯度的方向。</p><p>二维平面的梯度定义为：</p><p>　　　　<img src="http://pic002.cnblogs.com/images/2012/372204/2012112220142684.jpg" alt="img"></p><p>这很好理解，其表明颜色增长的方向与x轴的夹角。</p><p>但Sobel算子对于沿x轴和y轴的排列表示的较好，但是对于其他角度表示却不够精确。这时候我们可以使用Scharr滤波器。</p><p>Scharr滤波器的内核为：</p><p>　　　　<img src="http://docs.opencv.org/_images/math/d1340f7bb6665e67c94c196809095f23054fca2c.png" alt="G_{x} = \begin{bmatrix}-3 &amp; 0 &amp; +3  \\-10 &amp; 0 &amp; +10  \\-3 &amp; 0 &amp; +3\end{bmatrix}G_{y} = \begin{bmatrix}-3 &amp; -10 &amp; -3  \\0 &amp; 0 &amp; 0  \\+3 &amp; +10 &amp; +3\end{bmatrix}"></p><p>这样能提供更好的角度信息，现在我们修改原程序，改为使用Scharr滤波器进行计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;#include &quot;opencv2/imgproc/imgproc.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int main( int argc, char** argv )&#123;</span><br><span class="line"></span><br><span class="line">    Mat src, src_gray;</span><br><span class="line">    Mat grad;</span><br><span class="line">    char* window_name = &quot;梯度计算&quot;;</span><br><span class="line">    int scale = 1;</span><br><span class="line">    int delta = 0;</span><br><span class="line">    int ddepth = CV_16S;</span><br><span class="line"></span><br><span class="line">    int c;</span><br><span class="line"></span><br><span class="line">    src = imread( argv[1] );</span><br><span class="line"></span><br><span class="line">    if( !src.data )&#123; </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GaussianBlur( src, src, Size(3,3), 0, 0, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">    cvtColor( src, src_gray, CV_RGB2GRAY );</span><br><span class="line"></span><br><span class="line">    namedWindow( window_name, CV_WINDOW_AUTOSIZE );</span><br><span class="line"></span><br><span class="line">    Mat grad_x, grad_y;</span><br><span class="line">    Mat abs_grad_x, abs_grad_y;</span><br><span class="line"></span><br><span class="line">    //改为Scharr滤波器计算x轴导数</span><br><span class="line">    Scharr( src_gray, grad_x, ddepth, 1, 0, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_x, abs_grad_x );</span><br><span class="line"></span><br><span class="line">    //改为Scharr滤波器计算y轴导数</span><br><span class="line">    Scharr( src_gray, grad_y, ddepth, 0, 1, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_y, abs_grad_y );</span><br><span class="line"></span><br><span class="line">    addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );</span><br><span class="line"></span><br><span class="line">    imshow( window_name, grad );</span><br><span class="line"></span><br><span class="line">    waitKey(0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;&lt;/span&gt;&lt;strong style=&quot;font-size:24px;&quot;&gt;</span><br><span class="line">&lt;/strong&gt;</span><br></pre></td></tr></table></figure><p>Scharr函数接受参数与Sobel函数相似，这里就不叙述了。</p><p>下面我们通过divide函数就能得到一个x/y的矩阵。</p><blockquote><p>对两个输入数组的每个元素执行除操作。</p><ul><li>C++:<code></code>void <code>divide</code>(InputArray src1, InputArray src2, OutputArray dst, double scale=1, int dtype=-1)</li></ul><ul><li>C++:<code></code>void <code>divide</code>(double scale, InputArray src2, OutputArray dst, int dtype=-1)</li></ul><p>该函数对两个数组进行除法：</p><p>　　<img src="http://docs.opencv.org/_images/math/b95a5073fc087b8fc404bc7795982e1570891bd3.png" alt="\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}"></p><p>或则只是缩放系数除以一个数组：</p><p>　　<img src="http://docs.opencv.org/_images/math/8d762e1a527b3613404ec26a98faffd43d1ceb78.png" alt="\texttt{dst(I) = saturate(scale/src2(I))}"></p><p>这种情况如果src2是0，那么dst也是0。不同的通道是独立处理的。</p></blockquote></cxcore.h></ml.h></highgui.h></cvaux.h></cv.h>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;p&gt;在实验室里听一点记一点，到时候再总结整理吧。先记下来再说。&lt;/p&gt;
&lt;p&gt;一定要记住的page：&lt;a href=&quot;http://wiki.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5
      
    
    </summary>
    
      <category term="think" scheme="sherry0429.github.io/categories/think/"/>
    
    
      <category term="opencv" scheme="sherry0429.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1247 字典树</title>
    <link href="sherry0429.github.io/2018/02/11/HDU-1247-%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>sherry0429.github.io/2018/02/11/HDU-1247-字典树/</id>
    <published>2018-02-11T06:51:50.000Z</published>
    <updated>2018-02-11T09:04:58.922Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 26</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">NumTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    NumTree ans[MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NumTree <span class="title">init</span><span class="params">(NumTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    T=<span class="keyword">new</span> struct node;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;tag=<span class="number">0</span>;</span><br><span class="line">        T-&gt;ans[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T,S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            S=<span class="keyword">new</span> struct node;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                S-&gt;ans[j]=<span class="literal">NULL</span>;</span><br><span class="line">                S-&gt;tag=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q-&gt;ans[id]=S;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;tag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Stack;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;tag &amp;&amp; i&lt;len)<span class="comment">//find sepraste point</span></span><br><span class="line">        &#123;</span><br><span class="line">            Stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Stack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now=Stack.front();</span><br><span class="line">        now++;</span><br><span class="line">        <span class="keyword">bool</span> OK=<span class="literal">true</span>;</span><br><span class="line">        Stack.pop();</span><br><span class="line">        Q=T;</span><br><span class="line">        <span class="keyword">while</span>(str[now])</span><br><span class="line">        &#123;</span><br><span class="line">            id=str[now++]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(Q-&gt;ans[id]==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                OK=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(OK &amp;&amp; Q-&gt;tag)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">50011</span>][<span class="number">20</span>];</span><br><span class="line">    NumTree T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    T=init(T);</span><br><span class="line">    <span class="keyword">while</span>(gets(str[x]) &amp;&amp; str[x][<span class="number">0</span>]!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(T,str[x]);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>;u&lt;x;u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(find(T,str[u])==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;str[u]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞了一下午····</p><p>不得不说还是有一些收获，RE的次数最多，</p><p>这里要说一下，RE分两种，一种越界，一种是栈溢出，</p><p>这里在定义str的时候，</p><p>如果定义str[50001][100],就会栈溢出，可见字典树对字符长度的要求很高，不能太长。</p><p>整个代码的思路就是在insert同时的时候标记，一个字符如果是一个字符串的结尾字符，那么标记，</p><p>在find的时候，如果找到了一个标记，找到了A个标记，说明这个字符串里含有A个字符串，但无法确定这A个字符串是否是紧邻的，这里需要用STACK或者QUEUE，最好还是用STACK，依次记录有标记的下标，然后从后往前开始查询，</p><p>这里还有一个小细节，在查询的时候now++,因为top回来的now是一个字符的结尾，重新遍历的时候应该是从找到标记的字符的后一个字符开始。</p><p>然后如果有两个以上标记是怎么回事呢？</p><p>如果</p><p>abcdefg</p><p>1001001</p><p>有三个标记，这时候从最后一个1开始找，然后从倒数第二个1找，而这里的1代表，至少字典里有a,abcd,abcdefg三个字符串（也可能有defg,bcd等等），也就是说我从标记的下一个字符开始找起，标记的前半部分已经肯定在字符串里了（也就是组成该字符串的前半段），只需要证明从标记开始的字符串也在字典树里，那么就满足该字符串由两个字符串构成，输出即可。</p><p>这题还有一个思路，就是把每一个字符串在不同位置“砍一刀”，变成两个字符串，然后find(str1)find(str2),如果都能找到，那么就说明它（这个字符串）有两个字符串构成，这个代码我也实现了，但是不知道为什么一直RE，可能是迭代或者递归的层数太多了（find要递归，如果字符串很长的话，也要砍很多刀）。暂时我还没有想到比较好的优化方案。砍刀也许可以用二分查找实现，但那仍然依赖输入。对效率提升不一定十分明显。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 26</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">NumTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NumTree ans[MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NumTree <span class="title">init</span><span class="params">(NumTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    T=<span class="keyword">new</span> struct node;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">        T-&gt;ans[i]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T,S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            S=<span class="keyword">new</span> struct node;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX;j++)</span><br><span class="line">                S-&gt;ans[j]=<span class="literal">NULL</span>;</span><br><span class="line">            Q-&gt;ans[id]=S;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="keyword">int</span> tag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]!=<span class="literal">NULL</span>)</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(NumTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;ans[i]!=<span class="literal">NULL</span>)</span><br><span class="line">            FreeTree(T-&gt;ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">50011</span>][<span class="number">100</span>];</span><br><span class="line">    NumTree T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    T=init(T);</span><br><span class="line">    <span class="keyword">while</span>(gets(str[x]) &amp;&amp; str[x][<span class="number">0</span>]!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(T,str[x]);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>;u&lt;x;u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str[u]);</span><br><span class="line">        <span class="keyword">char</span> str1[<span class="number">100</span>],str2[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span>(k&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">                str1[i]=str[u][i];</span><br><span class="line">            str1[i]=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;i&lt;len;i++,j++)</span><br><span class="line">                str2[j]=str[u][i];</span><br><span class="line">            str2[j]=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(find(T,str1) &amp;&amp; find(T,str2))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str[u]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//FreeTree(T);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, acm, hdu" scheme="sherry0429.github.io/tags/c-acm-hdu/"/>
    
  </entry>
  
  <entry>
    <title>HDU 3790 双权最短路</title>
    <link href="sherry0429.github.io/2018/02/11/HDU-3790-%E5%8F%8C%E6%9D%83%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>sherry0429.github.io/2018/02/11/HDU-3790-双权最短路/</id>
    <published>2018-02-11T06:51:35.000Z</published>
    <updated>2018-02-11T09:05:06.487Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> cost[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=MAX;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=MAX;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[i][j]=<span class="number">0</span>;</span><br><span class="line">cost[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[i][j]=INF;</span><br><span class="line">cost[i][j]=INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> next,minc;</span><br><span class="line"><span class="keyword">int</span> dist[MAX],visit[MAX],value[MAX];</span><br><span class="line"><span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">dist[i]=<span class="built_in">map</span>[start][i];</span><br><span class="line">value[i]=cost[start][i];</span><br><span class="line">&#125;</span><br><span class="line">visit[start]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">minc=INF;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visit[j] &amp;&amp; minc&gt;dist[j])</span><br><span class="line">&#123;</span><br><span class="line">minc=dist[j];</span><br><span class="line">next=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visit[next]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visit[j] &amp;&amp; <span class="built_in">map</span>[next][j]&lt;INF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;dist[next]+<span class="built_in">map</span>[next][j])</span><br><span class="line">&#123;</span><br><span class="line">dist[j]=dist[next]+<span class="built_in">map</span>[next][j];</span><br><span class="line">value[j]=value[next]+cost[next][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dist[j]==(dist[next]+<span class="built_in">map</span>[next][j]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(value[j]&gt;value[next]+cost[next][j])</span><br><span class="line">value[j]=value[next]+cost[next][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,dist[end],value[end]);</span><br><span class="line"><span class="comment">//cout&lt;&lt;dist[end]&lt;&lt;' '&lt;&lt;value[end]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> start,end;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> time,<span class="built_in">cos</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;time&gt;&gt;<span class="built_in">cos</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[x][y]&gt;time)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[x][y]=<span class="built_in">map</span>[y][x]=time;</span><br><span class="line">cost[x][y]=cost[y][x]=<span class="built_in">cos</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[x][y]==time)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cost[x][y]&gt;<span class="built_in">cos</span>)</span><br><span class="line">cost[x][y]=cost[y][x]=<span class="built_in">cos</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;start&gt;&gt;end;</span><br><span class="line">dijkstra(start,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种题需要注意的就两点，特别重要的两点，初始化，和输入的设置（if语句），再就是Dijastra在更新时候的代码语句设置了。</p><p>这道题我在Virtual judge上做的，有一个很奇怪的情况。。。就是如果用cout,那就RE了，但用printf,就AC了（G++提交），然后如果用cin,cout组合，用C++提交，就WA了=，=</p><p>不懂是为什么=，=感觉好神奇</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, acm, hdu" scheme="sherry0429.github.io/tags/c-acm-hdu/"/>
    
  </entry>
  
  <entry>
    <title>HDU2544 Floyd</title>
    <link href="sherry0429.github.io/2018/02/11/HDU2544-Floyd/"/>
    <id>sherry0429.github.io/2018/02/11/HDU2544-Floyd/</id>
    <published>2018-02-11T06:51:17.000Z</published>
    <updated>2018-02-11T09:04:51.427Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 9999999</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)</span><br><span class="line"><span class="built_in">map</span>[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[j][i]=INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i][j]&gt;<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j])</span><br><span class="line"><span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;price;</span><br><span class="line">x--,y--;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[x][y]&gt;price)</span><br><span class="line"><span class="built_in">map</span>[x][y]=<span class="built_in">map</span>[y][x]=price;</span><br><span class="line">&#125;</span><br><span class="line">floyd();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">map</span>[<span class="number">0</span>][n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码本身不难，Floyd实现只是三个循环，但这道题需要注意的一些小问题让我WA了不少次.</p><ul><li>初始化，MAX和INF这两个预编译参数最好分开来写。</li><li>对Map的初始化需要考虑对角线上的元素为零，其余为INF，此外，每次初始化循环上限应为MAX，而非输入的顶点数。</li><li>input过程中，根据输入时刻更新Map[x][y]的值（即cin&gt;&gt;后的if语句）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, acm, hdu" scheme="sherry0429.github.io/tags/c-acm-hdu/"/>
    
  </entry>
  
  <entry>
    <title>Floyd,Dijkstra,SPFA</title>
    <link href="sherry0429.github.io/2018/02/11/Floyd-Dijkstra-SPFA/"/>
    <id>sherry0429.github.io/2018/02/11/Floyd-Dijkstra-SPFA/</id>
    <published>2018-02-11T06:50:58.000Z</published>
    <updated>2018-02-11T09:04:37.912Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><p>source link: <a href="http://gzhu-101majia.iteye.com/blog/1150170" target="_blank" rel="noopener">http://gzhu-101majia.iteye.com/blog/1150170</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">99999999</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[N][N], dist[N];  </span><br><span class="line"><span class="keyword">bool</span> visit[N];  </span><br><span class="line"><span class="keyword">int</span> n, m;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>     <span class="comment">//初始化  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="built_in">map</span>[i][j] = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[j][i] = INF;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span>    <span class="comment">//输入函数  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> vi, vj, cost;  </span><br><span class="line">    <span class="keyword">while</span>(m--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;vi, &amp;vj, &amp;cost);  </span><br><span class="line">        <span class="keyword">if</span>(cost &lt; <span class="built_in">map</span>[vi][vj])  </span><br><span class="line">            <span class="built_in">map</span>[vi][vj] = <span class="built_in">map</span>[vj][vi] = cost;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span>    <span class="comment">//Floyd算法  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j, k;  </span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++)     <span class="comment">//k为中间点  </span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)  </span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j] &lt;  <span class="built_in">map</span>[i][j])  </span><br><span class="line">                     <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijk</span><span class="params">()</span>     <span class="comment">//Dijkstra算法  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j, next, MIN;  </span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;  </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        MIN = INF;  </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  </span><br><span class="line">            <span class="keyword">if</span>(!visit[j] &amp;&amp; dist[j] &lt;= MIN)  </span><br><span class="line">                MIN = dist[next=j];  </span><br><span class="line">        <span class="keyword">if</span>(MIN == INF) <span class="keyword">break</span>;  </span><br><span class="line">        visit[next] = <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  </span><br><span class="line">            <span class="keyword">if</span>(!visit[j] &amp;&amp; dist[j] &gt; dist[next] + <span class="built_in">map</span>[next][j])  </span><br><span class="line">                dist[j] = dist[next] + <span class="built_in">map</span>[next][j];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span>     <span class="comment">//SPFA算法  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, now;  </span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;  </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;  </span><br><span class="line">    Q.push(<span class="number">1</span>);  </span><br><span class="line">    visit[<span class="number">1</span>] = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        now = Q.front();  </span><br><span class="line">        Q.pop();  </span><br><span class="line">        visit[now] = <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(dist[i] &gt; dist[now] + <span class="built_in">map</span>[now][i])  </span><br><span class="line">            &#123;  </span><br><span class="line">                dist[i] = dist[now] + <span class="built_in">map</span>[now][i];  </span><br><span class="line">                <span class="keyword">if</span>(visit[i] == <span class="number">0</span>)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    Q.push(i);  </span><br><span class="line">                    visit[i] = <span class="literal">true</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m))  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(!n || !m) <span class="keyword">break</span>;  </span><br><span class="line">        init();  </span><br><span class="line">        input();  </span><br><span class="line">        <span class="comment">//floyd();  </span></span><br><span class="line">        <span class="comment">//dijk();  </span></span><br><span class="line">        spfa();  </span><br><span class="line">        <span class="comment">//printf("%d\n", map[1][n]);  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[n]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;p&gt;source link: &lt;a href=&quot;http://gzhu-101majia.iteye.com/blog/1150170&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://gzhu-1
      
    
    </summary>
    
      <category term="code_template" scheme="sherry0429.github.io/categories/code-template/"/>
    
    
      <category term="c, acm" scheme="sherry0429.github.io/tags/c-acm/"/>
    
  </entry>
  
  <entry>
    <title>prim</title>
    <link href="sherry0429.github.io/2018/02/11/prim/"/>
    <id>sherry0429.github.io/2018/02/11/prim/</id>
    <published>2018-02-11T06:50:36.000Z</published>
    <updated>2018-02-11T09:06:02.073Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line"><span class="built_in">map</span>[i][j]=MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> minc,mht;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> visit[<span class="number">100</span>],lowcost[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">lowcost[i]=<span class="built_in">map</span>[<span class="number">0</span>][i];</span><br><span class="line">visit[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">mht=<span class="number">-1</span>;</span><br><span class="line">minc=MAX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[j]==<span class="number">0</span> &amp;&amp; minc&gt;lowcost[j])</span><br><span class="line">&#123;</span><br><span class="line">minc=lowcost[j];</span><br><span class="line">mht=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mht==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">sum+=minc;</span><br><span class="line">visit[mht]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[j]==<span class="number">0</span> &amp;&amp; lowcost[j]&gt;<span class="built_in">map</span>[mht][j])</span><br><span class="line">lowcost[j]=<span class="built_in">map</span>[mht][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">int</span> m=(n*(n<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">a--,b--;</span><br><span class="line"><span class="built_in">map</span>[a][b]=c;</span><br><span class="line"><span class="built_in">map</span>[b][a]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum=Prim(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的精华在：</p><ul><li>初始化（MAX！！！）这牵扯到后面的比较，十分重要。</li><li>两个数组vistied[max],和lowcast[max].</li><li>每找到一条边后进行的更新操作.</li></ul><p>理解该算法的重点在，理解lowcast里存的到底是什么。</p><p>简单来说，lowcast[i],就是i可达的顶点中，到i的最小距离，它在prim算法执行过程中被不断更新（或不更新，因为没有更小的路径）。</p><p>如果要标记出一条最小路径，那么记忆一下mht即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, acm" scheme="sherry0429.github.io/tags/c-acm/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal</title>
    <link href="sherry0429.github.io/2018/02/11/Kruskal/"/>
    <id>sherry0429.github.io/2018/02/11/Kruskal/</id>
    <published>2018-02-11T06:50:26.000Z</published>
    <updated>2018-02-11T09:05:43.014Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">int</span> price,vis;</span><br><span class="line">&#125;Edge[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge x,edge y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.vis!=y.vis)</span><br><span class="line"><span class="keyword">return</span> x.vis&lt;y.vis;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> x.price&lt;y.price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x!=ans[x])</span><br><span class="line">ans[x]=find(ans[x]);</span><br><span class="line"><span class="keyword">return</span> ans[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tx=find(a);</span><br><span class="line"><span class="keyword">int</span> ty=find(b);</span><br><span class="line"><span class="keyword">if</span>(tx!=ty)</span><br><span class="line">ans[tx]=ty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sort(Edge+<span class="number">1</span>,Edge+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tx=find(Edge[i].u);</span><br><span class="line"><span class="keyword">int</span> ty=find(Edge[i].v);</span><br><span class="line"><span class="keyword">if</span>(tx!=ty &amp;&amp; !Edge[i].vis)</span><br><span class="line">&#123;</span><br><span class="line">sum+=Edge[i].price;</span><br><span class="line">ans[tx]=ty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">m=(n*(n<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;Edge[i].u,&amp;Edge[i].v,&amp;Edge[i].price,&amp;Edge[i].vis);</span><br><span class="line"><span class="keyword">if</span>(Edge[i].vis==<span class="number">1</span>)</span><br><span class="line">Merge(Edge[i].u,Edge[i].v);</span><br><span class="line">&#125;</span><br><span class="line">Kruskal();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接上代码，需要注意的有几点：</p><ul><li>初始化。</li><li>排序，sort函数的使用。一定要排序，Kruskal关键就是在排序，而prim则是用一个顶点数组lowcast达到类似的排序效果。</li><li>这道题是和并查集连起来用了，因为涉及到“已建”和“未建”两种集合，如果是直接read Graph,初始状态要么就是都没建，要么就是都已建好（找出最短路），那就不需要用并查集，直接用MAP[MAX[[MAX[即可。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, acm" scheme="sherry0429.github.io/tags/c-acm/"/>
    
  </entry>
  
  <entry>
    <title>Graham</title>
    <link href="sherry0429.github.io/2018/02/11/Graham/"/>
    <id>sherry0429.github.io/2018/02/11/Graham/</id>
    <published>2018-02-11T06:49:31.000Z</published>
    <updated>2018-02-11T09:04:46.413Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><p>code_template from internet (unknown link):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">struct Point  </span><br><span class="line">&#123;  </span><br><span class="line">    double x,y;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">Point point[1003];  </span><br><span class="line">Point stack[1003];//把构成凸包的点存到stack中,存入点的个数为top个  </span><br><span class="line">int c,n,top;  </span><br><span class="line">double l,r;  </span><br><span class="line">  </span><br><span class="line">int multi(Point p0,Point p1,Point p2)  </span><br><span class="line">&#123;  </span><br><span class="line">    return ((p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">double dis(Point p1,Point p2)  </span><br><span class="line">&#123;  </span><br><span class="line">    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int cmp(Point a,Point b)  </span><br><span class="line">&#123;  </span><br><span class="line">    if(multi(point[0],a,b)&gt;0) return 1;  </span><br><span class="line">        if(multi(point[0],a,b)&lt;0) return 0;  </span><br><span class="line">            if(dis(point[0],a)&lt;dis(point[0],b))  </span><br><span class="line">                return 1;  </span><br><span class="line">                return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">void graham()  </span><br><span class="line">&#123;  </span><br><span class="line">    int i,k=0;  </span><br><span class="line">    Point temp;  </span><br><span class="line">    for(i=1; i&lt;n; i++)  </span><br><span class="line">        if((point[i].y&lt;point[k].y)||((point[i].y==point[k].y)&amp;&amp;(point[i].x&lt;point[k].x)))  </span><br><span class="line">            k=i;  </span><br><span class="line">    temp=point[0];  </span><br><span class="line">    point[0]=point[k];  </span><br><span class="line">    point[k]=temp;  </span><br><span class="line">    sort(point+1,point+n,cmp);//按极角的大小进行排序  </span><br><span class="line">    stack[0]=point[0];  </span><br><span class="line">    stack[1]=point[1];  </span><br><span class="line">   top=1;  </span><br><span class="line">   i=2;  </span><br><span class="line">     while(i&lt;n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(multi(stack[top],stack[top-1],point[i])&lt;=0)</span><br><span class="line">        //AB x AC&gt;0 AC在AB的逆时针方向  </span><br><span class="line">        //AB x AC&lt;0 AC在AB的顺时针方向  </span><br><span class="line">        //AB x AC=0 ABC 共线  </span><br><span class="line">            stack[++top]=point[i++];  </span><br><span class="line">        else  </span><br><span class="line">            top--;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我对这个算法的理解是，核心在于判断左右拐，而在判断前要做一些准备工作。</p><p>首先要有一个记录点顺序的结构和记录输入的结构【例如数组】，然后讲点对都记录下来了以后，</p><ul><li>首先找到最左下角的那个顶点（x最小，y最小或与第二小的点相等）</li><li>把这个点和记录输入的第一个点交换，把输入的第一个点放到最后去。</li><li>进行排序.</li><li>根据向量外积大于零或者小于零判断左拐或者右拐，用栈或者数组来完成记录点或者删除点的工作。（需要预先读入两个点）。</li></ul><p>算法到此结束，最后将点对输出和距离和即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;p&gt;code_template from internet (unknown link):&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, acm" scheme="sherry0429.github.io/tags/c-acm/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1232 并查集</title>
    <link href="sherry0429.github.io/2018/02/11/HDU-1232-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>sherry0429.github.io/2018/02/11/HDU-1232-并查集/</id>
    <published>2018-02-11T06:49:06.000Z</published>
    <updated>2018-02-11T09:04:56.201Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><p>source link : <a href="http://hi.baidu.com/nicker2010/item/9b593c2019c720846f2cc3ee" target="_blank" rel="noopener">http://hi.baidu.com/nicker2010/item/9b593c2019c720846f2cc3ee</a></p><h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>  某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？</p><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><p>  测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。<br>  注意:两个城市之间可以有多条道路相通,也就是说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这种输入也是合法的<br> 当N为0时，输入结束，该用例不被处理。</p><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><p>对每个测试用例，在1行里输出最少还需要建设的道路数目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sample Input</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">999</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment">//Sample Output</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">998</span></span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p><strong>并查集由一个整数型的数组和两个函数构成。数组pre[]记录了每个点的前导点是什么，函数find是查找，join是合并。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[<span class="number">1000</span> ];  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="comment">//查找根节点  </span></span><br><span class="line"><span class="keyword">int</span> r=x; <span class="keyword">while</span> (pre[r ]!=r) r=pre[r ]; <span class="comment">//路径压缩  </span></span><br><span class="line"><span class="keyword">int</span> i=x; <span class="keyword">int</span> j; <span class="keyword">while</span>(i!=r) &#123; j=pre[i ]; pre[i ]=r; i=j; &#125; <span class="comment">//返回根节点  </span></span><br><span class="line"><span class="keyword">return</span> r;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">//判断x y是否连通  </span></span><br><span class="line"><span class="comment">//如果已经连通，就不用管了 //如果不连通，就把它们所在的连通分支合并起,  </span></span><br><span class="line"><span class="keyword">int</span> fx=find(x),fy=find(y);  </span><br><span class="line"><span class="keyword">if</span>(fx!=fy) pre[fx ]=fy; &#125;</span><br></pre></td></tr></table></figure><p><img src="http://img.blog.csdn.net/20140610222158078?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxNDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</p><p>我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。</p><p>但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。</p><p> 下面我们来看并查集的实现。</p><p> int pre[1000]; 这个数组，记录了每个大侠的上级是谁。</p><p>大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。 find这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">nt <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//查找根节点  </span></span><br><span class="line"><span class="keyword">int</span> r=x; <span class="keyword">while</span> (pre[r ]!=r)<span class="comment">//如果我的上级不是掌门  </span></span><br><span class="line">r=pre[r ];<span class="comment">//我就接着找他的上级，直到找到掌门为止。  </span></span><br><span class="line"><span class="comment">//返回根节点  </span></span><br><span class="line"><span class="keyword">return</span> r;<span class="comment">//掌门驾到~~~  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看join函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”抗议无效，上天安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//我想让虚竹和周芷若做朋友  </span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span> fx=find(x),fy=find(y); <span class="comment">//虚竹的老大是玄慈，  </span></span><br><span class="line">芷若MM的老大是灭绝  </span><br><span class="line"><span class="keyword">if</span>(fx!=fy)<span class="comment">//玄慈和灭绝显然不是同一个人  </span></span><br><span class="line">pre[fx ]=fy;<span class="comment">//方丈只好委委屈屈地当了师太的手下啦  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看<strong>路径压缩算法</strong>。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂也没关系，直接抄上用就行了。总之它所实现的功能就是这么个意思。</p><p><img src="http://img.blog.csdn.net/20140610222224500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxNDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> int pre[1000 ];  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </span><br><span class="line"><span class="keyword">int</span> r=x;  </span><br><span class="line"><span class="keyword">while</span> (pre[r ]!=r)  </span><br><span class="line">r=pre[r ];  </span><br><span class="line"><span class="keyword">int</span> i=x; <span class="keyword">int</span> j;  </span><br><span class="line"><span class="keyword">while</span>(i!=r)  </span><br><span class="line">&#123;  </span><br><span class="line">j=pre[i ]; pre[i ]=r; i=j;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> r;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">这里我没有路径压缩， 直接上代码吧！  </span><br><span class="line">有根树  </span><br><span class="line">Father[i] = i , 则i表示本集合，并是集合对应树的根  </span><br><span class="line">Father[i] = j, j!=i, 则 j 是 i 的父节点  </span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">1005</span>;  </span><br><span class="line"><span class="keyword">int</span> Father[MAX];  </span><br><span class="line"><span class="keyword">int</span> Ans;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findx</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//找x的根节点  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> r = x;  </span><br><span class="line">    <span class="keyword">while</span>(Father[r]!=r) r=Father[r];  </span><br><span class="line">    <span class="keyword">return</span> r;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> xf = findx(x);<span class="comment">//x根节点  </span></span><br><span class="line">    <span class="keyword">int</span> yf = findx(y);<span class="comment">//y根节点  </span></span><br><span class="line">    <span class="keyword">if</span>(xf != yf)<span class="comment">//根节点不同则设一个位另外一个的根  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        Father[xf] = yf;  </span><br><span class="line">        --Ans;<span class="comment">//合并了两颗树，所以需要添加的路径的数目减一！  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> N,M,i,x,y;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;N)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>) <span class="keyword">break</span>;  </span><br><span class="line">        Ans = N<span class="number">-1</span>; <span class="comment">//初始化Ans等于N个点联通所需要的最少边的数目！  </span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=N;++i) Father[i] = i;  </span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;M;  </span><br><span class="line">        <span class="keyword">while</span>(M--)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;  </span><br><span class="line">            Merge(x,y);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;Ans&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;p&gt;source link : &lt;a href=&quot;http://hi.baidu.com/nicker2010/item/9b593c2019c720846f2cc3ee&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, acm, hdu" scheme="sherry0429.github.io/tags/c-acm-hdu/"/>
    
  </entry>
  
  <entry>
    <title>邻接表存图</title>
    <link href="sherry0429.github.io/2018/02/11/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%9B%BE/"/>
    <id>sherry0429.github.io/2018/02/11/邻接表存图/</id>
    <published>2018-02-11T06:48:43.000Z</published>
    <updated>2018-02-11T09:06:25.358Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"malloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> adjvex;<span class="comment">//临接的边序号.</span></span><br><span class="line">ArcNode *next;<span class="comment">//下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;<span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *InputLine;<span class="comment">//出边表</span></span><br><span class="line">ArcNode *OutputLine;<span class="comment">//入边表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Vnode vertexs[MAX];<span class="comment">//顶点数组</span></span><br><span class="line"><span class="keyword">int</span> vexnum;<span class="comment">//顶点数</span></span><br><span class="line"><span class="keyword">int</span> arcnum;<span class="comment">//边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Graph G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">ArcNode *pi;</span><br><span class="line"><span class="keyword">int</span> v1,v2;</span><br><span class="line">G.vexnum=<span class="number">0</span>;</span><br><span class="line">G.arcnum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input Graph's vexnum or arcnum.\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;G.vexnum,&amp;G.arcnum);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">G.vertexs[i].InputLine=G.vertexs[i].OutputLine=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input partner number like X X by point to point.\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.arcnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;v1,&amp;v2);</span><br><span class="line">v1--,v2--;</span><br><span class="line"><span class="comment">//input line</span></span><br><span class="line">pi=(ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ArcNode));</span><br><span class="line">pi-&gt;adjvex=v2;</span><br><span class="line">pi-&gt;next=G.vertexs[v1].InputLine;</span><br><span class="line">G.vertexs[v1].InputLine=pi;</span><br><span class="line"><span class="comment">//output line</span></span><br><span class="line"></span><br><span class="line">pi=(ArcNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ArcNode));</span><br><span class="line">pi-&gt;adjvex=v1;</span><br><span class="line">pi-&gt;next=G.vertexs[v2].OutputLine;</span><br><span class="line">G.vertexs[v2].OutputLine=pi;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">ArcNode *pi;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//free input line</span></span><br><span class="line">pi=G.vertexs[i].InputLine;</span><br><span class="line"><span class="keyword">while</span>(pi!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">G.vertexs[i].InputLine=pi-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line">pi=G.vertexs[i].InputLine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//free output line</span></span><br><span class="line">pi=G.vertexs[i].OutputLine;</span><br><span class="line"><span class="keyword">while</span>(pi!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">G.vertexs[i].OutputLine=pi-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(pi);</span><br><span class="line">pi=G.vertexs[i].OutputLine;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CreatGraph();</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line">ArcNode *pi;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">pi=G.vertexs[i].InputLine;</span><br><span class="line"><span class="keyword">while</span>(pi!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">pi=pi-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d points Inputline is:%d\n"</span>,i+<span class="number">1</span>,sum);</span><br><span class="line"></span><br><span class="line">pi=G.vertexs[i].OutputLine;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(pi!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">pi=pi-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d points OutputLine is %d\n"</span>,i+<span class="number">1</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line">DeleteGraph();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, acm" scheme="sherry0429.github.io/tags/c-acm/"/>
    
  </entry>
  
  <entry>
    <title>二叉堆</title>
    <link href="sherry0429.github.io/2018/02/11/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <id>sherry0429.github.io/2018/02/11/二叉堆/</id>
    <published>2018-02-11T06:48:29.000Z</published>
    <updated>2018-02-11T09:06:05.019Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上滤，下滤，指空穴的移动方向.</span></span><br><span class="line"><span class="comment">//另，二叉堆有堆序性，即父亲的权值始终小于每个儿子的权值。所以顶端是Min.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Element int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MinDATA -1</span></span><br><span class="line"><span class="comment">//MinData is first of Array.</span></span><br><span class="line"><span class="comment">//This MinDATA support a kindof heap which every num is bigger than zero.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">Two_Heap</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> *Array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Two_Heap <span class="title">InitHeap</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>;<span class="comment">//if not space,return 0;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(Two_Heap H)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">(Two_Heap H)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Element X,Two_Heap H)</span></span>;</span><br><span class="line"><span class="function">Element <span class="title">DeleteMin</span><span class="params">(Two_Heap H)</span></span>;</span><br><span class="line"><span class="function">Element <span class="title">FindMin</span><span class="params">(Two_Heap H)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Two_Heap H)</span></span>;<span class="comment">//if empty,return 0;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(Two_Heap H)</span></span>;<span class="comment">//if full,return 0;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Two_Heap <span class="title">InitHeap</span><span class="params">(<span class="keyword">int</span> Maxsize)</span><span class="comment">//if not space,return 0;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Two_Heap H;</span><br><span class="line">H=(Two_Heap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct node));</span><br><span class="line"><span class="keyword">if</span>(H==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"no space!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">H-&gt;Array=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*Maxsize+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(H-&gt;Array==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"no space!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">H-&gt;capacity=Maxsize;</span><br><span class="line">H-&gt;size=<span class="number">0</span>;</span><br><span class="line">H-&gt;Array[<span class="number">0</span>]=MinDATA;<span class="comment">//signal to end insert's "for"</span></span><br><span class="line"><span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">(Two_Heap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(IsEmpty(H)!=<span class="number">0</span>)<span class="comment">//not empty </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(H-&gt;Array);</span><br><span class="line"><span class="built_in">free</span>(H);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Element X,Two_Heap H)</span><span class="comment">//上滤</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(IsFull(H)==<span class="number">0</span>)<span class="comment">//has been full</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This Two_Heap has been full.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=++H-&gt;size;H-&gt;Array[i/<span class="number">2</span>]&gt;X;i/=<span class="number">2</span>)<span class="comment">//that"++H-&gt;size" make points from one space. </span></span><br><span class="line">H-&gt;Array[i]=H-&gt;Array[i/<span class="number">2</span>];<span class="comment">//every father instead child,and insteaded X.</span></span><br><span class="line"><span class="comment">//down to up,and every child instead of it's father.</span></span><br><span class="line"><span class="comment">//child to father</span></span><br><span class="line"><span class="comment">//and "H-&gt;size has been ++ in shadow."</span></span><br><span class="line">H-&gt;Array[i]=X;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Element <span class="title">DeleteMin</span><span class="params">(Two_Heap H)</span><span class="comment">//下滤</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,child;</span><br><span class="line">Element MinElement,LastElement;</span><br><span class="line"><span class="comment">//why have LastElement?</span></span><br><span class="line"><span class="comment">//MinElement to save array[1],because array[1] will be change,</span></span><br><span class="line"><span class="comment">//LastElement is "people" who we should move to right space.</span></span><br><span class="line"><span class="keyword">if</span>(IsEmpty(H)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"No space can be delete,it's empty!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> H-&gt;Array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">MinElement=H-&gt;Array[<span class="number">1</span>];</span><br><span class="line">LastElement=H-&gt;Array[H-&gt;size--];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i*<span class="number">2</span>&lt;=H-&gt;size;i=child)</span><br><span class="line">&#123;</span><br><span class="line">child=i*<span class="number">2</span>;<span class="comment">//father to child</span></span><br><span class="line"><span class="keyword">if</span>(child!=H-&gt;size &amp;&amp; H-&gt;Array[child+<span class="number">1</span>]&lt;H-&gt;Array[child])</span><br><span class="line">child++;</span><br><span class="line"><span class="comment">//find smaller child.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(LastElement&gt;H-&gt;Array[child])</span><br><span class="line">H-&gt;Array[i]=H-&gt;Array[child];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">H-&gt;Array[i]=LastElement;<span class="comment">//find right space.</span></span><br><span class="line"><span class="keyword">return</span> MinElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Element <span class="title">FindMin</span><span class="params">(Two_Heap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> H-&gt;Array[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Element <span class="title">IsEmpty</span><span class="params">(Two_Heap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(H-&gt;size==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Element <span class="title">IsFull</span><span class="params">(Two_Heap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(H-&gt;size==H-&gt;capacity)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this not all,Two_Heap also support some fuction.</span></span><br><span class="line"><span class="comment">//like:</span></span><br><span class="line"><span class="comment">//*DecreaseKey*</span></span><br><span class="line"><span class="comment">//*IncreaseKey*</span></span><br><span class="line"><span class="comment">//*Delete*</span></span><br><span class="line"><span class="comment">//*BuildHeap*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Two_Heap H;</span><br><span class="line"><span class="keyword">int</span> maxsize;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;maxsize);</span><br><span class="line">H=InitHeap(maxsize);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;maxsize;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">Insert(temp,H);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> min1,min2;</span><br><span class="line">min1=FindMin(H);</span><br><span class="line">DeleteMin(H);</span><br><span class="line">min2=FindMin(H);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,min1,min2);</span><br><span class="line">Destroy(H);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, acm" scheme="sherry0429.github.io/tags/c-acm/"/>
    
  </entry>
  
  <entry>
    <title>二叉查找树</title>
    <link href="sherry0429.github.io/2018/02/11/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <id>sherry0429.github.io/2018/02/11/二叉查找树/</id>
    <published>2018-02-11T06:48:11.000Z</published>
    <updated>2018-02-11T09:06:07.897Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉查找树</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Type int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">SearchTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Type Element;</span><br><span class="line">SearchTree left;</span><br><span class="line">SearchTree right;</span><br><span class="line"><span class="comment">//bool turn; 懒惰删除域</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">MakeEmpty</span><span class="params">(SearchTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(Type X,SearchTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(SearchTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(SearchTree T)</span></span>;</span><br><span class="line"><span class="function">SearchTree <span class="title">Insert</span><span class="params">(Type X,SearchTree T)</span></span>;</span><br><span class="line"><span class="function">SearchTree <span class="title">Delete</span><span class="params">(Type X,SearchTree T)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">MakeEmpty</span><span class="params">(SearchTree T)</span><span class="comment">//销毁树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">MakeEmpty(T-&gt;left);</span><br><span class="line">MakeEmpty(T-&gt;right);</span><br><span class="line"><span class="built_in">free</span>(T);<span class="comment">//清空T的内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(Type X,SearchTree T)</span><span class="comment">//注意，返回的是节点，并不是值!</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&lt;T-&gt;Element)</span><br><span class="line"><span class="keyword">return</span> Find(X,T-&gt;left);<span class="comment">//每个节点的Element大于left的Element，小于right的Element</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&gt;T-&gt;Element)</span><br><span class="line"><span class="keyword">return</span> Find(X,T-&gt;right);</span><br><span class="line"><span class="keyword">else</span><span class="comment">//找到了那个元素</span></span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(SearchTree T)</span><span class="comment">//自顶向下查找 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="comment">//此节点无儿子</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FindMin(T-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(SearchTree T)</span><span class="comment">//与Findmin均为递归实现，若不递归，利用If和while不断遍历左节点或右节点即可</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="comment">//此节点无儿子</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FindMax(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">Insert</span><span class="params">(Type X,SearchTree T)</span><span class="comment">//相当于creat,再不断的input同时，creat Tree;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)<span class="comment">//建立一个二叉树,若无树，应先运用MakeEmpty例程</span></span><br><span class="line">&#123;</span><br><span class="line">T=(SearchTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OUT OF SPACE\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T-&gt;Element=X;</span><br><span class="line">T-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&lt;T-&gt;Element)</span><br><span class="line">&#123;</span><br><span class="line">T-&gt;left=Insert(X,T-&gt;left);<span class="comment">//递归过程中不断遍历至适当的左节点。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&gt;T-&gt;Element)</span><br><span class="line">&#123;</span><br><span class="line">T-&gt;right=Insert(X,T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//此例程并未考虑如果insert的元素已在树中。可以在下面的代码段加入适当内容以补充</span></span><br><span class="line"><span class="comment">//if(X===T-&gt;Element)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//     ;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">return</span> T;<span class="comment">//tree root</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SearchTree <span class="title">Delete</span><span class="params">(Type X,SearchTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*自己画图，如果删除的是树叶，则直接删除，不是树叶，需要考虑</span></span><br><span class="line"><span class="comment">1.有一个儿子的节点.通过更改该节点的父节点的指针，指向该节点的儿子（参考链表绕过被删元素);</span></span><br><span class="line"><span class="comment">2.有两个儿子的节点,用该节点的右子树最小节点代替该节点，删除右子树最小节点.</span></span><br><span class="line"><span class="comment">注意:这里的删除涉及到指针的改变,和空间的释放(free).缺一不可.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Position TmpCell;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"You can't delete a NULL Tree\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&lt;T-&gt;Element)</span><br><span class="line">T-&gt;left=Delete(X,T-&gt;left);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&gt;T-&gt;Element)</span><br><span class="line">T-&gt;right=Delete(X,T-&gt;right);</span><br><span class="line"><span class="comment">//以上两句相当于在遍历整个树以找到元素,一旦找到,执行下面的语句</span></span><br><span class="line"><span class="keyword">else</span><span class="comment">//找到了元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;left &amp;&amp; T-&gt;right)<span class="comment">//if(T-&gt;left!=NULL &amp;&amp; T-&gt;right!=NULL)</span></span><br><span class="line">&#123;</span><br><span class="line">TmpCell=FindMin(T-&gt;right);<span class="comment">//此处FindMin小题大做了，可以直接找right的left,不断遍历left.</span></span><br><span class="line">T-&gt;Element=TmpCell-&gt;Element;</span><br><span class="line">T-&gt;right=Delete(T-&gt;Element,T-&gt;right);<span class="comment">//找到右子数的最小节点(it has only one children)，删除它.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//one children or leaf</span></span><br><span class="line">&#123;</span><br><span class="line">TmpCell=T;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line">T=T-&gt;right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">T=T-&gt;left;</span><br><span class="line"><span class="built_in">free</span>(TmpCell);</span><br><span class="line"><span class="comment">//若left,right有其一,则T被其取代,否则直接freeT(Tmpcell).</span></span><br><span class="line"><span class="comment">//这是一个包含例程，它能同时处理one children和leaf的情况!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若采用懒惰删除,则用bool turn域给每个元素加一个标记,依据标记进行遍历，符合的输出/遍历，不符合的不输出/遍历 .</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉查找树只是一种结构,它并不完美,如果有一些不好的输入,会产生一些很差的二叉树(一边深一边浅)但它是树的一个基本构架.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SearchTree T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">T=Insert(n,T);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Max;</span><br><span class="line"><span class="keyword">int</span> Min;</span><br><span class="line">SearchTree tmp;</span><br><span class="line">tmp=FindMax(T);</span><br><span class="line">Max=tmp-&gt;Element;</span><br><span class="line">tmp=FindMin(T);</span><br><span class="line">Min=tmp-&gt;Element;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Max=%d Min=%d\n"</span>,Max,Min);</span><br><span class="line">T=Delete(Max,T);</span><br><span class="line">tmp=FindMax(T);</span><br><span class="line">Max=tmp-&gt;Element;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Max=%d Min=%d\n"</span>,Max,Min);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入输出检测</span></span><br><span class="line"><span class="comment">3 1 2 5 4</span></span><br><span class="line"><span class="comment">Max=5 Min=1</span></span><br><span class="line"><span class="comment">Max=4 Min=1</span></span><br><span class="line"><span class="comment">Press any key to continue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//二叉AVL查找树</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"malloc.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span> *<span class="title">AvlTree</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//AvlTree means find a root plus,Position means return a plus in position.</span></span><br><span class="line"><span class="function">AvlTree <span class="title">MakeEmpty</span><span class="params">(AvlTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X,AvlTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(AvlTree T)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(AvlTree T)</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">Insert</span><span class="params">(ElementType X,AvlTree T)</span></span>;</span><br><span class="line"><span class="function">AvlTree <span class="title">Delete</span><span class="params">(ElementType X,AvlTree T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fuction</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(Position P)</span></span>;<span class="comment">//return plus's height to balance the tree</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Rotate</span></span><br><span class="line"><span class="function">Position <span class="title">SingleRotateWithLeft</span><span class="params">(Position P)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">SingleRotateWithRight</span><span class="params">(Position P)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">DoubleRotateWithLeft</span><span class="params">(Position P)</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">DoubleRotateWithRight</span><span class="params">(Position P)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AvlNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ElementType Element;</span><br><span class="line">AvlTree left;</span><br><span class="line">AvlTree right;</span><br><span class="line"><span class="keyword">int</span> height;<span class="comment">//how much meter?laugh~~</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Height</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(P==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> P-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=y)</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">Insert</span><span class="params">(ElementType X,AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">T=(AvlTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AvlNode));</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"OUT OF SPACE!\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">T-&gt;Element=X;</span><br><span class="line">T-&gt;height=<span class="number">0</span>;</span><br><span class="line">T-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&lt;T-&gt;Element)</span><br><span class="line">&#123;</span><br><span class="line">T-&gt;left=Insert(X,T-&gt;left);</span><br><span class="line"><span class="keyword">if</span>(Height(T-&gt;left)-Height(T-&gt;right)==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(X&lt;T-&gt;left-&gt;Element)</span><br><span class="line">T=SingleRotateWithLeft(T);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">T=DoubleRotateWithLeft(T);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&gt;T-&gt;Element)</span><br><span class="line">&#123;</span><br><span class="line">T-&gt;right=Insert(X,T-&gt;right);</span><br><span class="line"><span class="keyword">if</span>(Height(T-&gt;right)-Height(T-&gt;left)==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(X&gt;T-&gt;right-&gt;Element)</span><br><span class="line">T=SingleRotateWithRight(T);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">T=DoubleRotateWithRight(T);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//there not x==Element phonemeon</span></span><br><span class="line">T-&gt;height=Max(Height(T-&gt;left),Height(T-&gt;right))+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">SingleRotateWithLeft</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Position tmp;</span><br><span class="line">tmp=P-&gt;left;</span><br><span class="line">P-&gt;left=tmp-&gt;right;</span><br><span class="line">tmp-&gt;right=P;</span><br><span class="line">P-&gt;height=Max(Height(P-&gt;left),Height(P-&gt;right))+<span class="number">1</span>;</span><br><span class="line">tmp-&gt;height=Max(Height(tmp-&gt;left),Height(tmp-&gt;right))+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">SingleRotateWithRight</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Position tmp;</span><br><span class="line">tmp=P-&gt;right;</span><br><span class="line">P-&gt;right=tmp-&gt;left;</span><br><span class="line">tmp-&gt;left=P;</span><br><span class="line">P-&gt;height=Max(Height(P-&gt;left),Height(P-&gt;right))+<span class="number">1</span>;</span><br><span class="line">tmp-&gt;height=Max(Height(tmp-&gt;left),Height(tmp-&gt;right))+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">DoubleRotateWithLeft</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">P-&gt;left=SingleRotateWithRight(P-&gt;left);</span><br><span class="line"><span class="keyword">return</span> SingleRotateWithLeft(P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">DoubleRotateWithRight</span><span class="params">(Position P)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">P-&gt;right=SingleRotateWithLeft(P-&gt;right);</span><br><span class="line"><span class="keyword">return</span> SingleRotateWithRight(P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(ElementType X,AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&lt;T-&gt;Element)</span><br><span class="line"><span class="keyword">return</span> Find(X,T-&gt;left);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&gt;T-&gt;Element)</span><br><span class="line"><span class="keyword">return</span> Find(X,T-&gt;right);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FindMin(T-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FindMax(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AvlTree <span class="title">Delete</span><span class="params">(ElementType X,AvlTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Position TmpCell;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"You can't delete a NULL Tree\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&lt;T-&gt;Element)</span><br><span class="line">T-&gt;left=Delete(X,T-&gt;left);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(X&gt;T-&gt;Element)</span><br><span class="line">T-&gt;right=Delete(X,T-&gt;right);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;left &amp;&amp; T-&gt;right)</span><br><span class="line">&#123;</span><br><span class="line">TmpCell=FindMin(T-&gt;right);</span><br><span class="line">T-&gt;Element=TmpCell-&gt;Element;</span><br><span class="line">T-&gt;right=Delete(T-&gt;Element,T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">TmpCell=T;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line">T=T-&gt;right;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(T-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">T=T-&gt;left;</span><br><span class="line"><span class="built_in">free</span>(TmpCell);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AvlTree T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">T=Insert(n,T);</span><br><span class="line">&#125;</span><br><span class="line">Position tmp;</span><br><span class="line"><span class="keyword">int</span> max;</span><br><span class="line"><span class="keyword">int</span> min;</span><br><span class="line">tmp=FindMax(T);</span><br><span class="line">max=tmp-&gt;Element;</span><br><span class="line">tmp=FindMin(T);</span><br><span class="line">min=tmp-&gt;Element;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Max=%d Min=%d\n"</span>,max,min);</span><br><span class="line">tmp=Delete(max,T);</span><br><span class="line">max=FindMax(tmp)-&gt;Element;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Max=%d Min=%d\n"</span>,max,min);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">示例输入</span></span><br><span class="line"><span class="comment">INPUT</span></span><br><span class="line"><span class="comment">3 1 2 4 5</span></span><br><span class="line"><span class="comment">OUTPUT</span></span><br><span class="line"><span class="comment">Max=5 Min=1</span></span><br><span class="line"><span class="comment">Max=4 Min=1</span></span><br><span class="line"><span class="comment">Press any key to continue</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c, acm" scheme="sherry0429.github.io/tags/c-acm/"/>
    
  </entry>
  
  <entry>
    <title>队列例程</title>
    <link href="sherry0429.github.io/2018/02/11/%E9%98%9F%E5%88%97%E4%BE%8B%E7%A8%8B/"/>
    <id>sherry0429.github.io/2018/02/11/队列例程/</id>
    <published>2018-02-11T06:47:36.000Z</published>
    <updated>2018-02-11T09:06:45.559Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Element int</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueRecord</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueRecord</span> *<span class="title">Queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Isfull</span><span class="params">(Queue Q)</span></span>;</span><br><span class="line"><span class="function">Queue <span class="title">creat</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisposeQueue</span><span class="params">(Queue Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">(Queue Q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(Element X,Queue Q)</span></span>;<span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(Queue Q)</span></span>;<span class="comment">//出队</span></span><br><span class="line"><span class="function">Element <span class="title">ReturnQueue</span><span class="params">(Queue Q)</span></span>;<span class="comment">//返回队首元素</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Minsize (5)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueRecord</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> capacity;<span class="comment">//上限，可由Maxsize输入控制，或利用define.</span></span><br><span class="line"><span class="keyword">int</span> front;<span class="comment">//队首</span></span><br><span class="line"><span class="keyword">int</span> rear;<span class="comment">//队尾</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">Element *Array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Queue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Q-&gt;size==<span class="number">0</span>;<span class="comment">//if Q-&gt;size==0, return it</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(Queue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;size==Q-&gt;capacity)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Queue <span class="title">creat</span><span class="params">(<span class="keyword">int</span> Maxsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue Q;</span><br><span class="line">Q=(Queue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct QueueRecord));</span><br><span class="line">MakeEmpty(Q);</span><br><span class="line">Q-&gt;capacity=Maxsize;</span><br><span class="line">Q-&gt;Array=(Element*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Element)*Maxsize);</span><br><span class="line"><span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisposeQueue</span><span class="params">(Queue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!IsEmpty(Q))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(Q-&gt;Array);</span><br><span class="line"><span class="built_in">free</span>(Q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">(Queue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q-&gt;size=<span class="number">0</span>;</span><br><span class="line">Q-&gt;front=<span class="number">1</span>;</span><br><span class="line">Q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Succ</span><span class="params">(<span class="keyword">int</span> Value,Queue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Value==Q-&gt;capacity)<span class="comment">//若队尾过界，重新置为0，进行入队</span></span><br><span class="line">Value=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Value++;</span><br><span class="line"><span class="keyword">return</span> Value;<span class="comment">//上一个if条件句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(Element X,Queue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(IsFull(Q)==<span class="number">0</span>)<span class="comment">//若队列满(若循环队列，此行需改变)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Queue has been full!\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;size++;</span><br><span class="line">Q-&gt;rear=Succ(Q-&gt;rear,Q);<span class="comment">//并非构建循环队列 只是为了防止rear或front超出数组范围</span></span><br><span class="line">Q-&gt;Array[Q-&gt;rear]=X;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeQueue</span><span class="params">(Queue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(IsFull(Q)==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Queue has been full!\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;size--;</span><br><span class="line">Q-&gt;front=Succ(Q-&gt;front,Q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Element <span class="title">ReturnQueue</span><span class="params">(Queue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> Q-&gt;Array[Q-&gt;front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Queue Q;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">Q=creat(n);</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line">EnQueue(<span class="number">3</span>,Q);</span><br><span class="line">EnQueue(<span class="number">4</span>,Q);</span><br><span class="line">temp=ReturnQueue(Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp);</span><br><span class="line">DeQueue(Q);</span><br><span class="line">temp=ReturnQueue(Q);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">c</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="code_template" scheme="sherry0429.github.io/categories/code-template/"/>
    
    
      <category term="c, queue" scheme="sherry0429.github.io/tags/c-queue/"/>
    
  </entry>
  
  <entry>
    <title>栈例程</title>
    <link href="sherry0429.github.io/2018/02/11/%E6%A0%88%E4%BE%8B%E7%A8%8B/"/>
    <id>sherry0429.github.io/2018/02/11/栈例程/</id>
    <published>2018-02-11T06:45:19.000Z</published>
    <updated>2018-02-11T09:06:21.937Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt CSDN 博客搬家--><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Element int</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackRecord</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackRecord</span> *<span class="title">Stack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(Stack S)</span></span>;</span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">(<span class="keyword">int</span> MaxElements)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisposeStack</span><span class="params">(Stack S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">(Stack S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Element X,Stack S)</span></span>;</span><br><span class="line"><span class="function">Element <span class="title">Top</span><span class="params">(Stack S)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(Stack S)</span></span>;</span><br><span class="line"><span class="function">Element <span class="title">TopandPop</span><span class="params">(Stack S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EmptyTOS (-1)<span class="comment">//栈顶数值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MinStackSize (5)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackRecord</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> Capacity;<span class="comment">//容量</span></span><br><span class="line"><span class="keyword">int</span> TopOfStack;</span><br><span class="line">Element *Array;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">(<span class="keyword">int</span> MaxElements)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack S;</span><br><span class="line"><span class="keyword">if</span>(MaxElements&lt;MinStackSize)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This Stack is too small!\n"</span>);</span><br><span class="line">S=(Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct StackRecord));</span><br><span class="line"><span class="keyword">if</span>(S==<span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Out of Space!\n"</span>);</span><br><span class="line">S-&gt;Array=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Element)*MaxElements);</span><br><span class="line"><span class="keyword">if</span>(S-&gt;Array==<span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Out of Space!\n"</span>);</span><br><span class="line">S-&gt;Capacity=MaxElements;</span><br><span class="line">MakeEmpty(S);</span><br><span class="line"><span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">S-&gt;TopOfStack=EmptyTOS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisposeStack</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(S-&gt;Array);</span><br><span class="line"><span class="built_in">free</span>(S);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S-&gt;Capacity==S-&gt;TopOfStack)<span class="comment">//-1增至Capacity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stack is Full\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(Stack S)</span><span class="comment">//测试栈是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> S-&gt;TopOfStack==EmptyTOS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(Element X,Stack S)</span><span class="comment">//进栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(IsFull(S))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Stack is Full"</span>);<span class="comment">//栈满</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">S-&gt;Array[++S-&gt;TopOfStack]=X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Element <span class="title">Top</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!IsEmpty(S))</span><br><span class="line"><span class="keyword">return</span> S-&gt;Array[S-&gt;TopOfStack];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The Stack has been Empty!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!IsEmpty(S))</span><br><span class="line">S-&gt;TopOfStack--;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The Stack has been Empty!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Element <span class="title">TopandPop</span><span class="params">(Stack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!IsEmpty(S))<span class="comment">//非空</span></span><br><span class="line"><span class="keyword">return</span> S-&gt;Array[S-&gt;TopOfStack--];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The Stack has been Empty!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack S;</span><br><span class="line">S=CreateStack(<span class="number">10</span>);</span><br><span class="line">Element x;</span><br><span class="line"><span class="keyword">while</span>(getchar()!=<span class="string">'\n'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">Push(x,S);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,S-&gt;TopOfStack+<span class="number">2</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">Pop(S);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">a=Top(S);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- excerpt CSDN 博客搬家--&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
      <category term="Code_Template" scheme="sherry0429.github.io/categories/Code-Template/"/>
    
    
      <category term="stack, c" scheme="sherry0429.github.io/tags/stack-c/"/>
    
  </entry>
  
</feed>
