<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Monster &amp; Flower</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="sherry0429.github.io/"/>
  <updated>2018-02-26T02:34:07.391Z</updated>
  <id>sherry0429.github.io/</id>
  
  <author>
    <name>Tianyou Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>比特币与区块链</title>
    <link href="sherry0429.github.io/2018/02/26/%E6%AF%94%E7%89%B9%E5%B8%81%E4%B8%8E%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>sherry0429.github.io/2018/02/26/比特币与区块链/</id>
    <published>2018-02-26T02:12:22.000Z</published>
    <updated>2018-02-26T02:34:07.391Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>原link：<a href="https://www.zhihu.com/question/37290469/answer/107612456" target="_blank" rel="noopener">区块链是什么，如何简单易懂地介绍区块链？ - 汪乐-LaiW3n</a></p><p>以下转载原文：</p><hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>事情是这样的，最近我的室友Hasaki一直在问我区块链和比特币的事情，我尝试了很多种不通的姿势以求简单通俗形象生动地跟他解释什么是区块链技术，但是最后都失败了。因此我萌生了要写一篇BlockChain for Babies（又名：如何向你的弱智室友解释区块链）的想法，以求能简单直观生动形象地向对区块链技术不了解但是想知道区块链是什么的人介绍区块链技术或者比特币。</p><p>因为面向的读者是不想知道具体技术实现只想了解区块链的人群，因此本文避开了一些底层和算法细节，采用比较主观的方式来展示笔者对区块链技术的感性认识。<strong>如果你只是对区块链感兴趣，并没有深入学习的打算，或者只是想像我一样在别人问起来的时候装逼，本文应该是一篇很好的“导论”。</strong></p><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>区块链本质上是一个去中心化的分布式账本数据库（感谢</p><p><a href="http://www.zhihu.com/people/12bb0cb39453cc3827ea122146cedaa9" target="_blank" rel="noopener">@程剑宇</a></p><p>这是区块链的定义，因此要逐步了解区块链，我们需要一步步了解如下东西。</p><h2 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h2><h2 id="先来考虑一个中心化集中式处理的过程。你要在某宝上买一部手机，交易流程是：你将钱打给支付宝－支付宝收款后通知卖家发货－卖家发货－你确认收货－支付宝把钱打给卖家。"><a href="#先来考虑一个中心化集中式处理的过程。你要在某宝上买一部手机，交易流程是：你将钱打给支付宝－支付宝收款后通知卖家发货－卖家发货－你确认收货－支付宝把钱打给卖家。" class="headerlink" title="先来考虑一个中心化集中式处理的过程。你要在某宝上买一部手机，交易流程是：你将钱打给支付宝－支付宝收款后通知卖家发货－卖家发货－你确认收货－支付宝把钱打给卖家。"></a>先来考虑一个中心化集中式处理的过程。你要在某宝上买一部手机，交易流程是：你将钱打给支付宝－支付宝收款后通知卖家发货－卖家发货－你确认收货－支付宝把钱打给卖家。</h2><p><img src="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/BitCoin-Block-2018-02-26-1.jpg" alt="BitCoin-Block-2018-02-26-1"></p><p>在这个过程中，虽然你是在和卖家交易，但是这笔交易还牵扯到了除了你和卖家的第三方，即支付宝，你和卖家的交易都是围绕支付宝展开。因此，如果支付宝系统出了问题便会造成这笔交易的失败。并且虽然你只是简单的买了一个手机，但是你和卖家都要向第三方提供多余的信息。因此考虑极端情况，如果支付宝跑路了或者是拿了钱不却不承认你的交易或者是支付宝所在的城市因为开G20把所有人都赶走了(?)，那么你就悲剧了。</p><p>而去中心化的处理方式就要显得简单很多，你只需要和卖家交换钱和手机，然后双方都声称完成了这笔交易，就OK了。</p><p>可以看出在某些特定情况下，去中心化的处理方式会更便捷，同时也无须担心自己的与交易无关的信息泄漏。</p><p>其实如果只考虑两个人的交易并不能把去中心化的好处完全展示出来，设想如果有成千上万笔交易在进行，去中心化的处理方式会节约很多资源，使得整个交易自主化、简单化，并且排除了被中心化代理控制的风险。</p><p>去中心化是区块链技术的颠覆性特点，它无需中心化代理，实现了一种点对点的直接交互，使得高效率、大规模、无中心化代理的信息交互方式成为了现实。</p><p>当然，上述的例子有一个很大的潜在问题：没有了权威的中心化代理，怎样保证每笔交易的准确性和有效性呢？比如：如果没有了权威的中心化代理，张三某一天借了我100块钱，但是不还钱还不承认怎么办？这里就引出了区块链的其它特性。</p><h2 id="两个基础难题"><a href="#两个基础难题" class="headerlink" title="两个基础难题"></a>两个基础难题</h2><p>在去中心化以后，整个系统中没有了权威的中心化代理，信息的可信度和准确性便会面临问题。</p><p>问题1：类两军问题</p><p>第一次听说这个问题居然是在TCP的课上，大致说的是有两个相距很远的军队要传递信息，红军派遣一个信使去跟蓝军说：“你他娘的把意大利炮拿出来！”。蓝军收到信息后又派了一个信使去红军说：“收到指令！”。然后红军又派一个信使去蓝军说：“知道你收到指令了！”。然后蓝军又派一个信使去红军说：“知道你知道我收到指令了！”。然后红军又派一个信使去蓝军说：“知道你知道我知道你收到指令了！”……然后就没完没了了。</p><p><img src="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/BitCoin-Block-2018-02-26-2.jpg" alt="BitCoin-Block-2018-02-26-1"></p><p>在这种情况下，因为是点对点的通信，双方不可能在这种情况下达到信息的一致性。严谨一点，就是“在分布式计算上，试图在异步系统和不可靠的通道上达到一致性是不可能的”。</p><p>问题2：拜占庭将军问题</p><p>拜占庭罗马帝国在军事行动中，采取将军投票的策略来决定是进攻还是撤退，也就是说如果多数人决定进攻，就上去干。但是军队中如果有奸细（比如将军已经反水故意乱投票，或者传令官叛变擅自修改军令），那怎么保证最后投票的结果真正反映了忠诚的将军的意愿呢？</p><p>拜占庭将军问题反映到信息交换领域中来，可以理解为在一个去中心的系统中，有一些节点是坏掉的，它们可能向外界广播错误的信息或者不广播信息，在这种情况下如何验证数据传输的准确性。</p><p><strong>区块链技术的诞生</strong></p><p>现在让我们来一步一步在去中心化的系统中解决这些问题，见证区块链技术雏形的诞生。</p><p>1</p><p>我们先来建立一个去中心化的系统，为了方便理解，我们来看一个简单的去中心化借贷模型：如果A借了B 100块钱，这个时候，A在人群中大喊“我是A，我借给了B 100块钱！”，B也在人群中大喊“我是B，A借给了我100块钱！”，此时路人甲乙丙丁都听到了这些消息，因此所有人都在心中默默记下了“A借给了B100块钱”。你看，这个时候一个去中心化的系统就建立起来了，这个系统中不需要银行，也不需要借贷协议和收据，严格来说，甚至不需要人与人长久的信任关系（比如B突然又改口说“我不欠A钱！”，这个时候人民群众就会站出来说“不对，我的小本本上记录了你某天借了A100块钱！”）。</p><p><img src="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/BitCoin-Block-2018-02-26-3.jpg" alt="BitCoin-Block-2018-02-26-1"></p><p>可能你已经发现了，在上述的模型中，所谓的“100块钱”已经不重要了。换句话说，任何东西都可以在这个模型中交换，甚至你可以凭空杜撰一个东西，只要大家承认，你就可以让你杜撰的东西流通。比如：我在人群中高喊一声“我创造了10个查克拉！”，我甚至不需要知道查克拉是什么，也不需要关心世界上是不是真的有查克拉，只要大家都听到，然后在自己的小本本上记下“LaiW3n有10个查克拉”，于是我就真的有100个查克拉了。从此以后，我便可以声称我给了某人1个查克拉，只要路人甲乙丙丁都收到并且承认了这一信息，那我就算完成了这次交易，哪怕世界上没有查克拉。</p><p>你现在脑海中是不是浮现出了三个字——“比特币”？由于真正的区块链和比特币比我上述的模型复杂太多，细节也丰富太多，因此以下还是以查克拉举例，毕竟本文是Blockchain for Babies.（笑）</p><p>假设过了很长一段时间，我凭空创造的查克拉已经在这个系统中流通了起来，大家都开始认可了查克拉。但是这个系统中一共就只有10个查克拉，于是有人动了坏心思，他在人群中高呼“我有10个查克拉！”怎么办？大家是直接在本本上记下他有10个查克拉么，这样不是人人都可以伪造查克拉了么？</p><p>为了防止这种现象发生，我决定在我创造查克拉的时候给我的查克拉打上标记（更准确地说，我是给我喊的那句“我创造了10个查克拉”打上标记，比如标记为001），这样以后在每一笔交易的时候，我在高喊“我给了某某1个查克拉！”的时候，会附加上额外的一句话：“这1个查克拉的来源是记为001的那条记录，我的这句话标记为002！”。我们再抽象一点，某人喊话的内容的格式就变成了：“这句话编号xxx，上一句话的编号是yyy，我给了某某1个查克拉！”，这样就解决了伪造的问题。其实上述模型就变成一个简化的中本聪第一版比特币区块链协议：</p><p><img src="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/BitCoin-Block-2018-02-26-4.jpg" alt="BitCoin-Block-2018-02-26-1"></p><p>好了，看到这里你基本已经能够生动形象又不涉及任何细节地向你的弱智室友解释区块链了。但是也许你的室友是一个有打破沙锅问到底精神求是学子，因此你最好继续准好回答以下这几个问题。</p><h3 id="1-“凭啥？”"><a href="#1-“凭啥？”" class="headerlink" title="1. “凭啥？”"></a>1. “凭啥？”</h3><p>你室友可能会问：“凭啥你喊一句话我就帮你记？我的小本本不要钱么？”。为了激励大家帮我传话和记账，我决定给第一个听到我喊话并且记录在小本本上的人一些奖励：第一个听到我喊话并记录下来的人，你就凭空得到了1个查克拉，这个查克拉是整个系统对你幸苦记账的报酬，而你记录了这句话之后，要马上告诉其它人你已经记录好了，让别人放弃继续记录这句话，并给你自己的记录编号让别人有据可查，然后你再把我的话加上你的记录编号一起喊出来，供下一个人记账。</p><p>当这个规则定下以后，这个系统中一定会出现一批人，他们开始竖着耳朵监听周围发出的声音，以抢占第一个记账的权利。对的，你脑海中是不是又浮现出了“比特币挖矿”的字眼？</p><p>值得一提的是，关于比特币挖矿， </p><p><a href="http://www.zhihu.com/people/39e1a1e41b3903f9283e13d11a39bbfd" target="_blank" rel="noopener">@玲珑邪僧</a></p><blockquote><p>单身汪们要找女票，国民岳母说我有好多女儿，这样吧我给你们出点题目，解出一个就给其中一个姑娘的微信号。</p><p>单身汪们疯狂竞争，想破脑袋去解题。只要其中一只汪解出一道题，就立马得意洋洋地昭告天下，示威全部单身汪，这个姑娘是我的啦，你们放弃吧。其他单身汪们即使不服也没有办法，惆怅懊恼也不是个事儿啊，还是麻溜地立马去解下一道题目吧。这只喜赢姑娘的幸运小汪被岳母认可后还能得到25个货币单位的彩礼，简直人生赢家。</p></blockquote><h3 id="2-“听谁的？”"><a href="#2-“听谁的？”" class="headerlink" title="2. “听谁的？”"></a>2. “听谁的？”</h3><p>在这个系统中，如果我和另一个人C几乎同时地喊出一句：“为了艾泽拉斯！”。由于听众所处的位置不同，一定会有人先听到我说的那句话，而另外一些人则先听到C的那句话，如果我们规定只能有一个人说出这句话，那到底这句话是谁说的？</p><p>如果不加任何条件，那么上述的情况一定会这样发展：一部分人认为这句话是我说的，在听到这句话之后开始记账，之后他们所做的所有事情都是基于这个事实，并且随着这个信息一次次的传下去，这条信息链会越来越深；而另外一群认为是C先说这句话的人，也会按照这样的趋势发展。这样，原本是一条唯一的信息链，在我们喊出“为了艾泽拉斯”这句话之后，分叉了！？</p><p><img src="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/BitCoin-Block-2018-02-26-5.jpg" alt="BitCoin-Block-2018-02-26-1"></p><p>图5：“区块链”分叉</p><p>这会导致怎样的情况呢？按照我们的设想，应该每个人的小本本上记录的东西都是一样的，都是一条可以把所有信息串联起来的链条。但是在这一刻，他们小本本上记录的东西不一样了！这还玩毛啊？以后还怎么确定交易和信息的真实性！？</p><p>为了解决这个问题，我又追加了新的规则：每个人在记录小本本的时候，需要脱鞋然后用脚拿笔，在小本本上用正楷体书写！有了这个规定，由于用脚写字难度很大，每个人至少需要10分钟才能写完，而且由于每个人用脚写字的熟练度不通，写完这句话所用的时间也不同，因此一定会有人先写完然后高呼“我写完了！那句话是LaiW3n喊的！”，这样其它正在写这句话的人便会停笔，然后在小本本上重新开始写“那句话是来文写的，上一句的编号是xxx”。</p><p>如果你对上述我的解决方法感兴趣，你可以对照我上面的比喻去了解以下知识：</p><p>“听谁的”——中本聪破解“拜占庭将军问题”的算法</p><p>“在小本本上记录”——比特币挖矿</p><p>“脱鞋用脚写字”——比特币挖矿难度</p><p>“脱鞋写字速度”——算力</p><p>“新的规则”——工作量证明链</p><h3 id="3-“双花”问题"><a href="#3-“双花”问题" class="headerlink" title="3. “双花”问题"></a>3. “双花”问题</h3><p>这个时候你的室友可能又要问：如果我同时宣布我给了A一个查克拉和我给了B一个查克拉，但是我只有一个查克拉，那咋整？是A和B都收到了查克拉还是咋地？</p><p>这个时候你只需要托起他的下巴，温柔地看着他的眼睛，用手刮刮他的鼻子，说：“小妖精，你把这种情况带到上面的规则中去试试？”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注明：这是一篇转载文章，感谢原创作者&lt;/p&gt;
&lt;p&gt;原link：&lt;a href=&quot;https://www.zhihu.com/question/37290469/answer/107612456&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;区块链是什么，如何简单易懂地介绍区块链？ - 汪乐-LaiW3n&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前比特币和区块链貌似有点火，研究一波，这里贴一篇知乎上的链接，记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Reprint" scheme="sherry0429.github.io/categories/Reprint/"/>
    
    
      <category term="BitCoin" scheme="sherry0429.github.io/tags/BitCoin/"/>
    
  </entry>
  
  <entry>
    <title>如何便捷的在Hexo博客中插入图片</title>
    <link href="sherry0429.github.io/2018/02/25/%E5%A6%82%E4%BD%95%E4%BE%BF%E6%8D%B7%E7%9A%84%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>sherry0429.github.io/2018/02/25/如何便捷的在博客中插入图片/</id>
    <published>2018-02-25T07:37:06.000Z</published>
    <updated>2018-02-26T02:01:34.645Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>直接上干货，最好的实现当然是：</p><ul><li>在blog里贴本地link</li><li>hexo g的时候自动转化为oss的link并上传</li><li>hexo g的时候将blog里的local link转化为oss link</li></ul><p>我找了下这方面的插件，因为我用的是腾讯云的OSS，没有找到对应插件，想自己实现，但无奈nodejs太过垃圾。。</p><p>那么是不是就没有办法呢，倒也不是。</p><p>经过我的思考，我决定这样做：</p><ul><li>在Typora里直接放入本地图片，观察效果</li><li>开启Typora的“插入图片时使用相对路径功能”</li><li>开启Typora的“插入图片时拷贝到指定文件夹”功能</li><li>写一个python脚本，将指定文件夹的图片全部上传至OSS</li></ul><p>实际使用时，则这样：</p><ul><li>写博客，插入图片（本地），观察效果</li><li>跑一遍python脚本</li><li>全文替换博客中所有图片的前缀为OSS前缀</li><li>部署</li></ul><p>下面两张图，就是用这种方式上传的图片</p><p><img src="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/upload_oss_step_1.jpg" alt="upload_oss_step_1"></p><p><img src="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/upload_oss_step_2.jpg" alt="upload_oss_step_2"></p><p>关于python脚本的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Copyright (C) 2017 tianyou pan &lt;sherry0429 at SOAPython&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> qcloud_cos <span class="keyword">import</span> CosConfig</span><br><span class="line"><span class="keyword">from</span> qcloud_cos <span class="keyword">import</span> CosS3Client</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadOSSClass</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    secret_id = <span class="string">''</span>  <span class="comment"># 替换为用户的secret_id</span></span><br><span class="line">    secret_key = <span class="string">''</span>  <span class="comment"># 替换为用户的secret_key</span></span><br><span class="line">    region = <span class="string">''</span>  <span class="comment"># 替换为用户的region</span></span><br><span class="line">    token = <span class="string">''</span>  <span class="comment"># 使用临时秘钥需要传入Token，默认为空,可不填</span></span><br><span class="line">    config = CosConfig(Region=region, Secret_id=secret_id, Secret_key=secret_key, Token=token)  <span class="comment"># 获取配置对象</span></span><br><span class="line">    client = CosS3Client(config)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.redis_c = redis.StrictRedis(<span class="string">"localhost"</span>, <span class="number">6379</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">upload_img</span><span class="params">(self, file_name)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(file_name, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            response = self.client.put_object(</span><br><span class="line">                Bucket=<span class="string">''</span>,  <span class="comment"># Bucket由bucketname-appid组成</span></span><br><span class="line">                Body=fp,</span><br><span class="line">                Key=file_name,</span><br><span class="line">                StorageClass=<span class="string">'STANDARD'</span>,</span><br><span class="line">                CacheControl=<span class="string">'no-cache'</span>,</span><br><span class="line">                ContentDisposition=<span class="string">'download.txt'</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">if</span> response[<span class="string">'ETag'</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"upload success : "</span>,</span><br><span class="line">            <span class="keyword">print</span> response[<span class="string">'ETag'</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"upload failed"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_cache</span><span class="params">(self, img_path)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.redis_c.sadd(<span class="string">'blog-img'</span>, img_path)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">"."</span>):</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">                img_path = os.path.join(root, name)</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"upload : "</span> + img_path)</span><br><span class="line">                <span class="keyword">if</span> self.make_cache(img_path):</span><br><span class="line">                    self.upload_img(name)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"upload done"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    upload_c = UploadOSSClass()</span><br><span class="line">    upload_c.start()</span><br></pre></td></tr></table></figure><p>自行添加对应字段。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo部署，如果使用GitPages，不得不面对上传图片过多时超过github.io库限制的问题，而使用OSS，又需要先上传到OSS，再在blog里引用链接，&lt;/p&gt;
&lt;p&gt;有没有一种办法，写博客时插入图片，所见即所得，部署后，博客也自动采用OSS上的链接呢？&lt;/p&gt;
&lt;p&gt;这里提供一种思路和实现&lt;/p&gt;
    
    </summary>
    
      <category term="knowledge" scheme="sherry0429.github.io/categories/knowledge/"/>
    
    
      <category term="hexo" scheme="sherry0429.github.io/tags/hexo/"/>
    
      <category term="python" scheme="sherry0429.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>快速开发scrapy爬虫(二)</title>
    <link href="sherry0429.github.io/2018/02/25/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91scrapy%E7%88%AC%E8%99%AB-%E4%BA%8C/"/>
    <id>sherry0429.github.io/2018/02/25/快速开发scrapy爬虫-二/</id>
    <published>2018-02-25T07:19:43.000Z</published>
    <updated>2018-02-26T02:01:14.286Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>首先我们回顾一下上一节说过的爬虫步骤：</p><ul><li>找出需求中属于静态网页数据（即查看网页源码就能获取的内容）</li><li>找出需求中属于动态加载的数据（通过Chrome开发者工具的NetWork面板）</li><li>判断爬虫实现难度（主要在动态加载部分上，如果动态加载部分的请求URL过于难拼，考虑放弃该字段，没办法放弃就硬啃吧，做好心理准备和工期规划）</li><li>构造静态网页数据的爬取规则</li><li>构造动态加载数据的请求URL</li><li>实现爬虫</li></ul><p>上一节，我们走完了前4个步骤，这篇文章主要讲如何实现第五个步骤。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先通过chrome的开发者工具，NETWORK面板搜XHR请求，可以发现在加载商品详情页时有如下请求：</p><p><a href="https://www.amazon.cn/gp/product-description/ajaxGetProuductDescription.html?ref_=dp_apl_pc_loaddesc&amp;asin=B002WC7NGS&amp;cacheTime=1519547354719&amp;merchantId=A1AJ19PSB66TGU&amp;deviceType=web" target="_blank" rel="noopener">https://www.amazon.cn/gp/product-description/ajaxGetProuductDescription.html?ref_=dp_apl_pc_loaddesc&amp;asin=B002WC7NGS&amp;cacheTime=1519547354719&amp;merchantId=A1AJ19PSB66TGU&amp;deviceType=web</a></p><p>分析可知它需要如下几个参数：</p><ol><li>asin</li><li>cacheTime</li><li>merchantId</li><li>deviceType</li></ol><p>asin和merchantId通过爬取获得，cacheTime通过unix时间戳获得，deviceType固定为Web.</p><p>上一节我们的代码是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_0</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    info(<span class="string">'Parse 0 '</span>+response.url)</span><br><span class="line">    item = self.parse_with_rules(response, self.css_rules, dict)</span><br><span class="line">    <span class="keyword">if</span> isinstance(item, dict):</span><br><span class="line">        <span class="keyword">yield</span> item</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data_dict = dict()</span><br><span class="line">        data_dict[<span class="string">'data'</span>] = item</span><br><span class="line">        <span class="keyword">yield</span> data_dict</span><br></pre></td></tr></table></figure><p>现在只需要略微修改爬取规则，然后在item返回之后，取出来所需参数，拼接成一个URL。再发起请求和对应的css规则，在新的method里面进行解析即可。</p><p>还记得上一节，使用css selector的时候不知道如何选择标签内的属性值，在这一节，我使用了先通过css selector获取html标签，再通过正则获取属性的方式。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>首先是新的css规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">css_rules = &#123;</span><br><span class="line">        <span class="string">"#title"</span>: &#123;</span><br><span class="line">            <span class="string">"title"</span>: <span class="string">"#productTitle::text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"#byline"</span>: &#123;</span><br><span class="line">            <span class="string">"author"</span>: <span class="string">".a-link-normal::text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">".bucket&gt;.content"</span>: &#123;</span><br><span class="line">            <span class="string">"base_info_title"</span>: <span class="string">"li&gt;b::text"</span>,</span><br><span class="line">            <span class="string">"base_info_content"</span>: <span class="string">"li::text"</span>,</span><br><span class="line">            <span class="string">"average_star"</span>: <span class="string">".a-icon-alt::text"</span>,</span><br><span class="line">            <span class="string">"sum_comments"</span>: <span class="string">".a-link-normal::text"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"#addToCart"</span>:&#123;</span><br><span class="line">            <span class="string">"ASIN"</span>: <span class="string">"#ASIN"</span>,</span><br><span class="line">            <span class="string">"merchantID"</span>: <span class="string">"#merchantID"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">content_css_rules = &#123;</span><br><span class="line">    <span class="string">"#s_contents"</span>:&#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"h3::text"</span>,</span><br><span class="line">        <span class="string">"content"</span>: <span class="string">"p::text"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们在原有规则上添加了#addToCart这个css selector，用于定位ASIN，和merchantID。这两个值爬下来是HTML标签的形式，我们要用正则把它替换为可读形式，再拼接URL发送请求</p><p>下面为关键代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_0</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    info(<span class="string">'Parse 0 '</span>+response.url)</span><br><span class="line">    items = self.parse_with_rules(response, self.css_rules, dict)</span><br><span class="line">    <span class="keyword">if</span> isinstance(items, dict):</span><br><span class="line">        <span class="keyword">yield</span> items</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data_dict = dict()</span><br><span class="line">        data_dict[<span class="string">'data'</span>] = items</span><br><span class="line">        <span class="keyword">yield</span> data_dict</span><br><span class="line">    asin = <span class="string">''</span></span><br><span class="line">    merchant = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> base_data <span class="keyword">in</span> items:</span><br><span class="line">        need_params = base_data[<span class="string">'#addToCart'</span>]</span><br><span class="line">        <span class="keyword">for</span> params <span class="keyword">in</span> need_params:</span><br><span class="line">            asin_html = params[<span class="string">'ASIN'</span>]</span><br><span class="line">            asin = self.get_html_attr(asin_html[<span class="number">0</span>], <span class="string">"value"</span>)</span><br><span class="line">            merchant_html = params[<span class="string">'merchantID'</span>]</span><br><span class="line">            merchant = self.get_html_attr(merchant_html[<span class="number">0</span>], <span class="string">"value"</span>)</span><br><span class="line">    unix_time = str(int(time.time() * <span class="number">1000</span>))</span><br><span class="line">    content_url = <span class="string">"https://www.amazon.cn/gp/product-description/ajaxGetProuductDescription.html?ref_=dp_apl_pc_loaddesc&amp;asin=%s&amp;cacheTime=%s&amp;merchantId=%s&amp;deviceType=web"</span> % (asin[<span class="number">0</span>], unix_time, merchant[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">yield</span> Request(url=content_url, callback=self.parse_1)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_1</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    info(<span class="string">'Parse 1 '</span>+ response.url)</span><br><span class="line">    items = self.parse_with_rules(response, self.content_css_rules, dict)</span><br><span class="line">    <span class="keyword">if</span> isinstance(items, dict):</span><br><span class="line">        <span class="keyword">yield</span> items</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data_dict = dict()</span><br><span class="line">        data_dict[<span class="string">'data'</span>] = items</span><br><span class="line">        <span class="keyword">yield</span> data_dict</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>爬取后的结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"#title"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"title"</span>:[</span><br><span class="line">            <span class="string">"数据结构与算法分析:C语言描述(原书第2版)"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"#addToCart"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"ASIN"</span>:[</span><br><span class="line">            <span class="string">"&lt;input type=\"hidden\" id=\"ASIN\" name=\"ASIN\" value=\"B002WC7NGS\"&gt;"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"merchantID"</span>:[</span><br><span class="line">            <span class="string">"&lt;input type=\"hidden\" id=\"merchantID\" name=\"merchantID\" value=\"A1AJ19PSB66TGU\"&gt;"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"#byline"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"author"</span>:[</span><br><span class="line">            <span class="string">"维斯"</span>,</span><br><span class="line">            <span class="string">"冯舜玺"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">".bucket&gt;.content"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"base_info_title"</span>:[</span><br><span class="line">            <span class="string">"出版社:"</span>,</span><br><span class="line">            <span class="string">"丛书名:"</span>,</span><br><span class="line">            <span class="string">"平装:"</span>,</span><br><span class="line">            <span class="string">"语种："</span>,</span><br><span class="line">            <span class="string">"开本:"</span>,</span><br><span class="line">            <span class="string">"ISBN:"</span>,</span><br><span class="line">            <span class="string">"条形码:"</span>,</span><br><span class="line">            <span class="string">" 商品尺寸: "</span>,</span><br><span class="line">            <span class="string">" 商品重量: "</span>,</span><br><span class="line">            <span class="string">"品牌:"</span>,</span><br><span class="line">            <span class="string">"ASIN: "</span>,</span><br><span class="line">            <span class="string">"用户评分:"</span>,</span><br><span class="line">            <span class="string">"亚马逊热销商品排名:"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"average_star"</span>:[</span><br><span class="line">            <span class="string">"平均 4.2 星"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"base_info_content"</span>:[</span><br><span class="line">            <span class="string">" 机械工业出版社; 第1版 (2004年1月1日)"</span>,</span><br><span class="line">            <span class="string">" "</span>,</span><br><span class="line">            <span class="string">" 391页"</span>,</span><br><span class="line">            <span class="string">" 简体中文"</span>,</span><br><span class="line">            <span class="string">" 16"</span>,</span><br><span class="line">            <span class="string">" 711112748X,</span></span><br><span class="line"><span class="string">             9787111127482"</span>,</span><br><span class="line">            <span class="string">" 9787111127482"</span>,</span><br><span class="line">            <span class="string">" 25.7 x 18.3 x 1.8 cm "</span>,</span><br><span class="line">            <span class="string">" 621 g "</span>,</span><br><span class="line">            <span class="string">" 机械工业出版社"</span>,</span><br><span class="line">            <span class="string">"B002WC7NGS"</span>,</span><br><span class="line">            <span class="string">" 图书商品里排第1,</span></span><br><span class="line"><span class="string">            618名 ("</span>,</span><br><span class="line">            <span class="string">") "</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"sum_comments"</span>:[</span><br><span class="line">            <span class="string">" 236 条商品评论 "</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"#s_contents"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"content"</span>:[</span><br><span class="line">            <span class="string">" 《数据结构与算法分析:C语言描述(原书第2版)》讨论数据结构和算法分析。数据结构主要研究组织大量数据的方法，而算法分析则是对算法运行时间的评估。随着计算机的速度越来越快，对于能够处理大量输入数据的程序的需求变得日益急切。可是，由于在输入量很大的时候，程序的低效率现象变得非常明显，因此这又要求对效率问题给予更仔细的关注。通过在实际编程之前对算法的分析，学生可以决定一个特定的解法是否可行。例如，学生在《数据结构与算法分析:C语言描述(原书第2版)》中将读到一些特定的问题并看到精心的实现方法是如何把对大量数据的时间限制从16年减至不到1秒的。因此，若无运行时间的阐释，就不会有算法和数据结构的提出。"</span>,</span><br><span class="line">            <span class="string">"《数据结构与算法分析:C语言描述(原书第2版)》是国外数据结构与算法分析方在的标准教材，介绍了数据结构（大量数据的组织方法）以及算法分析（算法运行时间的估算）。《数据结构与算法分析:C语言描述(原书第2版)》的编写目标是同时廛授好的程序设计和算法分析技巧，使读者可以开发出具有高效率的程序。"</span>,</span><br><span class="line">            <span class="string">"《数据结构与算法分析:C语言描述(原书第2版)》可作为高级数据结构课程或研究生一年级算法分析课程的教材，使用《数据结构与算法分析:C语言描述(原书第2版)》需具有一些中级程序设计知识，还需要离散数学的一些背景知识。"</span>,</span><br><span class="line">            <span class="string">"随着速度的不断提高和存储容量的持续增长，计算机的功能日益强大，从而处理数据和解决问题的规模和复杂程度与日俱增。这不仅带来了需要认真研究的新课题，而且突出了原有数据结构和算法效率低下的缺点。程序的效率问题不是由于计算机功能的强大而受到冷落，相反地，倒是被人们提到前所未有的重视程度，因为大型问题的解决所涉及到的大容量存储和高速度运算容不得我们对效率有丝毫的忽视。《数据结构与算法分析:C语言描述(原书第2版)》正是在阐述数据结构基本概念的同时深入地分析了算法的效率。 "</span>,</span><br><span class="line">            <span class="string">" 作者：（美国）维斯 译者：冯舜玺"</span>,</span><br><span class="line">            <span class="string">"Mark Allen Weiss是佛罗里达国际大学计算机学院教授，普林斯顿大学计算机科学博士。除本书外，他编写的关于数据结构与算法方面的知名教材还有：Data Structures and Algorithm Analysis：in Java,</span></span><br><span class="line"><span class="string">             Data Structures and Algonthm Analysis：in C++以及Data Structures and Problem Solving：Using Jave、Data Struchures and Problem Solving：Using C++等。他目前是AP考试计算机学科委员会的主席。 "</span>,</span><br><span class="line">            <span class="string">" 出版者的话"</span>,</span><br><span class="line">            <span class="string">"专家指导委员会"</span>,</span><br><span class="line">            <span class="string">"译者序"</span>,</span><br><span class="line">            <span class="string">"前言 "</span>,</span><br><span class="line">            <span class="string">"第1章 引论"</span>,</span><br><span class="line">            <span class="string">"第2章 算法分析"</span>,</span><br><span class="line">            <span class="string">"第3章 表、栈和队列"</span>,</span><br><span class="line">            <span class="string">"第4章 树"</span>,</span><br><span class="line">            <span class="string">"第5章 散列"</span>,</span><br><span class="line">            <span class="string">"第6章 优先队列（堆）"</span>,</span><br><span class="line">            <span class="string">"第7章 排序"</span>,</span><br><span class="line">            <span class="string">"第8章 不相交集AD"</span>,</span><br><span class="line">            <span class="string">"第9章 图论算法"</span>,</span><br><span class="line">            <span class="string">"第10章 算法设计技巧"</span>,</span><br><span class="line">            <span class="string">"第11章 摊还分析"</span>,</span><br><span class="line">            <span class="string">"第12章 高级数据结构及其实现"</span>,</span><br><span class="line">            <span class="string">"索引 "</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"name"</span>:[</span><br><span class="line">            <span class="string">"编辑推荐"</span>,</span><br><span class="line">            <span class="string">"作者简介"</span>,</span><br><span class="line">            <span class="string">"目录"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>值得注意的是，这是两条记录，因此，我们需要在pipeline里面对它进行合并。</p><p>最简单的方式，就是使用Redis，给这些数据一个main<em>key（data-ASIN），</em>把这个main_key作为redis_key，把数据使用hset存入。</p><p>最后，为了减轻被爬取网站的压力，我建议将settings.py中的对应选项改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOAD_DELAY = <span class="number">5</span></span><br><span class="line">CONCURRENT_REQUESTS_PER_DOMAIN = <span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上一篇，这一篇将如何实现爬取动态加载的数据&lt;/p&gt;
    
    </summary>
    
      <category term="knowledge" scheme="sherry0429.github.io/categories/knowledge/"/>
    
    
      <category term="python" scheme="sherry0429.github.io/tags/python/"/>
    
      <category term="spider" scheme="sherry0429.github.io/tags/spider/"/>
    
      <category term="scrapy" scheme="sherry0429.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>hexo部署突然失败的一次解决</title>
    <link href="sherry0429.github.io/2018/02/25/hexo%E9%83%A8%E7%BD%B2%E7%AA%81%E7%84%B6%E5%A4%B1%E8%B4%A5%E7%9A%84%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3/"/>
    <id>sherry0429.github.io/2018/02/25/hexo部署突然失败的一次解决/</id>
    <published>2018-02-25T06:46:25.000Z</published>
    <updated>2018-02-25T06:57:03.942Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>春节过后，重新写blog提交，发现hexo d没问题，但hexo g则出现如下错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fatal: HttpRequestException encountered.</span><br><span class="line">   ▒▒▒▒▒▒▒▒ʱ▒▒▒▒</span><br><span class="line">bash: /dev/tty: No such device <span class="keyword">or</span> address</span><br><span class="line">error: <span class="function">failed to execute prompt <span class="title">script</span> <span class="params">(<span class="built_in">exit</span> code <span class="number">1</span>)</span></span></span><br><span class="line">fatal: could not read Username for 'https://github.com': No error</span><br><span class="line">FATAL Something's wrong. Maybe you can find the solution here: http:<span class="comment">//hexo.io/do                                                                                                                                                                                               cs/troubleshooting.html</span></span><br><span class="line">Error: fatal: HttpRequestException encountered.</span><br><span class="line">   ��������ʱ������</span><br><span class="line">bash: /dev/tty: No such device <span class="keyword">or</span> address</span><br></pre></td></tr></table></figure><p>一开始我以为是因为配置文件的问题，确认后发现并不是这样。没有改动过，为什么以前可以，现在却不行了呢？</p><p>然鹅，即使我现在解决了，我也不知道为什么这个问题出现，因为从上次成功提交blog到出现这个问题为止，这台电脑并没有被动过。</p><p>唯一可能的原因大概是提交的时候，<strong><em>我在hexo d的时候ctrl+c强行终止了</em></strong>。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>github上有一个<a href="https://github.com/hexojs/hexo/issues/1495" target="_blank" rel="noopener">issue</a></p><p>这里对younglaker的回答做一下引用：</p><hr><p>I try SSH instead HTTPS, it works. If you still have problem with HTTPS, try this command:</p><p>ssh -T git@github.com</p><hr><p>我使用的是windows，在power shell 下无此命令，在git bash下可以使用，但会报出如下错误：</p><hr><p>Warning: Permanently added the RSA host key for IP address ‘(随机IP)’ to th                                                                                                                                                                                               e list of known hosts.<br>sherry0429@github.com: Permission denied (publickey).</p><hr><p>在cmd下ping报出的ip，也无法ping通，上VPN也没用。</p><p>这里的原因我个人推测，ip不是原因，原因是permisson denied，即本机的ssh无法和github的ssh配对。<a href="https://help.github.com/articles/error-permission-denied-publickey/" target="_blank" rel="noopener">这里GitHub官方给出了对这个问题的分析步骤和解决方案</a></p><p>我看过以后依次尝试，最终打算简单粗暴：</p><p><strong><em>重新生成ssh</em></strong></p><p>下面说步骤。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>找见本机存放ssh的地方<ul><li>在gitbash中输入<figure class="highlight plain"><figcaption><span>-vT git@github.com```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   - 在一大串debug信息中找到Offering public key: ... /c/Users/username/.ssh/id_rsa</span><br><span class="line">   - 这里的.ssh就是存放ssh的地方</span><br><span class="line">2. 删除掉本机的ssh</span><br><span class="line">3. 利用命令重新生成ssh</span><br><span class="line">   - 在gitbash中 输入： ```ssh-keygen -t rsa -C `&quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>密码可以不用输，一路回车即可创建</li></ul><ol><li>修改github账号settings内的ssh选项<ul><li>此时去先前存ssh的地方，可以看到有一个文件id_rsa.pub，用notepad++打开，复制里面的所有内容</li><li>登录github账号，右上角settings-&gt;SSH and GPG Keys</li><li>New SSH Keys，把前面复制的id_rsa.pub的内容复制进去，给这个ssh key取个名</li></ul></li><li>修改hexo的_config.xml<ul><li>将hexo配置文件deploy部分的repo选项修改为你的github.io库的ssh repo地址</li><li>repo ssh地址可以打开repo，在clone or download那个下拉框里，点右上角的use ssh就可以转换到ssh的repo地址</li></ul></li><li>hexo clean, hexo g, hexo d<ul><li>因为修改了_config.xml，clean一下比较好</li></ul></li><li>it’s works !</li></ol><h2 id="Linux-下"><a href="#Linux-下" class="headerlink" title="Linux 下"></a>Linux 下</h2><p>Linux下步骤也是类似的，不过考虑到真正的生产环境中，ssh-key可能不止一个，不要全删了…仔细分辨之后在进行处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;春节放完假回来再hexo提交时出现的问题，这里记录一下解决方式。&lt;/p&gt;
    
    </summary>
    
      <category term="knowledge" scheme="sherry0429.github.io/categories/knowledge/"/>
    
    
      <category term="hexo" scheme="sherry0429.github.io/tags/hexo/"/>
    
      <category term="bugs" scheme="sherry0429.github.io/tags/bugs/"/>
    
  </entry>
  
  <entry>
    <title>快速开发scrapy爬虫</title>
    <link href="sherry0429.github.io/2018/02/24/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91scrapy%E7%88%AC%E8%99%AB/"/>
    <id>sherry0429.github.io/2018/02/24/快速开发scrapy爬虫/</id>
    <published>2018-02-24T02:22:53.000Z</published>
    <updated>2018-02-25T07:03:01.945Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先介绍一下项目来源：</p><p><a href="https://github.com/geekan/scrapy-examples" target="_blank" rel="noopener">https://github.com/geekan/scrapy-examples</a></p><p>这个项目的开发者和维护者不是我，这里感谢该项目的contributors，因为需求，现在需要开发一个具体的书籍内容爬取爬虫，但迫于时间关系，想直接通过快速修改来获取自己能使用的爬虫，在github上找到了这个轮子。</p><h2 id="源代码分析"><a href="#源代码分析" class="headerlink" title="源代码分析"></a>源代码分析</h2><p>代码中除了各个网站的实例外，有一个<a href="https://github.com/geekan/scrapy-examples/tree/master/misc" target="_blank" rel="noopener">misc</a>的module，在这个module里可以看到底层CommonSpider的实现。</p><p>在CommonSpider类中，可以看到下面这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, sel, rules, item_class, force_1_item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> sel <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    items = []</span><br><span class="line">    <span class="keyword">if</span> item_class != dict:</span><br><span class="line">        self.traversal(sel, rules, item_class, <span class="keyword">None</span>, items)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.traversal_dict(sel, rules, item_class, <span class="keyword">None</span>, items, force_1_item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> items</span><br></pre></td></tr></table></figure><p>DFS即深度优先搜索，再联系该类的css_ruls注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''' # css rule example:</span></span><br><span class="line"><span class="string">all_css_rules = &#123;</span></span><br><span class="line"><span class="string">    '.zm-profile-header': &#123;</span></span><br><span class="line"><span class="string">        '.zm-profile-header-main': &#123;</span></span><br><span class="line"><span class="string">            '__use':'dump',</span></span><br><span class="line"><span class="string">            'name':'.title-section .name::text',</span></span><br><span class="line"><span class="string">            'sign':'.title-section .bio::text',</span></span><br><span class="line"><span class="string">            'location':'.location.item::text',</span></span><br><span class="line"><span class="string">            'business':'.business.item::text',</span></span><br><span class="line"><span class="string">            'employment':'.employment.item::text',</span></span><br><span class="line"><span class="string">            'position':'.position.item::text',</span></span><br><span class="line"><span class="string">            'education':'.education.item::text',</span></span><br><span class="line"><span class="string">            'education_extra':'.education-extra.item::text',</span></span><br><span class="line"><span class="string">        &#125;, '.zm-profile-header-operation': &#123;</span></span><br><span class="line"><span class="string">            '__use':'dump',</span></span><br><span class="line"><span class="string">            'agree':'.zm-profile-header-user-agree strong::text',</span></span><br><span class="line"><span class="string">            'thanks':'.zm-profile-header-user-thanks strong::text',</span></span><br><span class="line"><span class="string">        &#125;, '.profile-navbar': &#123;</span></span><br><span class="line"><span class="string">            '__use':'dump',</span></span><br><span class="line"><span class="string">            'asks':'a[href*=asks] .num::text',</span></span><br><span class="line"><span class="string">            'answers':'a[href*=answers] .num::text',</span></span><br><span class="line"><span class="string">            'posts':'a[href*=posts] .num::text',</span></span><br><span class="line"><span class="string">            'collections':'a[href*=collections] .num::text',</span></span><br><span class="line"><span class="string">            'logs':'a[href*=logs] .num::text',</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">    &#125;, '.zm-profile-side-following': &#123;</span></span><br><span class="line"><span class="string">        '__use':'dump',</span></span><br><span class="line"><span class="string">        'followees':'a.item[href*=followees] strong::text',</span></span><br><span class="line"><span class="string">        'followers':'a.item[href*=followers] strong::text',</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>我想大家都会有一个推测，即通过dfs来搜索css_rules，根据css selector来定位到某个元素，然后爬取指定位置的数据。</p><p>以往scrapy直接使用的话，需要parse到html后，自己依次用正则，或者Xpath等技术把想要的数据抽取下来，交给下个部分。是一系列顺序代码。这里通过使用dfs，将数据抽取的部分模板化了。</p><p>那么弄明白了核心逻辑，接下来我们就可以尝试修改这个代码，我现在修改的是<a href="https://github.com/geekan/scrapy-examples/tree/master/amazonbook" target="_blank" rel="noopener">amazon_book</a>这个module。</p><h2 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h2><p>scrapy具体的架构就不再细说，从项目结构上看，</p><ul><li>items.py定义了爬取下来存储的数据的基本结构</li><li>pipelines将数据持久化到了redis中</li><li>settings定义了scrapy的设置</li><li><a href="https://github.com/geekan/scrapy-examples/blob/master/misc/spider.py" target="_blank" rel="noopener">spider.py</a>则调用了misc中CommonSpider的具体函数</li></ul><p>因此，我们如果需要快速模板化一个网站去爬取，那么只需要修改amazon_book中spider.py中的css_rules就可以了</p><p>如果我们需要修改爬取的具体行为，或者中间件，代理代理设置等，则需要去<a href="https://github.com/geekan/scrapy-examples/tree/master/misc" target="_blank" rel="noopener">misc</a>这个module中去寻找。</p><h2 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h2><p>那么现在直接从对这个爬虫的具体修改讲起。</p><p>首先说需求，我需要爬取amazon中某个具体book详情页的：</p><ul><li>名称</li><li>isbn号</li><li>价格</li><li>概述</li><li>试读</li><li>热门/畅销榜单</li></ul><p>那么这里直接打开一个amazon的书籍页面开始分析，我们以<a href="https://www.amazon.cn/dp/B002WC7NGS/ref=sr_1_2?ie=UTF8&amp;qid=1519440234&amp;sr=8-2&amp;keywords=%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">数据结构与算法分析:C语言描述(原书第2版)</a>这本经典的书开始。</p><p>具体细节也不再详细说明，只说一下大概步骤：</p><ul><li>找出需求中属于静态网页数据（即查看网页源码就能获取的内容）</li><li>找出需求中属于动态加载的数据（通过Chrome开发者工具的NetWork面板）</li><li>判断爬虫实现难度（主要在动态加载部分上，如果动态加载部分的请求URL过于难拼，考虑放弃该字段，没办法放弃就硬啃吧，做好心理准备和工期规划）</li><li>构造静态网页数据的爬取规则</li><li>构造动态加载数据的请求URL</li><li>实现爬虫</li></ul><p>这里我直接给出前五步的结果，然后开始实现爬虫。</p><p>通过分析页面可知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">allowed_domains = [&quot;amazon.cn&quot;, &quot;www.amazon.cn&quot;]</span><br><span class="line">start_urls = [</span><br><span class="line">    &quot;https://www.amazon.cn/dp/B002WC7NGS&quot;,</span><br><span class="line">]</span><br><span class="line">rules = [</span><br><span class="line">    Rule(sle(allow=(&quot;/dp/B002WC7NGS&quot;)), callback=&apos;parse_0&apos;, follow=True),</span><br><span class="line">]</span><br><span class="line">css_rules = &#123;</span><br><span class="line">    &quot;#title&quot;: &#123;</span><br><span class="line">        &quot;title&quot;: &quot;#productTitle::text&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;#byline&quot;: &#123;</span><br><span class="line">        &quot;author&quot;: &quot;.a-link-normal::text&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;.bucket&gt;.content&quot;: &#123;</span><br><span class="line">        &quot;base_info_title&quot;: &quot;li&gt;b::text&quot;,</span><br><span class="line">        &quot;base_info_content&quot;: &quot;li::text&quot;,</span><br><span class="line">        &quot;average_star&quot;: &quot;.a-icon-alt::text&quot;,</span><br><span class="line">        &quot;sum_comments&quot;: &quot;.a-link-normal::text&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于css规则如何写可以看：<a href="http://www.w3school.com.cn/cssref/css_selectors.asp" target="_blank" rel="noopener">css_selector</a></p><p>值得注意的是，这个爬虫的实现中，调用parse_0返回的是一个list格式的数据，我们把它修改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_0</span><span class="params">(self, response)</span>:</span></span><br><span class="line">    info(<span class="string">'Parse 0 '</span>+response.url)</span><br><span class="line">    item = self.parse_with_rules(response, self.css_rules, dict)</span><br><span class="line">    <span class="keyword">if</span> isinstance(item, dict):</span><br><span class="line">        <span class="keyword">yield</span> item</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data_dict = dict()</span><br><span class="line">        data_dict[<span class="string">'data'</span>] = item</span><br><span class="line">        <span class="keyword">yield</span> data_dict</span><br></pre></td></tr></table></figure><p>注意三个地方：</p><ul><li>parse_with_rules的第三个参数是dict，表明我们希望爬取的数据以dict类型存储，但如果有多条，则会是list类型的dict</li><li>使用yield而不是return，否则爬取到数据会立刻结束爬虫，无法执行pipelines的逻辑</li><li>先判断返回的item是dict还是list</li></ul><p>修改好以上部分后，就可以执行代码了，我们在amazonbook目录下打开shell输入：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy crawl amazonbook</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>接下来可以看到shell下输出一堆信息，默认的情况下，会使用自带的JsonPipeline，可以看到amazonbook下出现了一个data_utf8.json的文件，以下为我爬取的样例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"data"</span>: [&#123;</span><br><span class="line">  <span class="attr">"#title"</span>: [&#123;</span><br><span class="line">    <span class="attr">"title"</span>: [<span class="string">"数据结构与算法分析:C语言描述(原书第2版)"</span>]&#125;], </span><br><span class="line">  <span class="attr">"#byline"</span>: [&#123;<span class="attr">"author"</span>: [<span class="string">"维斯"</span>, <span class="string">"冯舜玺"</span>]&#125;], </span><br><span class="line">  <span class="attr">".bucket&gt;.content"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="attr">"base_info_title"</span>: [<span class="string">"出版社:"</span>, <span class="string">"丛书名:"</span>, <span class="string">"平装:"</span>, <span class="string">"语种："</span>, <span class="string">"开本:"</span>, <span class="string">"ISBN:"</span>, <span class="string">"条形码:"</span>, <span class="string">" 商品尺寸: "</span>, <span class="string">" 商品重量: "</span>, <span class="string">"品牌:"</span>, <span class="string">"ASIN: "</span>, <span class="string">"用户评分:"</span>, <span class="string">"亚马逊热销商品排名:"</span>], </span><br><span class="line">    <span class="attr">"average_star"</span>: [<span class="string">"平均 4.2 星"</span>], </span><br><span class="line">    <span class="attr">"base_info_content"</span>: [<span class="string">" 机械工业出版社; 第1版 (2004年1月1日)"</span>, <span class="string">" "</span>, <span class="string">" 391页"</span>, <span class="string">" 简体中文"</span>, <span class="string">" 16"</span>, <span class="string">" 711112748X, 9787111127482"</span>, <span class="string">" 9787111127482"</span>, <span class="string">" 25.7 x 18.3 x 1.8 cm "</span>, <span class="string">" 621 g "</span>, <span class="string">" 机械工业出版社"</span>, <span class="string">"B002WC7NGS"</span>, <span class="string">" 图书商品里排第2,331名 ("</span>, <span class="string">") "</span>], </span><br><span class="line">    <span class="attr">"sum_comments"</span>: [<span class="string">" 236 条商品评论 "</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这里只是将了静态数据的爬取，下一节写动态数据的爬取。</p><p>爬虫本身难点并不在爬取上，难点还是在数据清洗，整理，断点续爬等，这里只讲如何应付一些小需求，快速实现。</p><p>同样，在这个轮子上进行修改，修改CommonSpider，也可以达到自己想要达到的功能。比如，不熟悉css的话，可以hack掉CommonSpider，把其中的sel.css改成sel.xpath，再进行适当的调整后，就可以用xpath来进行写解析规则了。</p><p>试了一趟个人感觉，XPath可以定位到某个具体的属性，css目前定位到的是元素，对元素中的属性，似乎无法精确的定位到，查了查没有找见，如果有高手了解，希望不吝赐教。</p><p>本项目的源代码在动态数据的爬取一章结束后会带在章节末尾。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;适合有一定爬虫经验和前端/后端开发经验的人，快速通过github上的scrapy-example，改造出适合自己的爬虫。&lt;/p&gt;
&lt;p&gt;需要的基础知识点为python, scrapy, css selector。&lt;/p&gt;
    
    </summary>
    
      <category term="knowledge" scheme="sherry0429.github.io/categories/knowledge/"/>
    
    
      <category term="python" scheme="sherry0429.github.io/tags/python/"/>
    
      <category term="spider" scheme="sherry0429.github.io/tags/spider/"/>
    
      <category term="scrapy" scheme="sherry0429.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>Except Test</title>
    <link href="sherry0429.github.io/2018/02/12/Except-Test/"/>
    <id>sherry0429.github.io/2018/02/12/Except-Test/</id>
    <published>2018-02-12T01:36:13.000Z</published>
    <updated>2018-02-12T03:18:57.397Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>this is articles’s content</p><p>test characters &gt; 300,</p><p>test characters:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">Dima Bilan - Believe me</span><br><span class="line"></span><br><span class="line">Even when the thunder and storm begins </span><br><span class="line">就算电闪雷鸣风暴即将到来的时候 </span><br><span class="line">I&apos;ll be standing stong like a tree in the wind </span><br><span class="line">我也会像风中的大树一样坚定地站立 </span><br><span class="line">Nothing is gonna move this mountain or change my direction </span><br><span class="line">我的方向（愿望）就像大山一样没有什么可以撼动（它） </span><br><span class="line">I&apos;m falling off the sky and I&apos;m all alone </span><br><span class="line">我孤独地从空中坠落 </span><br><span class="line">The courage that&apos;s inside is gonna break my fall </span><br><span class="line">内心深处的勇气将会阻止我的坠落 </span><br><span class="line">Nothing is gonna dim my light within </span><br><span class="line">没有什么可以熄灭我心中的光线（希望） </span><br><span class="line">But if I keep going on it will never be impossible </span><br><span class="line">如果我坚持去做那么没有什么是不可能的 </span><br><span class="line">Not today. </span><br><span class="line">不是今天 </span><br><span class="line">Cause I got something to believe in </span><br><span class="line">因为我有信仰 </span><br><span class="line">As long as I&apos;m breathing </span><br><span class="line">只要我还在呼吸 </span><br><span class="line">There is not a limit to what I can dream </span><br><span class="line">那么我的梦想就永不会有止境 </span><br><span class="line">Cause I got something to believe in </span><br><span class="line">因为我有信仰 </span><br><span class="line">Mission to keep climbing </span><br><span class="line">因为我还有未竟的事业 </span><br><span class="line">Nothing else can stop me if I just believe </span><br><span class="line">如果我相信自己那么就没有什么可以阻止我 </span><br><span class="line">And I believe in me. </span><br><span class="line">我相信自己 </span><br><span class="line"></span><br><span class="line">Even when the world tries to pull me down </span><br><span class="line">就算世界想把我摧毁 </span><br><span class="line">Tell me that I can&apos;t... try to turn me around </span><br><span class="line">告诉我做不到的....试着把我翻转 </span><br><span class="line">I wont let them put my fire out </span><br><span class="line">我不会让他们把我摧毁(燃烧殆尽) </span><br><span class="line">But if I keep going on it will never be impossible </span><br><span class="line">如果我坚持去做那么没有什么是不可能的 </span><br><span class="line">Not today </span><br><span class="line">不是今天 </span><br><span class="line"></span><br><span class="line">Cause I got something to believe in </span><br><span class="line">因为我有信仰 </span><br><span class="line">As long as I&apos;m breathing </span><br><span class="line">只要我还在呼吸 </span><br><span class="line">There is not a limit to what I can dream </span><br><span class="line">那么我的梦想就永不会有止境 </span><br><span class="line">Cause I got something to believe in </span><br><span class="line">因为我有信仰 </span><br><span class="line">Mission to keep climbing </span><br><span class="line">因为我还有未竟的事业 </span><br><span class="line">Nothing else can stop me if I just believe </span><br><span class="line">如果我相信自己那么就没有什么可以阻止我 </span><br><span class="line">And I believe in me. </span><br><span class="line">我相信自己 </span><br><span class="line"></span><br><span class="line">I can do it all, open every door </span><br><span class="line">我可以全部做到,打开所有的门 </span><br><span class="line">Turn unthinkable to reality </span><br><span class="line">化不可能为现实 </span><br><span class="line">You see I can do it all and more </span><br><span class="line">你会看到我可以全部做到 </span><br><span class="line">Believing as long as I&apos;m breathing </span><br><span class="line">(我)相信只要我还在呼吸 </span><br><span class="line">There is not a limit to what I can dream </span><br><span class="line">那么我的梦想就永不会有止境 </span><br><span class="line">Cause I got something to believe in </span><br><span class="line">因为我有信仰 </span><br><span class="line">Mission to keep climbing </span><br><span class="line">因为我还有未竟的事业 </span><br><span class="line">Nothing else can stop me if I just believe </span><br><span class="line">如果我相信自己那么就没有什么可以阻止我 </span><br><span class="line">And I believe in me. </span><br><span class="line">我相信自己</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;this is article’s summary, you can’t see it in content&lt;/p&gt;
    
    </summary>
    
      <category term="other" scheme="sherry0429.github.io/categories/other/"/>
    
    
      <category term="test" scheme="sherry0429.github.io/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="sherry0429.github.io/2018/02/11/KMP/"/>
    <id>sherry0429.github.io/2018/02/11/KMP/</id>
    <published>2018-02-11T07:19:59.000Z</published>
    <updated>2018-02-12T03:46:53.505Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 100000</span></span><br><span class="line"><span class="keyword">int</span> T[MAXN],P[MAXM],Next[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeNext</span><span class="params">(<span class="keyword">int</span> M)</span><span class="comment">//找到一个匹配位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;M)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span> || P[i]==P[j])</span><br><span class="line">&#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">            <span class="keyword">if</span>(P[i]!=P[j])</span><br><span class="line">Next[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">Next[i] = Next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">j = Next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span> M)</span><span class="comment">//进行匹配</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;N &amp;&amp; j&lt;M)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[i]==P[j] || j==<span class="number">-1</span>)</span><br><span class="line">i++,j++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">j = Next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==M)</span><br><span class="line"><span class="keyword">return</span> i-M+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,M,C;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;C);</span><br><span class="line">    <span class="keyword">while</span>(C--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;N,&amp;M);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T[i]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;P[i]);</span><br><span class="line">        <span class="keyword">if</span>(M&gt;N)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">            MakeNext(M);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,KMP(N,M));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="code_template" scheme="sherry0429.github.io/categories/code-template/"/>
    
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
      <category term="kmp" scheme="sherry0429.github.io/tags/kmp/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode #003 Longest Substring Without Repeating Characters</title>
    <link href="sherry0429.github.io/2018/02/11/LeetCode-003-Longest-Substring-Without-Repeating-Characters/"/>
    <id>sherry0429.github.io/2018/02/11/LeetCode-003-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2018-02-11T06:58:00.000Z</published>
    <updated>2018-02-12T03:48:31.224Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>#003 Longest Substring Without Repeating Characters</p><blockquote><p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p><p>Input: abcabccbb<br>Output: 3<br>题意：找到一个字符串中，没有重复字符的最长子串，返回它的长度</p><p>#####思路：</p><ol><li>做一个一维数组HashTable，下标为字符的ASCII码，值为这个字符在字符串中的位置，初始化为-1</li><li>设置一个变量LastPosition表示不重复最长串的第一个元素的下标</li><li>遍历字符串，依次检测该字符是否存在HashTable中，例：<br><code>HashTable[&#39;a&#39;]=-1</code>表示该字符第一次出现。<br><code>HashTable[&#39;a&#39;]=2</code>表示该字符上一次出现的位置在str[2].</li><li>如果第一次出现该字符a，HashTable[‘a’]=字符’a’在字符串中的位置.</li><li>如果已经出现过字符’a’，如果上一次’a’在目前检测串中，则置LastPosition为a的下标（即上一次LastPostion）。否则置LastPosition为当前检测字符的下标（HashTable[temp]）。<br>该下标一定为：<code>LastPosition=std::max(LastPosition,HashTable[temp]);</code></li><li>Max为<code>HashTable[temp]-LastPostion</code>所能得到的最大值<br>| a | b | c | d | a |<br>| – |</li></ol></blockquote><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>5</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>#####代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> LastPosition=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> HashTable[<span class="number">255</span>]=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=(<span class="keyword">int</span>)s[i];</span><br><span class="line">            <span class="keyword">if</span>(HashTable[temp]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                LastPosition=<span class="built_in">std</span>::max(LastPosition,HashTable[temp]);</span><br><span class="line">            &#125;</span><br><span class="line">            HashTable[temp]=i+<span class="number">1</span>;</span><br><span class="line">            Max=<span class="built_in">std</span>::max(Max,HashTable[temp]-LastPosition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>#####知识点</p><ol><li>字符串中寻找最长符合要求的子串</li><li>难点：当检测到重复字符时，应该从何处继续检测</li><li>还有一种DP解法如下，其实上面的代码也是DP，DP指通过状态转移来解决问题的一种思路，每一种状态的决定总是与上一次状态有联系，以下代码中，Flag数组就是一种记录状态，而Longest每次依赖于上一次Longest还有Flag数组中的状态，因此说这种解决思路是一种DP思路。这个代码由LeetCode上的prime_tang所写，此处为引用。我询问后，他对DP思路的描述原文如下：<blockquote><p>In my understanding, the dynamic programming is: every decision depends on the current status, and immediately cause the transfer of status. In this problem, flag is the status, and we can get the longest every time depends on the previous longest and the flag, so I think it also can be seen as DP solution, even though not obvious compared to the Maximum Subarray problem.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, longest = <span class="number">0</span>, len = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[s[i]] &gt;= start) &#123;</span><br><span class="line">                longest = <span class="built_in">std</span>::max(longest, i - start);</span><br><span class="line">                start = flag[s[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(longest, len - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
      <category term="leetcode" scheme="sherry0429.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode #002 Add Two Numbers</title>
    <link href="sherry0429.github.io/2018/02/11/LeetCode-002-Add-Two-Numbers/"/>
    <id>sherry0429.github.io/2018/02/11/LeetCode-002-Add-Two-Numbers/</id>
    <published>2018-02-11T06:57:37.000Z</published>
    <updated>2018-02-12T03:48:22.302Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>#002 Add Two Numbers</p><blockquote><p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p><p>#####思路：</p><ol><li>建立一个新的链表List</li><li>依次检测两个链表节点是否为空，不为空则检测值</li><li>如果检测到值，<code>int value = val1 + val2 + remain;</code></li><li>val1=l1-&gt;val,val2=l2-&gt;val,它们被初始化为0,remain为进位值.</li><li>将value存入List节点里<br>#####代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> remain = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//new list</span></span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//head node,it is empty.</span></span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="literal">NULL</span> &amp;&amp; l2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1==<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> ||  l2 != <span class="literal">NULL</span>)<span class="comment">//only two list get end,while will be finish.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = <span class="number">0</span>, val2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            val1 = l1-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            val2 = l2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = val1 + val2 + remain;</span><br><span class="line">        remain = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(value &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            value -= <span class="number">10</span>;<span class="comment">//value = value % 10</span></span><br><span class="line">            remain = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//build List</span></span><br><span class="line">        ListNode * pos = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">        p-&gt;next = pos;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if ABCDE</span></span><br><span class="line"><span class="comment">    if FGHIG</span></span><br><span class="line"><span class="comment">    AND IF E+G&gt;10</span></span><br><span class="line"><span class="comment">    we need make a new node,it's val is (E+G)%10.</span></span><br><span class="line"><span class="comment">    like this:</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(remain != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pos = <span class="keyword">new</span> ListNode(remain);</span><br><span class="line">        p-&gt;next = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    <span class="comment">//!!!__Don't return head because head is empty,head-&gt;next is first node with val.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>#####知识点</p><ol><li>如何用尾插法建立链表</li><li>同时遍历两个链表并进行相应处理（均遍历到结尾时处理才结束）</li><li>当遍历A节点时，得到需要处理A-&gt;next的信息，如何在遍历时延后一步处理。<ol><li>方案1：用一个Bool量标记是否应当处理，在建表后的语句中加入处理语句</li><li>方案2：类似这种求和，将信息保留在remain中，每次加上remain，无信息则remain=0,否则remain=溢出数.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案1</span></span><br><span class="line"><span class="keyword">bool</span> deal=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">....<span class="comment">//here you build list</span></span><br><span class="line"><span class="keyword">if</span>(deal)&#123;</span><br><span class="line">....<span class="comment">//here you deal something</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方案2</span></span><br><span class="line"><span class="keyword">int</span> value = val1 + val2 + remain;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
      <category term="leetcode" scheme="sherry0429.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode #001 Two Num</title>
    <link href="sherry0429.github.io/2018/02/11/LeetCode-001-Two-Num/"/>
    <id>sherry0429.github.io/2018/02/11/LeetCode-001-Two-Num/</id>
    <published>2018-02-11T06:57:22.000Z</published>
    <updated>2018-02-12T03:48:13.667Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>#01 Two Num</p><blockquote><p>Given an array of integers, find two numbers such that they add up to a specific target number.<br>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br>You may assume that each input would have exactly one solution.</p><p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p><p>#####思路1：</p><ol><li>用STL Map，将数据存入Map，而后查找First和Target-First是否都存在，如都存在，输出他们的下标。（即First，Target-First对应的Value）.</li><li>迭代器iterator两个域,iterator-&gt;first对应Key,iterator-&gt;second对应Value.</li><li>循环遍历Nums，检测Map，跳过Nums下标为Map-Value的元素。（重要）<br>#####代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Map;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> solve;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            Map[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (Map[temp]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="comment">//this if is important</span></span><br><span class="line">                <span class="keyword">if</span>(i == Map[temp])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//Map's value don't need in 'for' fuction.</span></span><br><span class="line">                &#125;</span><br><span class="line">                solve.push_back(i+<span class="number">1</span>);</span><br><span class="line">                solve.push_back(Map[temp]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> solve;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> solve;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>####思路2</p><ol><li>分配一个数组空间，将数据拷贝至A</li><li>将A数组排序</li><li>建立两个查找指针头指针X,尾指针Y,依次相加比较指针所指的值E,F</li><li>E大于F Y++</li><li>E小于F X++</li><li>当指针相等或相交时退出循环</li><li>提前退出循环说明找到了E+F=target</li><li>遍历nums，当值与找到的E,F相等时,将相应的下标Push进Vector</li></ol><p>#####代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt;temp;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;index;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; len;i++)</span></span><br><span class="line">        <span class="comment">//  temp.push_back(nums[i]);</span></span><br><span class="line">        <span class="comment">//sort(temp.begin(),temp.end());</span></span><br><span class="line">        qsort(temp,len,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),compare);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((temp[left] + temp[right]) &gt; target)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((temp[left] + temp[right]) &lt; target)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == temp[left] || nums[i] == temp[right])</span><br><span class="line">                index.push_back(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> []temp;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>#####知识点</p><ol><li>在一个数组中查找指定元素</li><li>对数组元素进行排序</li><li>得到排序数组中比某数小或大的区域（该数不一定存在在数组内）</li><li>知道一组值，求与这组值有关的另一组值</li><li>方法2的一种特殊思路.</li></ol><p>#####官网给出的Solution</p><blockquote><p>####O(n2) runtime, O(1) space – Brute force:</p><p>The brute force approach is simple. Loop through each element x and find if there is another value that equals to target – x. As finding another value requires looping through the rest of array, its runtime complexity is O(n2).</p><p>####O(n) runtime, O(n) space – Hash table:</p><p>We could reduce the runtime complexity of looking up a value to O(1) using a hash map that maps a value to its index.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
      <category term="leetcode" scheme="sherry0429.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>C++文件流 总结</title>
    <link href="sherry0429.github.io/2018/02/11/C-%E6%96%87%E4%BB%B6%E6%B5%81-%E6%80%BB%E7%BB%93/"/>
    <id>sherry0429.github.io/2018/02/11/C-文件流-总结/</id>
    <published>2018-02-11T06:54:35.000Z</published>
    <updated>2018-02-12T03:18:50.387Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h1 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h1><p>首先，需要加<fstream>头文件。（即file stream），在包含这个头文件后，可使用三种类：</fstream></p><ul><li>ofstream  写文件  （Output File Stream）  <ul><li>使用方法: 文件名&lt;&lt;内容&lt;&lt;endl;</li></ul></li><li>ifstream   读文件 （Input File Stream）  <ul><li>使用方法:文件名&gt;&gt;内容;</li></ul></li><li>fstream  打开文件供读写  （File Stream） <ul><li>利用各种参数达到控制文件读写的目的</li></ul></li></ul><h1 id="Same"><a href="#Same" class="headerlink" title="Same"></a>Same</h1><p>每个类都有相同的两种函数功能：</p><ul><li>X.open(“String”);   <ul><li>//String为路径，也可以string str；X.open(str);(用string类，没有引号，但是string本身内容里最后4个单位应为.txt）</li><li>如果用fstream创建文件 必须加Ios::out.</li></ul></li><li>X.close();</li></ul><p>同一时间，同一文件只能由一种类进行操作。若需要换，必须先将此类指针关闭，再用需要的类的指针Open目标文件。</p><h1 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h1><p>fstream的open函数的参数定义了文件的打开模式。总共有如下模式：</p><ul><li>ios::in 读</li><li>ios::out 写</li><li>ios::app 从文件末尾开始写</li><li>ios::binary       二进制模式</li><li>ios::nocreate 打开一个文件时，如果文件不存在，不创建文件。</li><li>ios::noreplace  打开一个文件时，如果文件不存在，创建该文件</li><li>ios::trunc 打开一个文件，然后清空内容</li><li>ios::ate 打开一个文件时，将位置移动到文件尾</li></ul><p>使用方式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.open(<span class="string">"file.ext"</span>,iso::in|ios::out)</span><br></pre></td></tr></table></figure><ul><li>默认模式是文本</li><li>默认如果文件不存在，那么创建一个新的</li><li>多种模式可以混合，用|(按位或)</li><li>文件的byte索引从0开始。（就像数组一样）</li></ul><h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><ul><li>good()<ul><li>如果文件打开成功</li></ul></li><li>bad() <ul><li>打开文件时发生错误</li></ul></li><li>eof() <ul><li>到达文件尾</li></ul></li></ul><h2 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h2><ul><li>seekg() </li><li>tellg()</li><li>seekp()          </li><li>tellq()</li></ul><p>以g结尾的，处理get指针（ifstream），以p结尾的，处理put指针（ofstream）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seekg/p(X,INF);</span><br></pre></td></tr></table></figure><p>X为一个数，可为正可为负，INF为一个参数，该参数可为以下：</p><ul><li>ios::beg  文件头</li><li>ios::end  文件尾</li><li>ios::cur  当前位置</li></ul><p>整个函数表示将指针从INF处，移动X个单位。</p><p>例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seekg(<span class="number">-1</span>,ios::end);<span class="comment">//把指针从文件尾向前移动一个字节</span></span><br></pre></td></tr></table></figure><p>tellg, tellp : 返回一个数，表示此时指针所在的位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="think" scheme="sherry0429.github.io/categories/think/"/>
    
    
      <category term="c++" scheme="sherry0429.github.io/tags/c/"/>
    
      <category term="file" scheme="sherry0429.github.io/tags/file/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机</title>
    <link href="sherry0429.github.io/2018/02/11/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>sherry0429.github.io/2018/02/11/AC自动机/</id>
    <published>2018-02-11T06:52:54.000Z</published>
    <updated>2018-02-25T07:36:32.637Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>source link: <a href="http://blog.csdn.net/niushuai666/article/details/7002823" target="_blank" rel="noopener">http://blog.csdn.net/niushuai666/article/details/7002823</a></p><h1 id="AC自动机简介："><a href="#AC自动机简介：" class="headerlink" title="AC自动机简介："></a>AC自动机简介：</h1><p>##AC自动机的构造：</p><ul><li><p>构造一棵Trie，作为AC自动机的搜索数据结构。</p></li><li><p>构造fail指针，使当前字符失配时跳转到具有最长公共前后缀的字符继续匹配。</p><p>如同 KMP算法一样， AC自动机在匹配时如果当前字符匹配失败，那么利用fail指针进行跳转。由此可知如果跳转，跳转后的串的前缀，必为跳转前的模式串的后缀并且跳转的新位置的深度（匹配字符个数）一定小于跳之前的节点。所以我们可以利用 bfs在 Trie上面进行 fail指针的求解。</p></li><li><p>扫描主串进行匹配。</p></li></ul><h2 id="AC自动机详讲："><a href="#AC自动机详讲：" class="headerlink" title="AC自动机详讲："></a>AC自动机详讲：</h2><p>我们给出5个单词，say，she，shr，he，her。给定字符串为yasherhs。问多少个单词在字符串中出现过。</p><p><strong>一、Trie</strong></p><p>首先我们需要建立一棵Trie。但是这棵Trie不是普通的Trie，而是带有一些特殊的性质。</p><p>首先会有3个重要的指针，分别为p, p-&gt;fail, temp。</p><p>1.指针p，指向当前匹配的字符。若p指向root，表示当前匹配的字符序列为空。（root是Trie入口，没有实际含义）。</p><p>2.指针p-&gt;fail，p的失败指针，指向与字符p相同的结点，若没有，则指向root。</p><p>3.指针temp，测试指针（自己命名的，容易理解！~），在建立fail指针时有寻找与p字符匹配的结点的作用，在扫描时作用最大，也最不好理解。</p><p>对于Trie树中的一个节点，对应一个序列s[1…m]。此时，p指向字符s[m]。若在下一个字符处失配，即p-&gt;next[s[m+1]] == NULL，则由失配指针跳到另一个节点(p-&gt;fail)处，该节点对应的序列为s[i…m]。若继续失配，则序列依次跳转直到序列为空或出现匹配。在此过程中，p的值一直在变化，但是p对应节点的字符没有发生变化。在此过程中，我们观察可知，最终求得得序列s则为最长公共后缀。另外，由于这个序列是从root开始到某一节点，则说明这个序列有可能是某些序列的前缀。</p><p>再次讨论p指针转移的意义。如果p指针在某一字符s[m+1]处失配(即p-&gt;next[s[m+1]] == NULL)，则说明没有单词s[1…m+1]存在。此时，如果p的失配指针指向root，则说明当前序列的任意后缀不会是某个单词的前缀。如果p的失配指针不指向root，则说明序列s[i…m]是某一单词的前缀，于是跳转到p的失配指针，以s[i…m]为前缀继续匹配s[m+1]。</p><p>对于已经得到的序列s[1…m]，由于s[i…m]可能是某单词的后缀，s[1…j]可能是某单词的前缀，所以s[1…m]中可能会出现单词。此时，p指向已匹配的字符，不能动。于是，令temp = p，然后依次测试s[1…m], s[i…m]是否是单词。</p><p>构造的Trie为：</p><p><img src="http://www.cppblog.com/images/cppblog_com/mythit/ac1.jpg" alt="img"></p><p><strong>二、构造失败指针</strong></p><p>用BFS来构造失败指针，与KMP算法相似的思想。</p><p>首先，root入队，第1次循环时处理与root相连的字符，也就是各个单词的第一个字符h和s，因为第一个字符不匹配需要重新匹配，所以第一个字符都指向root（root是Trie入口，没有实际含义）失败指针的指向对应下图中的(1)，(2)两条虚线；第2次进入循环后，从队列中先弹出h，接下来p指向h节点的fail指针指向的节点，也就是root；p=p-&gt;fail也就是p=NULL说明匹配序列为空，则把节点e的fail指针指向root表示没有匹配序列，对应图-2中的(3)，然后节点e进入队列；第3次循环时，弹出的第一个节点a的操作与上一步操作的节点e相同，把a的fail指针指向root，对应图-2中的(4)，并入队；第4次进入循环时，弹出节点h(图中左边那个)，这时操作略有不同。由于p-&gt;next[i]!=NULL(root有h这个儿子节点，图中右边那个)，这样便把左边那个h节点的失败指针指向右边那个root的儿子节点h，对应图-2中的(5)，然后h入队。以此类推：在循环结束后，所有的失败指针就是图-2中的这种形式。</p><p><img src="http://www.cppblog.com/images/cppblog_com/mythit/ac2.JPG" alt="img"></p><p><strong>三、扫描</strong></p><p>构造好Trie和失败指针后，我们就可以对主串进行扫描了。这个过程和KMP算法很类似，但是也有一定的区别，主要是因为AC自动机处理的是多串模式，需要防止遗漏某个单词，所以引入temp指针。</p><p>匹配过程分两种情况：(1)当前字符匹配，表示从当前节点沿着树边有一条路径可以到达目标字符，此时只需沿该路径走向下一个节点继续匹配即可，目标字符串指针移向下个字符继续匹配；(2)当前字符不匹配，则去当前节点失败指针所指向的字符继续匹配，匹配过程随着指针指向root结束。重复这2个过程中的任意一个，直到模式串走到结尾为止。</p><p> 对照上图，看一下模式匹配这个详细的流程，其中模式串为yasherhs。对于i=0,1。Trie中没有对应的路径，故不做任何操作；i=2,3,4时，指针p走到左下节点e。因为节点e的count信息为1，所以cnt+1，并且讲节点e的count值设置为-1，表示改单词已经出现过了，防止重复计数，最后temp指向e节点的失败指针所指向的节点继续查找，以此类推，最后temp指向root，退出while循环，这个过程中count增加了2。表示找到了2个单词she和he。当i=5时，程序进入第5行，p指向其失败指针的节点，也就是右边那个e节点，随后在第6行指向r节点，r节点的count值为1，从而count+1，循环直到temp指向root为止。最后i=6,7时，找不到任何匹配，匹配过程结束。</p><p>到此，AC自动机入门知识就讲完了。HDU 2222入门题必须果断A掉，反正我是参考别人代码敲的。。。</p><p>AC自动机貌似还有很多需要优化的地方，等把基础搞定之后再学习一下怎么优化吧。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="reprint" scheme="sherry0429.github.io/categories/reprint/"/>
    
    
      <category term="acm" scheme="sherry0429.github.io/tags/acm/"/>
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 随笔记录</title>
    <link href="sherry0429.github.io/2018/02/11/OpenCV-%E9%9A%8F%E7%AC%94%E8%AE%B0%E5%BD%95/"/>
    <id>sherry0429.github.io/2018/02/11/OpenCV-随笔记录/</id>
    <published>2018-02-11T06:52:18.000Z</published>
    <updated>2018-02-12T03:48:40.031Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>在实验室里听一点记一点，到时候再总结整理吧。先记下来再说。</p><p>一定要记住的page：<a href="http://wiki.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">http://wiki.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     IplImage * test=NULL;</span><br><span class="line">     test = cvLoadImage (&quot;D:\\demo.jpg&quot;);</span><br><span class="line">     cvNamedWindow(&quot;test_demo&quot;,1);</span><br><span class="line"> cvMoveWindow(&quot;test_demo&quot;,800,10);</span><br><span class="line">     cvShowImage(&quot;test_demo&quot;,test);</span><br><span class="line">     cvWaitKey(0);</span><br><span class="line">     cvDestroyWindow(&quot;test_demo&quot;);</span><br><span class="line">     cvReleaseImage(&amp;test);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知函数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.IplImage *p=NULL;定义图像指针</span><br></pre></td></tr></table></figure><p>IplImage是一个类，它包含以下结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IplImage</span><br><span class="line">    &#123;</span><br><span class="line">        int  nSize;         /* IplImage大小，=sizeof(IplImage)*/</span><br><span class="line">        int  ID;            /* 版本 (=0)*/</span><br><span class="line">        int  nChannels;     /* 大多数OPENCV函数支持1,2,3 或 4 个通道 */</span><br><span class="line">        int  alphaChannel;  /* 被OpenCV忽略 */</span><br><span class="line">        int  depth;         /* 像素的位深度: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U,</span><br><span class="line">                               IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F 可支持 */</span><br><span class="line">        char colorModel[4]; /* 被OpenCV忽略 */</span><br><span class="line">        char channelSeq[4]; /* 被OpenCV忽略 */</span><br><span class="line">        int  dataOrder;     /* 0 - 交叉存取颜色通道，对三通道RGB图像，像素存储顺序为BGR BGR BGR ... BGR；</span><br><span class="line">                                     1 - 分开的颜色通道，对三通道RGB图像，像素存储顺序为RRR...R GGG...G BBB...B。</span><br><span class="line">                                  cvCreateImage只能创建交叉存取图像 */</span><br><span class="line">        int  origin;        /* 0 - 顶—左结构,</span><br><span class="line">                               1 - 底—左结构 (Windows bitmaps 风格) */</span><br><span class="line">        int  align;         /* 图像行排列 (4 or 8). OpenCV 忽略它，使用 widthStep 代替 */</span><br><span class="line">        int  width;         /* 图像宽像素数 */</span><br><span class="line">        int  height;        /* 图像高像素数*/</span><br><span class="line">        struct _IplROI *roi;/* 图像感兴趣区域. 当该值非空只对该区域进行处理 */</span><br><span class="line">        struct _IplImage *maskROI; /* 在 OpenCV中必须置NULL */</span><br><span class="line">        void  *imageId;     /* 同上*/</span><br><span class="line">        struct _IplTileInfo *tileInfo; /*同上*/</span><br><span class="line">        int  imageSize;     /* 图像数据大小(在交叉存取格式下imageSize=image-&gt;height*image-&gt;widthStep），单位字节*/</span><br><span class="line">        char *imageData;  /* 指向排列的图像数据 */</span><br><span class="line">        int  widthStep;   /* 排列的图像行大小，以字节为单位 */</span><br><span class="line">        int  BorderMode[4]; /* 边际结束模式, 被OpenCV忽略 */</span><br><span class="line">        int  BorderConst[4]; /* 同上 */</span><br><span class="line">        char *imageDataOrigin; /* 指针指向一个不同的图像数据结构（不是必须排列的），是为了纠正图像内存分配准备的 */</span><br><span class="line">    &#125;</span><br><span class="line">    IplImage;</span><br></pre></td></tr></table></figure><p>每定义一个IplImage指针，就定义了一个矩形，矩形的每一行依次为nsize,ID……等等。如图：</p><p><img src="http://img.blog.csdn.net/20140707151208062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxNDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.cvLoadImage()</span><br></pre></td></tr></table></figure><p>cvLoadImage( filename, -1 ); 默认读取图像的原通道数，filename为图像路径</p><p>cvLoadImage( filename, 0 ); 强制转化读取图像为灰度图</p><p>cvLoadImage( filename, 1 ); 读取彩色图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.cvNameWindow(&quot;Image&quot;,1);命名图像空间</span><br></pre></td></tr></table></figure><p>int cvNamedWindow( const char* name, int flags=CV_WINDOW_AUTOSIZE );</p><p>函数cvNamedWindow创建一个可以放置图像的窗口.</p><p>被创建的窗口可以通过它们的名字被引用.</p><p>如果已经存在这个名字的窗口，这个函数将不做任何事情.</p><p>若为0表示以固定尺寸显示,此时可以用cvResizeWindow控制窗口大小，这时图像根据窗口大小进行调整，且全铺在窗口上。可以用鼠标拉伸。</p><p>若为1，窗口以图像大小进行调整（即使先前设置过窗口大小），也会根据图像大小进行调整，且不可拉伸。</p><p><em>*</em>使用了这个函数后，即使没有图像指针，在编译完成后也会生成一个窗口（灰色）。</p><p>关于cvResizeWindow(需要注意，这个函数是用来改变窗口大小的，而非改变图像大小。之所以看似图像大小也改变了，实际上是因为在NamedWindow参数里，设置为图像根据窗口进行调整。换句话说，它的原理是通过改变窗口大小——让图像跟着窗口变化——进而改变图像大小，而非直接改变图像大小。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvResizeWindow( const char* name, int width, int height );</span><br></pre></td></tr></table></figure><ul><li><p>name </p><p>将被设置窗口的名字。</p></li><li><p>width </p><p>新的窗口宽度。</p></li><li><p>height </p><p>新的窗口高度。</p></li></ul><p>函数cvResizeWindow改变窗口的大小。</p><p>如果想要直接改变图像大小，需要resize函数或者图像金字塔pyrDown,pyrUp(不改变长宽比，一次面积放大4倍或者缩小4分之一）</p><p>以下为转载：</p><hr><p>OpenCV改变图像大小的操作有两类：resize与图像金字塔，但是这两类操作差别还是比较大的。</p><p>一、resize</p><p>函数原型</p><p>void resize(InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR )</p><p>各个参数的意义比较直观，但是需要注意的是dsize与fx和fy必须不能同时为零，也就是说要么dsize不为零而fx与fy同时可以为0，要么dsize为0而fx与fy不同时为0；resize函数的目标大小可以是任意的大小，可以不保持长宽比率，删除的像素或者新增的像素值通过interpolation（内插）控制；</p><p>二、图像金字塔</p><p>pyrDown与pyrUp分别表示向下降采样与向上升采样，但是二者并不是互为逆操作；</p><p>void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize=Size(), int border-</p><p>Type=BORDER_DEFAULT )</p><p>void pyrUp(InputArray src, OutputArray dst, const Size&amp; dstsize=Size(), int border-</p><p>Type=BORDER_DEFAULT )</p><p>这两个操作实现图像金字塔的经典操作，他们仅仅是分别代表一次采样操作，也就是说，向下(或者向上)进行相邻层次的金字塔采样，调用一次pyrDown函数只能降低到原图像尺寸的1/2;反之，调用pyrUp目标图像则为原图像尺寸的2倍。因为它们内部都给定了一次采样尺寸的约束。也就是说采样之后，长宽比基本是不变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void ResizeDemo()</span><br><span class="line">&#123;</span><br><span class="line">         Mat img1=imread(&quot;person_org.jpg&quot;);</span><br><span class="line">         Mat img2;</span><br><span class="line">//将原图像变为32*32，长宽比被改变了</span><br><span class="line">         resize(img1,img2,Size(32,32),0,0,CV_INTER_LINEAR);</span><br><span class="line">         namedWindow(&quot;WindowOrg&quot;);</span><br><span class="line">         namedWindow(&quot;WindowNew&quot;);</span><br><span class="line">         imshow(&quot;WindowOrg&quot;,img1);</span><br><span class="line">         imshow(&quot;WindowNew&quot;,img2);</span><br><span class="line"> </span><br><span class="line">         waitKey(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">IplImage *Image;</span><br><span class="line">IplImage *NewImage;</span><br><span class="line">Image = cvLoadImage(&quot;D:\\1234.jpg&quot;,1);</span><br><span class="line"></span><br><span class="line">CvSize sz;</span><br><span class="line">sz = cvGetSize(Image);</span><br><span class="line">sz.height /= 2;</span><br><span class="line">sz.width /= 2;</span><br><span class="line">//if pyrup,</span><br><span class="line">//sz.height*=2;</span><br><span class="line">//sz.width*=2;</span><br><span class="line">//setting height and width.</span><br><span class="line"></span><br><span class="line">NewImage = cvCreateImage(sz,IPL_DEPTH_8U, 3);</span><br><span class="line">//Create Image</span><br><span class="line"></span><br><span class="line">cvPyrDown(Image, NewImage, 7);</span><br><span class="line">//cvPryup(Image,NewImage,7);</span><br><span class="line">//若使用这个函数，需要事先建立好一个尺寸为原图一半的图并用IplImage指针指向它.7相当于CV_GAUSSIAN_5x5.</span><br><span class="line"></span><br><span class="line">cvNamedWindow(&quot;graph1&quot;, 1);</span><br><span class="line">cvNamedWindow(&quot;graph2&quot;, 1);</span><br><span class="line">cvShowImage(&quot;graph1&quot;, Image);</span><br><span class="line">cvShowImage(&quot;graph2&quot;, NewImage);</span><br><span class="line">cvWaitKey(0);</span><br><span class="line">cvDestroyAllWindows();</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：resize可以一次性将原图像变为任意不为0的尺寸，适合用来做归一化图像操作；而pyrDown与pyrUp适合做长宽比率不变得操作，且调用一次只能长和宽只能变为原来的1/2或者2倍，也即是说面积变为原来的1/4或者4倍。</p><p>转载自<a href="http://blog.sina.com.cn/s/blog_4b0020f30101cgok.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b0020f30101cgok.html</a></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.void cvShowImage( const char* name, const CvArr* image );</span><br></pre></td></tr></table></figure><p>Example:</p><p>cvShowImage(“Image”,p);</p><p>函数cvShowImage 在指定窗口中显示图像.如果窗口创建的时候被设定标志CV_WINDOW_AUTOSIZE,</p><p>那么图像将以原始尺寸显示；否则，图像将被伸缩以适合窗口大小.</p><p>一条语句只显示一次图像，若后面的语句没有cvWaitKey(0)的话，图像一闪而过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.cvWaitKey(delay)</span><br></pre></td></tr></table></figure><p>Example:</p><p>cvWaitKey(0);</p><p>函数的功能是不断刷新图像，频率时间为delay，单位为ms。</p><p>delay为&lt;=0时，无限制等待按键。按键后（在显示出的图片里进行按键），才执行WaitKey之后的语句。另外注意WaitKey单位为毫秒！它的功能可以理解为延时X毫秒后，执行接下来的语句。</p><p>函数cvWaitKey无限制的等待按键事件（delay&lt;=0时）；或者延迟”delay”毫秒。返回值为被按键的值，如果超过指定时间则返回-1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.void cvDestroyWindow( const char* name );</span><br></pre></td></tr></table></figure><p>Example;</p><p>cvDestroyWindow(“Image”);</p><p>销毁指定窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.cvReleaseImage(&amp;p);//销毁指针</span><br></pre></td></tr></table></figure><p>cvReleaseImage函数只是将IplImage*型的变量值赋为NULL，而这个变量本身还是存在的并且在内存中的存储位置不变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.void cvMoveWindow( const char* name, int x, int y );</span><br></pre></td></tr></table></figure><p>设定窗口的位置。</p><p>name 将被设置的窗口的名字。</p><p>x 窗口左上角的x坐标。</p><p>y 窗口左上角的y坐标。</p><p>函数cvMoveWindow改变窗口的位置。</p><p>cvActionTargetMod()</p><p>Example:</p><p> cv</p><p>Get</p><p>2D</p><p> cv</p><p>Create</p><p>Image</p><p> cv</p><p>Name</p><p>Window</p><p>CV_bitdepth()</p><p>S=符号整型</p><p>U=无符号整型</p><p>F=浮点型</p><p>CV_8（位数）U（类型）G（矩阵）1（通道） 一个8位无符号整形单通道矩阵</p><p>CV_32FG2 32位浮点型双通道矩阵</p><p>图像数据类型：</p><p>IPL<em>DEPTH</em><bit_depth>(S|U|F)</bit_depth></p><p>IPL_DEPTH_8U 8位无符号整型</p><p>头文件：</p><cv.h><cvaux.h><highgui.h><ml.h><cxcore.h><p>基础结构：</p><ul><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint" target="_blank" rel="noopener">1 CvPoint</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint2D32f" target="_blank" rel="noopener">2 CvPoint2D32f</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint3D32f" target="_blank" rel="noopener">3 CvPoint3D32f</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSize" target="_blank" rel="noopener">4 CvSize</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSize2D32f" target="_blank" rel="noopener">5 CvSize2D32f</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvRect" target="_blank" rel="noopener">6 CvRect</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvScalar" target="_blank" rel="noopener">7 CvScalar</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvTermCriteria" target="_blank" rel="noopener">8 CvTermCriteria</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvMat" target="_blank" rel="noopener">9 CvMat</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvMatND" target="_blank" rel="noopener">10 CvMatND</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSparseMat" target="_blank" rel="noopener">11 CvSparseMat</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#IplImage" target="_blank" rel="noopener">12 IplImage</a></li><li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvArr" target="_blank" rel="noopener">13 CvArr</a></li></ul><p>其中，CvPoint为二维坐标点整型，2D32F为2维浮点型，以此类推。</p><p>CyScalar是一个颜色结构体类，有四个数组元素，分别代表R,G,B,第四个元素通常用来表示透明色.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CvScalar</span><br><span class="line"> &#123;</span><br><span class="line">  double val[4]</span><br><span class="line"> &#125;</span><br><span class="line"> CvScalar;</span><br></pre></td></tr></table></figure><p>扩展——</p><p>其中Cvpoint</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inline CvPoint cvPoint( int x, int y );</span><br><span class="line">inline CvPoint cvPointFrom32f( CvPoint2D32f point )</span><br></pre></td></tr></table></figure><p>分别作用为：返回一个cvPoint值，</p><p>将一个2D32f值转换为cvPoint值并返回。</p><p>函数原型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvLine( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure><p>功能：绘制连接两个点的线段</p><ul><li><p>img 图像。</p></li><li><p>pt1 线段的第一个端点。</p></li><li><p>pt2 线段的第二个端点。</p></li><li><p>color 线段的颜色。</p></li><li><p>thickness 线段的粗细程度。</p></li><li><p>line_type 线段的类型。</p><p>8 (or 0) - 8-connected line（8邻接)连接 线。</p><p>4 - 4-connected line(4邻接)连接线。</p><p>CV_AA - antialiased 线条。</p></li></ul><p>shift 坐标点的小数点位数。</p><p>函数cvLine 在图像中的点1和点2之间画一条线段。线段被图像或感兴趣的矩形(ROI rectangle)所裁剪。对于具有整数坐标的non-antialiasing 线条，使用8-连接或者4-连接Bresenham 算法。画粗线条时结尾是圆形的。画 antialiased 线条使用高斯滤波。要指定线段颜色，用户可以使用使用宏CV_RGB( r, g, b )。</p><p>而且指定线条颜色的时候用到的宏CV_RGB(r，g，b)定义为#define CV_RGB( r, g, b ) cvScalar( (b), (g), (r), 0 )，由此可见，实际上起作用的颜色是看cvScalar中的b，g，r顺序，线段颜色就不言而喻了</p><p>利用CvScalar，CvLine画线:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// qwsds.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;highgui.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">CvPoint pt1;</span><br><span class="line">pt1=cvPoint(100,200);</span><br><span class="line">printf(&quot;x:%d,y:%d\n&quot;,pt1.x,pt1.y);</span><br><span class="line"></span><br><span class="line">CvPoint pt2;</span><br><span class="line">pt2=cvPoint(200,320);</span><br><span class="line">printf(&quot;x:%d,y:%d\n&quot;,pt2.x,pt2.y);</span><br><span class="line"></span><br><span class="line">CvScalar color;</span><br><span class="line">color=cvScalar(100,0,200);//蓝 绿 红。RGB</span><br><span class="line">printf(&quot;v1:%f v2:%f v3:%f\n&quot;,color.val[0],color.val[1],color.val[2]);</span><br><span class="line"></span><br><span class="line">IplImage *img=0;</span><br><span class="line">img=cvLoadImage(&quot;D:\\Blue hills.jpg&quot;);</span><br><span class="line"></span><br><span class="line">cvLine(img,pt1,pt2,color,2);</span><br><span class="line"></span><br><span class="line">cvNamedWindow(&quot;draw&quot;);</span><br><span class="line"></span><br><span class="line">cvShowImage(&quot;draw&quot;,img);</span><br><span class="line"></span><br><span class="line">cvWaitKey();</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/pre&gt;&lt;pre code_snippet_id=&quot;421021&quot; snippet_file_name=&quot;blog_20140707_14_8402014&quot; name=&quot;code&quot; class=&quot;cpp&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;CvLine&lt;/span&gt;&lt;/strong&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void cvLine( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color,</span><br><span class="line">             int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure><ul><li><p>img</p><p>图像。</p></li><li><p>pt1</p><p>线段的第一个端点。</p></li><li><p>pt2</p><p>线段的第二个端点。</p></li><li><p>color</p><p>线段的颜色。</p></li><li><p>thickness</p><p>线段的粗细程度。</p></li><li><p>line_type</p><p>线段的类型。8 (or 0) - 8-connected line（8邻接)连接 线。4 - 4-connected line(4邻接)连接线。CV_AA - antialiased 线条。</p></li></ul><ul><li><p>shift</p><p>坐标点的小数点位数。</p></li></ul><p>函数cvLine 在图像中的点1和点2之间画一条线段。线段被图像或感兴趣的矩形(ROI rectangle)所裁剪。对于具有整数坐标的non-antialiasing 线条，使用8-连接或者4-连接Bresenham 算法。画粗线条时结尾是圆形的。画 antialiased 线条使用高斯滤波。要指定线段颜色，用户可以使用使用宏CV_RGB( r, g, b )。</p><p>CvSize sz;</p><p>设置一个矩形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CvSize sz;</span><br><span class="line">sz=cvSize(640,480);</span><br><span class="line">printf(&quot;width:%d,height:%d\n&quot;,sz.width,sz.height);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IplImage *p;</span><br><span class="line">p=cvCreateImage(sz,IPL_DEPTH_8U,3);//sz矩形的宽，高（将结构体传进去）,深度,颜色通道数）</span><br><span class="line">cvNamedWindow(&quot;Image&quot;);</span><br><span class="line">cvShowImage(&quot;Image&quot;,p);</span><br><span class="line">cvWaitKey(0);</span><br></pre></td></tr></table></figure><p>其中cvCreateImage创建了一个矩形！</p><p>CvRect矩阵框的偏移量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CvRect</span><br><span class="line"> &#123;</span><br><span class="line">  int x; /* 方形的最左角的x-坐标  */</span><br><span class="line">  int y; /* 方形的最上或者最下角的y-坐标 */</span><br><span class="line">  int width; /* 宽 */</span><br><span class="line">  int height; /* 高 */</span><br><span class="line"> &#125;</span><br><span class="line"> CvRect;</span><br></pre></td></tr></table></figure><p>应用：（利用了CvRectangle）</p><p>CvRectangle：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void cvRectangle( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color,</span><br><span class="line">                  int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure><ul><li><p>img</p><p>图像.</p></li><li><p>pt1</p><p>矩形的一个顶点。</p></li><li><p>pt2</p><p>矩形对角线上的另一个顶点</p></li><li><p>color</p><p>线条颜色 (RGB) 或亮度（灰度图像 ）(grayscale image）。</p></li><li><p>thickness</p><p>组成矩形的线条的粗细程度。取负值时（如 CV_FILLED）函数绘制填充了色彩的矩形。</p></li><li><p>line_type</p><p>线条的类型。见cvLine的描述</p></li><li><p>shift</p><p>坐标点的小数点位数。</p></li></ul><p>函数 cvRectangle 通过对角线上的两个顶点绘制矩形。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;highgui.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">CvSize sz;//CvSize 数据类型 C大写,定义。</span><br><span class="line">sz=cvSize(640,480);//给sz赋值。</span><br><span class="line">printf(&quot;width:%d,height:%d\n&quot;,sz.width,sz.height);</span><br><span class="line">IplImage *img=0;</span><br><span class="line">img=cvCreateImage(sz,IPL_DEPTH_8U,3);//创建而不是载入。</span><br><span class="line">CvRect rect;</span><br><span class="line">rect=cvRect(50,30,100,150);//左上坐标，长度，宽度。</span><br><span class="line">CvPoint pt1=cvPoint(rect.x,rect.y);</span><br><span class="line">CvPoint pt2=cvPoint(rect.x+rect.width,rect.y+rect.height);</span><br><span class="line">cvRectangle(img,pt1,pt2,cvScalar(0,0,255),2);</span><br><span class="line">cvNamedWindow(&quot;create&quot;);</span><br><span class="line">cvShowImage(&quot;create&quot;,img);</span><br><span class="line">cvWaitKey();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中cvRectangle利用apt1,apt2两个点，和颜色方案cvScalar，以及粗细程度2，将绘制的矩形传递给指针p2,然后在建立的图案区域AAA内显示矩形。</p><p>复制图像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IplImage *mp1=cvCloneImage(img);//把图像img复制给mp1.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;para&quot; style=&quot;margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif; font-size:14px&quot;&gt;&lt;pre code_snippet_id=&quot;421021&quot; snippet_file_name=&quot;blog_20140707_20_810661&quot; name=&quot;code&quot; class=&quot;cpp&quot; style=&quot;color: rgb(51, 51, 51);&quot;&gt;cvNamedWindow(&quot;create&quot;);</span><br><span class="line">cvShowImage(&quot;create&quot;,img);//img需要事先指向图像</span><br><span class="line">IplImage *p2=cvCloneImage(img);</span><br><span class="line">cvNamedWindow(&quot;clone&quot;);</span><br><span class="line">cvShowImage(&quot;clone&quot;,p2);</span><br><span class="line">cvWaitKey();</span><br></pre></td></tr></table></figure><p>​      保存图像到文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int cvSaveImage( const char* filename, const CvArr* image );</span><br></pre></td></tr></table></figure><ul><li><p>filename </p><p>文件名，如果对应的文件已经存在，则将被复盖。</p></li><li><p>image </p><p>要保存的图像。</p></li></ul><p>函数cvSaveImage保存图像到指定文件。图像格式的的选择依赖于filename的扩展名，请参考cvLoadImage。只有8位单通道或者3通道（通道顺序为’BGR’ ）可以使用这个函数保存。如果格式，深度或者通道不符合要求，请先用cvCvtScale 和cvCvtColor转换；或者使用通用的cvSave保存图像为XML或者YAML格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     IplImage * test=NULL;</span><br><span class="line">     test = cvLoadImage (&quot;D:\\demo.jpg&quot;);</span><br><span class="line">     cvNamedWindow(&quot;test_demo&quot;,1);</span><br><span class="line"> cvMoveWindow(&quot;test_demo&quot;,800,10);</span><br><span class="line">     cvShowImage(&quot;test_demo&quot;,test);</span><br><span class="line"> cvSaveImage(&quot;D:\\123.jpg&quot;,test);</span><br><span class="line">     cvWaitKey(0);</span><br><span class="line">     cvDestroyWindow(&quot;test_demo&quot;);</span><br><span class="line">     cvReleaseImage(&amp;test);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：<br>OpenCV里有两个单词，Image，Window，它们各自代表的是载入的图像(用IplImage指针表示)，放置图像的窗口。<br>1.在存在Window的前提下,即cvNamedWindow(“窗口名”,是否根据Image进行调整的指标.)，<br>2.让IplImage指针指向Image,即cvLoadImage(“Image”,指针名).除去载入的方法外,也可以创建:<br>(1).定义一个CvSize类型的矩形sz.<br>(2).赋予其宽,高.sz=CvSize(640,480)<br>(3).p=cvCreateImage(sz,IPL_DEPTH_8U,3).第二个参数为深度,例为8位无符号整型,3通道.<br>3.再将Image导入Window，才能让Image显示出来,即cvShowImage(Window,image的指针).</p><p>另外，除了必要的知识外，大部分函数在使用的时候可以直接在博客开头的Page手册里查阅使用方案，系统全面的文档提供了很高的支持。感觉和Linux查阅技术文档来进行操作有些相同之处。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#iclude&lt;stdio.h&gt;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">FILE *fp;                  /*定义一个文件指针*/</span><br><span class="line">int i;</span><br><span class="line">fp=fopen(&quot;CLIB&quot;, &quot;rb&quot;);    /*打开当前目录名为CLIB的文件只读*/ </span><br><span class="line">if(fp==NULL)               /*判断文件是否打开成功*/</span><br><span class="line">puts(&quot;File open error&quot;);/*提示打开不成功*/</span><br><span class="line">i=fclose(fp);              /*关闭打开的文件*/</span><br><span class="line">if(i==0)                   /*判断文件是否关闭成功*/</span><br><span class="line">printf(&quot;O.K&quot;);           /*提示关闭成功*/</span><br><span class="line">else                </span><br><span class="line">puts(&quot;File close error&quot;);/*提示关闭不成功*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> int fprintf(FILE <em>stream, char </em>format, <variable-list>);<br>​        int fputs(char <em>string, FILE </em>steam);<br>int fputc(intch, FILE *steam);<br>fprintf() 函数的返回值为实际写入文件中的字符个数(字节数)。如果写错误, 则返回一个负数； fputs()函数返回0时表明将string指针所指的字符串写入文件中的操作成功, 返回非0时,表明写操作失败。  fputc()函数返回一个向文件所写字符的值, 此时写操作成功,否则返回EOF(文件结束结束其值为-1, 在stdio.h中定义)表示写操作错误。   fprintf( ) 函数中格式化的规定与printf( ) 函数相同,所不同的只是fprintf()函数是向文件中写入。而printf()是向屏幕输出。<br>4.文件的顺序读操作函数<br>​        fscanf()、fgets()和fgetc()函数<br>函数fscanf()、fgets()和fgetc()均为文件的顺序读操作函数, 其调用格式 如下:</variable-list></p><p>int fscanf(FILE <em>stream, char </em>format, <address-list>);<br>​        char fgets(char <em>string, int n, FILE </em>steam);<br>​        int fgetc(FILE *steam);<br>fscanf()函数的用法与scanf()函数相似,只是它是从文件中读到信息。 fscanf()函数的返回值为EOF(即-1), 表明读错误, 否则读数据成功。  fgets()函数从文件中读取至多n-1个字符(n用来指定字符数), 并把它们放入string指向的字符串中, 在读入之后自动向字符串未尾加一个空字符, 读成功返回string指针,  失败返回一个空指针。  fgetc()函数返回文件当前位置的一个字符,读错误时返回EOF。 </address-list></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void cvSmooth( const CvArr* src, CvArr* dst,</span><br><span class="line">               int smoothtype=CV_GAUSSIAN,</span><br><span class="line">               int param1=3, int param2=0, double param3=0, double param4=0 );</span><br></pre></td></tr></table></figure><ul><li><p>src</p><p>输入图像.</p></li><li><p>dst</p><p>输出图像.</p></li><li><p>smoothtype</p><p>平滑方法:CV_BLUR_NO_SCALE (简单不带尺度变换的模糊) - 对每个象素的 param1×param2 领域求和。如果邻域大小是变化的，可以事先利用函数 cvIntegral 计算积分图像。CV_BLUR (simple blur) - 对每个象素param1×param2邻域 求和并做尺度变换 1/(param1•param2).CV_GAUSSIAN (gaussian blur) - 对图像进行核大小为 param1×param2 的高斯卷积CV_MEDIAN (median blur) - 对图像进行核大小为param1×param1 的中值滤波 (i.e. 邻域是方的).CV_BILATERAL (双向滤波) - 应用双向 3x3 滤波，彩色 sigma=param1，空间 sigma=param2. 关于双向滤波，可参考<a href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html" target="_blank" rel="noopener">http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a></p></li></ul><ul><li><p>param1</p><p>平滑操作的第一个参数.</p></li><li><p>param2</p><p>平滑操作的第二个参数. 对于简单/非尺度变换的高斯模糊的情况，如果param2的值 为零，则表示其被设定为param1。</p></li><li><p>param3</p><p>对应高斯参数的 Gaussian sigma (标准差). 如果为零，则标准差由下面的核尺寸计算：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigma = (n/2 - 1)*0.3 + 0.8, 其中 n=param1 对应水平核,</span><br><span class="line">                                 n=param2 对应垂直核.</span><br></pre></td></tr></table></figure><p>对小的卷积核 (3×3 to 7×7) 使用如上公式所示的标准 sigma 速度会快。如果 param3 不为零，而 param1 和 param2 为零，则核大小有 sigma 计算 (以保证足够精确的操作).</p><p>函数 cvSmooth 可使用上面任何一种方法平滑图像。每一种方法都有自己的特点以及局限。</p><p>没有缩放的图像平滑仅支持单通道图像，并且支持8位到16位的转换(与cvSobel和cvaplace相似)和32位浮点数到32位浮点数的变换格式。</p><p>简单模糊和高斯模糊支持 1- 或 3-通道, 8-比特 和 32-比特 浮点图像。这两种方法可以（in-place）方式处理图像。</p><p>中值和双向滤波工作于 1- 或 3-通道， 8-位图像，但是不能以 in-place 方式处理图像.</p><ul><li><p>中值滤波</p><p>中值滤波法是一种非线性平滑技术，它将每一象素点的灰度值设置为该点某邻域窗口内的所有象素点灰度值的中值。实现方法：</p></li></ul><ol><li>通过从图像中的某个采样窗口取出奇数个数据进行排序</li><li>用排序后的中值取代要处理的数据即可</li></ol><p>中值滤波法对消除椒盐噪音非常有效，在光学测量条纹图象的相位分析处理方法中有特殊作用，但在条纹中心分析方法中作用不大。中值滤波在图像处理中,常用于用来保护边缘信息,是经典的平滑噪声的方法</p><ul><li>中值滤波原理</li></ul><p>中值滤波是基于排序统计理论的一种能有效抑制噪声的非线性信号处理技术，中值滤波的基本原理是把数字图像或数字序列中一点的值用该点的一个拎域中各点值的中值代替，让周围的像素值接近的值，从而消除孤立的噪声点。方法是去某种结构的二维滑动模板，将板内像素按照像素值的大小进行排序，生成单调上升（或下降）的为二维数据序列。二维中值滤波输出为g（x,y）=med{f(x-k,y-l),(k,l∈W)} ，其中,f(x,y)，g(x,y)分别为原始图像和处理后图像。W为二维模板，通常为2<em>2，3</em>3区域，也可以是不同的的形状，如线状，圆形，十字形，圆环形等。</p><ul><li>高斯滤波</li></ul><p>高斯滤波实质上是一种信号的滤波器，其用途是信号的平滑处理，我们知道数字图像用于后期应用，其噪声是最大的问题，由于误差会累计传递等原因，很多图像处理教材会在很早的时候介绍Gauss滤波器，用于得到信噪比SNR较高的图像（反应真实信号）。于此相关的有Gauss-Lapplace变换，其实就是为了得到较好的图像边缘，先对图像做Gauss平滑滤波，剔除噪声，然后求二阶导矢，用二阶导的过零点确定边缘，在计算时也是频域乘积=&gt;空域卷积。</p><p>滤波器就是建立的一个数学模型，通过这个模型来将图像数据进行能量转化，能量低的就排除掉，噪声就是属于低能量部分</p><p>其实编程运算的话就是一个模板运算，拿图像的八连通区域来说，中间点的像素值就等于八连通区的像素值的均值，这样达到平滑的效果</p><p>若使用理想滤波器，会在图像中产生振铃现象。采用高斯滤波器的话，系统函数是平滑的，避免了振铃现象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例程序：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">IplImage *p = cvLoadImage(&quot;D:\\1234.jpg&quot;, 1);</span><br><span class="line">IplImage *out = cvCreateImage(cvGetSize(p), IPL_DEPTH_8U, 3);</span><br><span class="line">cvNamedWindow(&quot;cv_in&quot;, 1);</span><br><span class="line">cvNamedWindow(&quot;cv_out&quot;, 1);</span><br><span class="line"></span><br><span class="line">cvShowImage(&quot;cv_in&quot;, p);</span><br><span class="line">cvWaitKey(1024);</span><br><span class="line"></span><br><span class="line">cvSmooth(p, out, CV_GAUSSIAN, 3, 3);//from head file &lt;cv.h&gt;.</span><br><span class="line">cvShowImage(&quot;cv_out&quot;, out);</span><br><span class="line">cvWaitKey(1024);</span><br><span class="line"></span><br><span class="line">//cvReleaseImage(&amp;p);</span><br><span class="line">cvReleaseImage(&amp;out);</span><br><span class="line">//加上上述两行就会报错，原因：</span><br><span class="line">/*</span><br><span class="line">在写相关程序的时候，在程序的结尾处释放前段自定义的变量。使用函数cvReleaseImage(&amp;pFrame);时程序在调试结束后报错，</span><br><span class="line">指明是在释放内存时出错。经过看前辈们遇到的相同的问题。先总结如下：</span><br><span class="line"></span><br><span class="line">    cvReleaseImage()和cvCreateImage()相对应的。在程序中如果没有“创建”就不能“释放”。</span><br><span class="line">所以，如果我们使用的指针不是用cvCreateImage()创建的。</span><br><span class="line">如果使用cvReleaseImage()就会出现错误。如果大家担心指针不释放会引发内存的错误。</span><br><span class="line">可以使用pFrame = NULL;来释放内存。</span><br><span class="line">因为cvReleaseImage()的作用就是将作为参数的那个指针设置为NULL;</span><br><span class="line"></span><br><span class="line">如修改后，只ReleaseOUT就不会出错.</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">cvDestroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CvCapture 视频获取结构</span><br></pre></td></tr></table></figure><h2 id="cvCreateFileCapture"><a href="#cvCreateFileCapture" class="headerlink" title="cvCreateFileCapture"></a>cvCreateFileCapture</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CvCapture* cvCreateFileCapture( const char* filename );</span><br></pre></td></tr></table></figure><ul><li><p>filename </p><p>视频文件名。</p></li></ul><p>函数cvCreateFileCapture给指定文件中的视频流分配和初始化CvCapture结构。</p><p>当分配的结构不再使用的时候，它应该使用cvReleaseCapture函数释放掉。</p><h2 id="cvReleaseCapture"><a href="#cvReleaseCapture" class="headerlink" title="cvReleaseCapture"></a>cvReleaseCapture</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvReleaseCapture( CvCapture** capture );</span><br></pre></td></tr></table></figure><ul><li><p>capture </p><p>视频获取结构指针。</p></li></ul><p>函数cvReleaseCapture释放由函数cvCreateFileCapture或者cvCreateCameraCapture分配的CvCapture结构。</p><p>注:若从capture中使用cvQueryFrame获取图像指针，在releaseCapture的时候同时函数释放图像指针，用户不用再自己释放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">IplImage *p; </span><br><span class="line">CvCapture *capture = cvCreateFileCapture(&quot;D:\\123.avi&quot;);</span><br><span class="line">cvNamedWindow(&quot;Image&quot;, 1);</span><br><span class="line">while (1)</span><br><span class="line">&#123;</span><br><span class="line">p = cvQueryFrame(capture);</span><br><span class="line">if (!p)</span><br><span class="line">break;//if can&apos;t load image,p is NULL,and break.</span><br><span class="line">cvShowImage(&quot;Image&quot;, p);</span><br><span class="line">char c = cvWaitKey(1024);</span><br><span class="line">if (c == 27)</span><br><span class="line">break;//if you press Esc,c will get 27.</span><br><span class="line">&#125;</span><br><span class="line">cvReleaseCapture(&amp;capture);</span><br><span class="line">cvReleaseImage(&amp;p);</span><br><span class="line">cvDestroyWindow(Image);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像像素的获取：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 访问图像像素.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//way:</span><br><span class="line">//IplImage *Img = cvCreateImage(cvSize(640, 580), IPL_DEPTH_8U, 3);</span><br><span class="line">//1.间接访问:get*D,set*D...</span><br><span class="line">//2.直接访问:((*uchar)ImageData+i*Image-&gt;width)[j]=111;</span><br><span class="line">/*</span><br><span class="line">单通道：</span><br><span class="line">IplImage*img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,1);</span><br><span class="line">int height     =img-&gt;height; </span><br><span class="line">int width=img-&gt;width;  </span><br><span class="line">int step       =img-&gt;widthStep/sizeof(uchar); </span><br><span class="line">uchar* data    =(uchar*)img-&gt;imageData; </span><br><span class="line">data[i*step+j]=111;</span><br><span class="line">多通道：</span><br><span class="line">IplImage*img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,3);  </span><br><span class="line">int height     =img-&gt;height; </span><br><span class="line">int width      =img-&gt;width;  </span><br><span class="line">int step       =img-&gt;widthStep/sizeof(uchar); </span><br><span class="line">int channels   =img-&gt;nChannels;  </span><br><span class="line">uchar* data    =(uchar*)img-&gt;imageData; </span><br><span class="line">data[i*step+j*channels+k]=111;</span><br><span class="line">如果为浮点型矩阵，而非字节型，那就把uchar改为float.</span><br><span class="line">*/</span><br><span class="line">//3.利用宏:CV_IMAGE_ELEM</span><br><span class="line">//单通道:CV_IMAGE_ELEM(img,uchar,i,j)=111; img为IplImage指针</span><br><span class="line">//多通道:CV_IMAGE_ELEM(srcimg,uchar,i,j*3+0)=111;</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">IplImage *Image = cvCreateImage(cvSize(640,480), IPL_DEPTH_8U, 3);</span><br><span class="line">CvScalar color;</span><br><span class="line">int i, j;</span><br><span class="line">for (i = 0; i &lt; 50; i++)//循环使i*j区域内的点全部变为黑色.</span><br><span class="line">&#123;</span><br><span class="line">for (j = 50; j &lt; 100; j++)</span><br><span class="line">&#123;</span><br><span class="line">color = cvGet2D(Image, i, j);//get(x,y)&apos;s color.cal[0],color.cal[1].</span><br><span class="line"></span><br><span class="line">//printf(&quot;cal0:%d\ncal1:%d\ncal2:%d\n&quot;, color.val[0], color.val[1], color.val[2]);</span><br><span class="line">//若为单通道图像，只修改color.val[0]即可.</span><br><span class="line">color.val[0] = 0;</span><br><span class="line">color.val[1] = 0;</span><br><span class="line">color.val[2] = 0;</span><br><span class="line">cvSet2D(Image, i, j, color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cvNamedWindow(&quot;ImageA&quot;, 1);</span><br><span class="line">cvShowImage(&quot;ImageA&quot;, Image);</span><br><span class="line">cvWaitKey(0);</span><br><span class="line">cvDestroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而cvSetXD中，固定参数为IplImage指针，X个Int类型的参数表示图上的坐标，以及可以将每个坐标的颜色分配修改的Scalar类。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像的边缘检测（根据像素梯度）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">IplImage *Image;</span><br><span class="line">IplImage *out;</span><br><span class="line">Image = cvLoadImage(&quot;D:\\1234.jpg&quot;, 0);</span><br><span class="line">out = cvCreateImage(cvGetSize(Image), IPL_DEPTH_8U, 1);</span><br><span class="line">cvNamedWindow(&quot;ImageA&quot;, 1);</span><br><span class="line">cvNamedWindow(&quot;ImageB&quot;, 1);</span><br><span class="line">cvCanny(Image, out, 50, 75, 3);</span><br><span class="line">//cvCanny的第一个第二个参数均为指向单通道图片的IplImage.</span><br><span class="line">//第三,第四个参数为阀值，一个大一个小，应当根据图像的梯度设定.</span><br><span class="line">//第五个参数为canny算子3.</span><br><span class="line">cvShowImage(&quot;ImageB&quot;, out);</span><br><span class="line">cvWaitKey(0);</span><br><span class="line">cvDestroyAllWindows();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>canny算子实质：如果一个像素的梯度大与上限值，则被认为是边缘像素，如果小于下限阈值，则被抛弃，那么如果该点的梯度位于两者之间，则当其与高于上限值的像素点连接时我们才保留，否则删除。另：当两个阀值等比例同时增大时（比如从50，150增加到100，300，比例并未改变），则图像上的杂点变少（边缘更加清晰）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于梯度的计算：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用自：http://www.cnblogs.com/justany/archive/2012/11/23/2782660.html</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像的边缘图像的边缘从数学上是如何表示的呢？图像的边缘上，邻近的像素值应当显著地改变了。而在数学上，导数是表示改变快慢的一种方法。梯度值的大变预示着图像中内容的显著变化了。用更加形象的图像来解释,假设我们有一张一维图形。下图中灰度值的“跃升”表示边缘的存在：　　　　使用一阶微分求导我们可以更加清晰的看到边缘“跃升”的存在(这里显示为高峰值)：　　　　由此我们可以得出：边缘可以通过定位梯度值大于邻域的相素的方法找到。 卷积卷积可以近似地表示求导运算。那么卷积是什么呢？卷积是在每一个图像块与某个算子（核）之间进行的运算。核？！核就是一个固定大小的数值数组。该数组带有一个锚点 ，一般位于数组中央。 可是这怎么运算啊？假如你想得到图像的某个特定位置的卷积值，可用下列方法计算：将核的锚点放在该特定位置的像素上，同时，核内的其他值与该像素邻域的各像素重合；将核内各值与相应像素值相乘，并将乘积相加；将所得结果放到与锚点对应的像素上；对图像所有像素重复上述过程。用公式表示上述过程如下：　　　　在图像边缘的卷积怎么办呢？计算卷积前，OpenCV通过复制源图像的边界创建虚拟像素，这样边缘的地方也有足够像素计算卷积了。 近似梯度比如内核为3时。首先对x方向计算近似导数：然后对y方向计算近似导数：然后计算梯度：当然你也可以写成：求梯度的例程序：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;#include &quot;opencv2/imgproc/imgproc.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int main( int argc, char** argv )&#123;</span><br><span class="line"></span><br><span class="line">    Mat src, src_gray;</span><br><span class="line">    Mat grad;</span><br><span class="line">    char* window_name = &quot;求解梯度&quot;;</span><br><span class="line">    int scale = 1;</span><br><span class="line">    int delta = 0;</span><br><span class="line">    int ddepth = CV_16S;</span><br><span class="line"></span><br><span class="line">    int c;</span><br><span class="line"></span><br><span class="line">    src = imread( argv[1] );</span><br><span class="line"></span><br><span class="line">    if( !src.data )&#123; </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //高斯模糊</span><br><span class="line">    GaussianBlur( src, src, Size(3,3), 0, 0, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">    //转成灰度图</span><br><span class="line">    cvtColor( src, src_gray, CV_RGB2GRAY );</span><br><span class="line"></span><br><span class="line">    namedWindow( window_name, CV_WINDOW_AUTOSIZE );</span><br><span class="line"></span><br><span class="line">    Mat grad_x, grad_y;</span><br><span class="line">    Mat abs_grad_x, abs_grad_y;</span><br><span class="line"></span><br><span class="line">    Sobel( src_gray, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_x, abs_grad_x );</span><br><span class="line"></span><br><span class="line">    Sobel( src_gray, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_y, abs_grad_y );</span><br><span class="line"></span><br><span class="line">    addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );</span><br><span class="line"></span><br><span class="line">    imshow( window_name, grad );</span><br><span class="line"></span><br><span class="line">    waitKey(0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>Sobel函数</p><blockquote><p>索贝尔算子（Sobel operator）计算。</p><ul><li>C++:<code></code>void <code>Sobel</code>(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize=3, double scale=1, double delta=0, intborderType=BORDER_DEFAULT )</li></ul></blockquote><p>代码注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在x方向求图像近似导数</span><br><span class="line">Sobel( src_gray, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">//在y方向求图像近似导数</span><br><span class="line">Sobel( src_gray, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT );</span><br></pre></td></tr></table></figure><p>如果我们打印上面两个输出矩阵，可以看到grad_x和grad_y中的元素有正有负。</p><p>当然，正方向递增就是正的，正方向递减则是负值。</p><p>这很重要，我们可以用来判断梯度方向。</p><p>convertScaleAbs函数</p><blockquote><p>线性变换转换输入数组元素成8位无符号整型。</p><ul><li>C++:<code></code>void <code>convertScaleAbs</code>(InputArray src, OutputArray dst, double alpha=1, double beta=0)</li></ul><p>对于每个输入数组的元素函数<code>convertScaleAbs</code> 进行三次操作依次是：缩放，得到一个绝对值，转换成无符号8位类型。</p><p><img src="http://docs.opencv.org/_images/math/5ca28093f0a8eca32bcf6d54a644b4bcaa07ad72.png" alt="\texttt{dst} (I)= \texttt{saturate\_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} +  \texttt{beta} |)"></p><p>对于多通道矩阵，该函数对各通道独立处理。如果输出不是8位，将调用<code>Mat::convertTo</code>方法并计算结果的绝对值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mat_&lt;float&gt; A(30,30);</span><br><span class="line">&gt; randu(A, Scalar(-100), Scalar(100));</span><br><span class="line">&gt; Mat_&lt;float&gt; B = A*5 + 3;</span><br><span class="line">&gt; B = abs(B);</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>为了能够用图像显示，提供一个直观的图形，我们利用该方法，将-256 — 255的导数值，转成0 — 255的无符号8位类型。</p><p>addWeighted函数</p><blockquote><p>计算两个矩阵的加权和。</p><ul><li>C++:<code></code>void <code>addWeighted</code>(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, intdtype=-1)</li></ul><p>函数<code>addWeighted</code> 两个数组的加权和公式如下：</p><p>　　　　<img src="http://docs.opencv.org/_images/math/160c3479896ac799bb5c7d260a052e6b35c463ef.png" alt="\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +  \texttt{gamma} )"></p><p>在多通道情况下，每个通道是独立处理的，该函数可以被替换成一个函数表达式：</p><p>　　　　dst = src1<em>alpha + src2</em>beta + gamma;</p></blockquote><p>利用convertScaleAbs和addWeighted，我们可以对梯度进行一个可以用图像显示的近似表达。</p><p>这样我们就可以得到下面的效果：</p><p><img src="http://docs.opencv.org/_images/Sobel_Derivatives_Tutorial_Result.jpg" alt="Result of applying Sobel operator to lena.jpg"></p><p>梯度方向</p><p>但有时候边界还不够，我们希望得到图片色块之间的关系，或者研究样本的梯度特征来对机器训练识别物体时候，我们还需要梯度的方向。</p><p>二维平面的梯度定义为：</p><p>　　　　<img src="http://pic002.cnblogs.com/images/2012/372204/2012112220142684.jpg" alt="img"></p><p>这很好理解，其表明颜色增长的方向与x轴的夹角。</p><p>但Sobel算子对于沿x轴和y轴的排列表示的较好，但是对于其他角度表示却不够精确。这时候我们可以使用Scharr滤波器。</p><p>Scharr滤波器的内核为：</p><p>　　　　<img src="http://docs.opencv.org/_images/math/d1340f7bb6665e67c94c196809095f23054fca2c.png" alt="G_{x} = \begin{bmatrix}-3 &amp; 0 &amp; +3  \\-10 &amp; 0 &amp; +10  \\-3 &amp; 0 &amp; +3\end{bmatrix}G_{y} = \begin{bmatrix}-3 &amp; -10 &amp; -3  \\0 &amp; 0 &amp; 0  \\+3 &amp; +10 &amp; +3\end{bmatrix}"></p><p>这样能提供更好的角度信息，现在我们修改原程序，改为使用Scharr滤波器进行计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;#include &quot;opencv2/imgproc/imgproc.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int main( int argc, char** argv )&#123;</span><br><span class="line"></span><br><span class="line">    Mat src, src_gray;</span><br><span class="line">    Mat grad;</span><br><span class="line">    char* window_name = &quot;梯度计算&quot;;</span><br><span class="line">    int scale = 1;</span><br><span class="line">    int delta = 0;</span><br><span class="line">    int ddepth = CV_16S;</span><br><span class="line"></span><br><span class="line">    int c;</span><br><span class="line"></span><br><span class="line">    src = imread( argv[1] );</span><br><span class="line"></span><br><span class="line">    if( !src.data )&#123; </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GaussianBlur( src, src, Size(3,3), 0, 0, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">    cvtColor( src, src_gray, CV_RGB2GRAY );</span><br><span class="line"></span><br><span class="line">    namedWindow( window_name, CV_WINDOW_AUTOSIZE );</span><br><span class="line"></span><br><span class="line">    Mat grad_x, grad_y;</span><br><span class="line">    Mat abs_grad_x, abs_grad_y;</span><br><span class="line"></span><br><span class="line">    //改为Scharr滤波器计算x轴导数</span><br><span class="line">    Scharr( src_gray, grad_x, ddepth, 1, 0, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_x, abs_grad_x );</span><br><span class="line"></span><br><span class="line">    //改为Scharr滤波器计算y轴导数</span><br><span class="line">    Scharr( src_gray, grad_y, ddepth, 0, 1, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_y, abs_grad_y );</span><br><span class="line"></span><br><span class="line">    addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );</span><br><span class="line"></span><br><span class="line">    imshow( window_name, grad );</span><br><span class="line"></span><br><span class="line">    waitKey(0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;&lt;/span&gt;&lt;strong style=&quot;font-size:24px;&quot;&gt;</span><br><span class="line">&lt;/strong&gt;</span><br></pre></td></tr></table></figure><p>Scharr函数接受参数与Sobel函数相似，这里就不叙述了。</p><p>下面我们通过divide函数就能得到一个x/y的矩阵。</p><blockquote><p>对两个输入数组的每个元素执行除操作。</p><ul><li>C++:<code></code>void <code>divide</code>(InputArray src1, InputArray src2, OutputArray dst, double scale=1, int dtype=-1)</li></ul><ul><li>C++:<code></code>void <code>divide</code>(double scale, InputArray src2, OutputArray dst, int dtype=-1)</li></ul><p>该函数对两个数组进行除法：</p><p>　　<img src="http://docs.opencv.org/_images/math/b95a5073fc087b8fc404bc7795982e1570891bd3.png" alt="\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}"></p><p>或则只是缩放系数除以一个数组：</p><p>　　<img src="http://docs.opencv.org/_images/math/8d762e1a527b3613404ec26a98faffd43d1ceb78.png" alt="\texttt{dst(I) = saturate(scale/src2(I))}"></p><p>这种情况如果src2是0，那么dst也是0。不同的通道是独立处理的。</p></blockquote></cxcore.h></ml.h></highgui.h></cvaux.h></cv.h>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="think" scheme="sherry0429.github.io/categories/think/"/>
    
    
      <category term="opencv" scheme="sherry0429.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1247 字典树</title>
    <link href="sherry0429.github.io/2018/02/11/HDU-1247-%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <id>sherry0429.github.io/2018/02/11/HDU-1247-字典树/</id>
    <published>2018-02-11T06:51:50.000Z</published>
    <updated>2018-02-12T03:19:49.689Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 26</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">NumTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    NumTree ans[MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NumTree <span class="title">init</span><span class="params">(NumTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    T=<span class="keyword">new</span> struct node;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;tag=<span class="number">0</span>;</span><br><span class="line">        T-&gt;ans[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T,S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            S=<span class="keyword">new</span> struct node;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                S-&gt;ans[j]=<span class="literal">NULL</span>;</span><br><span class="line">                S-&gt;tag=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q-&gt;ans[id]=S;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;tag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Stack;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;tag &amp;&amp; i&lt;len)<span class="comment">//find sepraste point</span></span><br><span class="line">        &#123;</span><br><span class="line">            Stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Stack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now=Stack.front();</span><br><span class="line">        now++;</span><br><span class="line">        <span class="keyword">bool</span> OK=<span class="literal">true</span>;</span><br><span class="line">        Stack.pop();</span><br><span class="line">        Q=T;</span><br><span class="line">        <span class="keyword">while</span>(str[now])</span><br><span class="line">        &#123;</span><br><span class="line">            id=str[now++]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(Q-&gt;ans[id]==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                OK=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(OK &amp;&amp; Q-&gt;tag)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">50011</span>][<span class="number">20</span>];</span><br><span class="line">    NumTree T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    T=init(T);</span><br><span class="line">    <span class="keyword">while</span>(gets(str[x]) &amp;&amp; str[x][<span class="number">0</span>]!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(T,str[x]);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>;u&lt;x;u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(find(T,str[u])==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;str[u]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞了一下午····</p><p>不得不说还是有一些收获，RE的次数最多，</p><p>这里要说一下，RE分两种，一种越界，一种是栈溢出，</p><p>这里在定义str的时候，</p><p>如果定义str[50001][100],就会栈溢出，可见字典树对字符长度的要求很高，不能太长。</p><p>整个代码的思路就是在insert同时的时候标记，一个字符如果是一个字符串的结尾字符，那么标记，</p><p>在find的时候，如果找到了一个标记，找到了A个标记，说明这个字符串里含有A个字符串，但无法确定这A个字符串是否是紧邻的，这里需要用STACK或者QUEUE，最好还是用STACK，依次记录有标记的下标，然后从后往前开始查询，</p><p>这里还有一个小细节，在查询的时候now++,因为top回来的now是一个字符的结尾，重新遍历的时候应该是从找到标记的字符的后一个字符开始。</p><p>然后如果有两个以上标记是怎么回事呢？</p><p>如果</p><p>abcdefg</p><p>1001001</p><p>有三个标记，这时候从最后一个1开始找，然后从倒数第二个1找，而这里的1代表，至少字典里有a,abcd,abcdefg三个字符串（也可能有defg,bcd等等），也就是说我从标记的下一个字符开始找起，标记的前半部分已经肯定在字符串里了（也就是组成该字符串的前半段），只需要证明从标记开始的字符串也在字典树里，那么就满足该字符串由两个字符串构成，输出即可。</p><p>这题还有一个思路，就是把每一个字符串在不同位置“砍一刀”，变成两个字符串，然后find(str1)find(str2),如果都能找到，那么就说明它（这个字符串）有两个字符串构成，这个代码我也实现了，但是不知道为什么一直RE，可能是迭代或者递归的层数太多了（find要递归，如果字符串很长的话，也要砍很多刀）。暂时我还没有想到比较好的优化方案。砍刀也许可以用二分查找实现，但那仍然依赖输入。对效率提升不一定十分明显。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 26</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">NumTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NumTree ans[MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NumTree <span class="title">init</span><span class="params">(NumTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    T=<span class="keyword">new</span> struct node;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">        T-&gt;ans[i]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T,S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            S=<span class="keyword">new</span> struct node;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX;j++)</span><br><span class="line">                S-&gt;ans[j]=<span class="literal">NULL</span>;</span><br><span class="line">            Q-&gt;ans[id]=S;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="keyword">int</span> tag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]!=<span class="literal">NULL</span>)</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(NumTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;ans[i]!=<span class="literal">NULL</span>)</span><br><span class="line">            FreeTree(T-&gt;ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">50011</span>][<span class="number">100</span>];</span><br><span class="line">    NumTree T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    T=init(T);</span><br><span class="line">    <span class="keyword">while</span>(gets(str[x]) &amp;&amp; str[x][<span class="number">0</span>]!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(T,str[x]);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>;u&lt;x;u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str[u]);</span><br><span class="line">        <span class="keyword">char</span> str1[<span class="number">100</span>],str2[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span>(k&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">                str1[i]=str[u][i];</span><br><span class="line">            str1[i]=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;i&lt;len;i++,j++)</span><br><span class="line">                str2[j]=str[u][i];</span><br><span class="line">            str2[j]=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(find(T,str1) &amp;&amp; find(T,str2))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str[u]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//FreeTree(T);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="acm" scheme="sherry0429.github.io/tags/acm/"/>
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
      <category term="hdu" scheme="sherry0429.github.io/tags/hdu/"/>
    
  </entry>
  
  <entry>
    <title>HDU 3790 双权最短路</title>
    <link href="sherry0429.github.io/2018/02/11/HDU-3790-%E5%8F%8C%E6%9D%83%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>sherry0429.github.io/2018/02/11/HDU-3790-双权最短路/</id>
    <published>2018-02-11T06:51:35.000Z</published>
    <updated>2018-02-12T03:45:41.577Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> cost[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=MAX;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=MAX;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[i][j]=<span class="number">0</span>;</span><br><span class="line">cost[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[i][j]=INF;</span><br><span class="line">cost[i][j]=INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> next,minc;</span><br><span class="line"><span class="keyword">int</span> dist[MAX],visit[MAX],value[MAX];</span><br><span class="line"><span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">dist[i]=<span class="built_in">map</span>[start][i];</span><br><span class="line">value[i]=cost[start][i];</span><br><span class="line">&#125;</span><br><span class="line">visit[start]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">minc=INF;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visit[j] &amp;&amp; minc&gt;dist[j])</span><br><span class="line">&#123;</span><br><span class="line">minc=dist[j];</span><br><span class="line">next=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">visit[next]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!visit[j] &amp;&amp; <span class="built_in">map</span>[next][j]&lt;INF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dist[j]&gt;dist[next]+<span class="built_in">map</span>[next][j])</span><br><span class="line">&#123;</span><br><span class="line">dist[j]=dist[next]+<span class="built_in">map</span>[next][j];</span><br><span class="line">value[j]=value[next]+cost[next][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(dist[j]==(dist[next]+<span class="built_in">map</span>[next][j]))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(value[j]&gt;value[next]+cost[next][j])</span><br><span class="line">value[j]=value[next]+cost[next][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,dist[end],value[end]);</span><br><span class="line"><span class="comment">//cout&lt;&lt;dist[end]&lt;&lt;' '&lt;&lt;value[end]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> start,end;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> time,<span class="built_in">cos</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;time&gt;&gt;<span class="built_in">cos</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[x][y]&gt;time)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[x][y]=<span class="built_in">map</span>[y][x]=time;</span><br><span class="line">cost[x][y]=cost[y][x]=<span class="built_in">cos</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[x][y]==time)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cost[x][y]&gt;<span class="built_in">cos</span>)</span><br><span class="line">cost[x][y]=cost[y][x]=<span class="built_in">cos</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;start&gt;&gt;end;</span><br><span class="line">dijkstra(start,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种题需要注意的就两点，特别重要的两点，初始化，和输入的设置（if语句），再就是Dijastra在更新时候的代码语句设置了。</p><p>这道题我在Virtual judge上做的，有一个很奇怪的情况。。。就是如果用cout,那就RE了，但用printf,就AC了（G++提交），然后如果用cin,cout组合，用C++提交，就WA了=，=</p><p>不懂是为什么=，=感觉好神奇</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="acm" scheme="sherry0429.github.io/tags/acm/"/>
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
      <category term="hdu" scheme="sherry0429.github.io/tags/hdu/"/>
    
  </entry>
  
  <entry>
    <title>HDU2544 Floyd</title>
    <link href="sherry0429.github.io/2018/02/11/HDU2544-Floyd/"/>
    <id>sherry0429.github.io/2018/02/11/HDU2544-Floyd/</id>
    <published>2018-02-11T06:51:17.000Z</published>
    <updated>2018-02-12T03:19:25.197Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 9999999</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)</span><br><span class="line"><span class="built_in">map</span>[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[j][i]=INF;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i][j]&gt;<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j])</span><br><span class="line"><span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"><span class="keyword">int</span> price;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;price;</span><br><span class="line">x--,y--;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[x][y]&gt;price)</span><br><span class="line"><span class="built_in">map</span>[x][y]=<span class="built_in">map</span>[y][x]=price;</span><br><span class="line">&#125;</span><br><span class="line">floyd();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">map</span>[<span class="number">0</span>][n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码本身不难，Floyd实现只是三个循环，但这道题需要注意的一些小问题让我WA了不少次.</p><ul><li>初始化，MAX和INF这两个预编译参数最好分开来写。</li><li>对Map的初始化需要考虑对角线上的元素为零，其余为INF，此外，每次初始化循环上限应为MAX，而非输入的顶点数。</li><li>input过程中，根据输入时刻更新Map[x][y]的值（即cin&gt;&gt;后的if语句）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="acm" scheme="sherry0429.github.io/tags/acm/"/>
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
      <category term="hdu" scheme="sherry0429.github.io/tags/hdu/"/>
    
  </entry>
  
  <entry>
    <title>Floyd,Dijkstra,SPFA</title>
    <link href="sherry0429.github.io/2018/02/11/Floyd-Dijkstra-SPFA/"/>
    <id>sherry0429.github.io/2018/02/11/Floyd-Dijkstra-SPFA/</id>
    <published>2018-02-11T06:50:58.000Z</published>
    <updated>2018-02-12T03:19:05.426Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>source link: <a href="http://gzhu-101majia.iteye.com/blog/1150170" target="_blank" rel="noopener">http://gzhu-101majia.iteye.com/blog/1150170</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">99999999</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[N][N], dist[N];  </span><br><span class="line"><span class="keyword">bool</span> visit[N];  </span><br><span class="line"><span class="keyword">int</span> n, m;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>     <span class="comment">//初始化  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; N; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="built_in">map</span>[i][j] = <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[j][i] = INF;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span>    <span class="comment">//输入函数  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> vi, vj, cost;  </span><br><span class="line">    <span class="keyword">while</span>(m--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;vi, &amp;vj, &amp;cost);  </span><br><span class="line">        <span class="keyword">if</span>(cost &lt; <span class="built_in">map</span>[vi][vj])  </span><br><span class="line">            <span class="built_in">map</span>[vi][vj] = <span class="built_in">map</span>[vj][vi] = cost;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span>    <span class="comment">//Floyd算法  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j, k;  </span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= n; k++)     <span class="comment">//k为中间点  </span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)  </span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j] &lt;  <span class="built_in">map</span>[i][j])  </span><br><span class="line">                     <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][k] + <span class="built_in">map</span>[k][j];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijk</span><span class="params">()</span>     <span class="comment">//Dijkstra算法  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, j, next, MIN;  </span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;  </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        MIN = INF;  </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  </span><br><span class="line">            <span class="keyword">if</span>(!visit[j] &amp;&amp; dist[j] &lt;= MIN)  </span><br><span class="line">                MIN = dist[next=j];  </span><br><span class="line">        <span class="keyword">if</span>(MIN == INF) <span class="keyword">break</span>;  </span><br><span class="line">        visit[next] = <span class="literal">true</span>;  </span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  </span><br><span class="line">            <span class="keyword">if</span>(!visit[j] &amp;&amp; dist[j] &gt; dist[next] + <span class="built_in">map</span>[next][j])  </span><br><span class="line">                dist[j] = dist[next] + <span class="built_in">map</span>[next][j];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span>     <span class="comment">//SPFA算法  </span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i, now;  </span><br><span class="line">    <span class="built_in">memset</span>(visit, <span class="literal">false</span>, <span class="keyword">sizeof</span>(visit));  </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) dist[i] = INF;  </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;  </span><br><span class="line">    Q.push(<span class="number">1</span>);  </span><br><span class="line">    visit[<span class="number">1</span>] = <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())  </span><br><span class="line">    &#123;  </span><br><span class="line">        now = Q.front();  </span><br><span class="line">        Q.pop();  </span><br><span class="line">        visit[now] = <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(dist[i] &gt; dist[now] + <span class="built_in">map</span>[now][i])  </span><br><span class="line">            &#123;  </span><br><span class="line">                dist[i] = dist[now] + <span class="built_in">map</span>[now][i];  </span><br><span class="line">                <span class="keyword">if</span>(visit[i] == <span class="number">0</span>)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    Q.push(i);  </span><br><span class="line">                    visit[i] = <span class="literal">true</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m))  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(!n || !m) <span class="keyword">break</span>;  </span><br><span class="line">        init();  </span><br><span class="line">        input();  </span><br><span class="line">        <span class="comment">//floyd();  </span></span><br><span class="line">        <span class="comment">//dijk();  </span></span><br><span class="line">        spfa();  </span><br><span class="line">        <span class="comment">//printf("%d\n", map[1][n]);  </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[n]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="code_template" scheme="sherry0429.github.io/categories/code-template/"/>
    
    
      <category term="acm" scheme="sherry0429.github.io/tags/acm/"/>
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>prim</title>
    <link href="sherry0429.github.io/2018/02/11/prim/"/>
    <id>sherry0429.github.io/2018/02/11/prim/</id>
    <published>2018-02-11T06:50:36.000Z</published>
    <updated>2018-02-12T03:48:47.661Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line"><span class="built_in">map</span>[i][j]=MAX;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">int</span> minc,mht;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> visit[<span class="number">100</span>],lowcost[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">lowcost[i]=<span class="built_in">map</span>[<span class="number">0</span>][i];</span><br><span class="line">visit[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">mht=<span class="number">-1</span>;</span><br><span class="line">minc=MAX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[j]==<span class="number">0</span> &amp;&amp; minc&gt;lowcost[j])</span><br><span class="line">&#123;</span><br><span class="line">minc=lowcost[j];</span><br><span class="line">mht=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mht==<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">sum+=minc;</span><br><span class="line">visit[mht]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[j]==<span class="number">0</span> &amp;&amp; lowcost[j]&gt;<span class="built_in">map</span>[mht][j])</span><br><span class="line">lowcost[j]=<span class="built_in">map</span>[mht][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">init(n);</span><br><span class="line"><span class="keyword">int</span> m=(n*(n<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a,b,c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">a--,b--;</span><br><span class="line"><span class="built_in">map</span>[a][b]=c;</span><br><span class="line"><span class="built_in">map</span>[b][a]=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum=Prim(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法的精华在：</p><ul><li>初始化（MAX！！！）这牵扯到后面的比较，十分重要。</li><li>两个数组vistied[max],和lowcast[max].</li><li>每找到一条边后进行的更新操作.</li></ul><p>理解该算法的重点在，理解lowcast里存的到底是什么。</p><p>简单来说，lowcast[i],就是i可达的顶点中，到i的最小距离，它在prim算法执行过程中被不断更新（或不更新，因为没有更小的路径）。</p><p>如果要标记出一条最小路径，那么记忆一下mht即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="acm" scheme="sherry0429.github.io/tags/acm/"/>
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Kruskal</title>
    <link href="sherry0429.github.io/2018/02/11/Kruskal/"/>
    <id>sherry0429.github.io/2018/02/11/Kruskal/</id>
    <published>2018-02-11T06:50:26.000Z</published>
    <updated>2018-02-12T03:47:58.486Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 10000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="keyword">int</span> price,vis;</span><br><span class="line">&#125;Edge[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge x,edge y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x.vis!=y.vis)</span><br><span class="line"><span class="keyword">return</span> x.vis&lt;y.vis;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> x.price&lt;y.price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x!=ans[x])</span><br><span class="line">ans[x]=find(ans[x]);</span><br><span class="line"><span class="keyword">return</span> ans[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tx=find(a);</span><br><span class="line"><span class="keyword">int</span> ty=find(b);</span><br><span class="line"><span class="keyword">if</span>(tx!=ty)</span><br><span class="line">ans[tx]=ty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sort(Edge+<span class="number">1</span>,Edge+m+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tx=find(Edge[i].u);</span><br><span class="line"><span class="keyword">int</span> ty=find(Edge[i].v);</span><br><span class="line"><span class="keyword">if</span>(tx!=ty &amp;&amp; !Edge[i].vis)</span><br><span class="line">&#123;</span><br><span class="line">sum+=Edge[i].price;</span><br><span class="line">ans[tx]=ty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">m=(n*(n<span class="number">-1</span>))/<span class="number">2</span>;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;Edge[i].u,&amp;Edge[i].v,&amp;Edge[i].price,&amp;Edge[i].vis);</span><br><span class="line"><span class="keyword">if</span>(Edge[i].vis==<span class="number">1</span>)</span><br><span class="line">Merge(Edge[i].u,Edge[i].v);</span><br><span class="line">&#125;</span><br><span class="line">Kruskal();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接上代码，需要注意的有几点：</p><ul><li>初始化。</li><li>排序，sort函数的使用。一定要排序，Kruskal关键就是在排序，而prim则是用一个顶点数组lowcast达到类似的排序效果。</li><li>这道题是和并查集连起来用了，因为涉及到“已建”和“未建”两种集合，如果是直接read Graph,初始状态要么就是都没建，要么就是都已建好（找出最短路），那就不需要用并查集，直接用MAP[MAX[[MAX[即可。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="acm" scheme="sherry0429.github.io/tags/acm/"/>
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Graham</title>
    <link href="sherry0429.github.io/2018/02/11/Graham/"/>
    <id>sherry0429.github.io/2018/02/11/Graham/</id>
    <published>2018-02-11T06:49:31.000Z</published>
    <updated>2018-02-12T03:19:13.691Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>code_template from internet (unknown link):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">struct Point  </span><br><span class="line">&#123;  </span><br><span class="line">    double x,y;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">Point point[1003];  </span><br><span class="line">Point stack[1003];//把构成凸包的点存到stack中,存入点的个数为top个  </span><br><span class="line">int c,n,top;  </span><br><span class="line">double l,r;  </span><br><span class="line">  </span><br><span class="line">int multi(Point p0,Point p1,Point p2)  </span><br><span class="line">&#123;  </span><br><span class="line">    return ((p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">double dis(Point p1,Point p2)  </span><br><span class="line">&#123;  </span><br><span class="line">    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int cmp(Point a,Point b)  </span><br><span class="line">&#123;  </span><br><span class="line">    if(multi(point[0],a,b)&gt;0) return 1;  </span><br><span class="line">        if(multi(point[0],a,b)&lt;0) return 0;  </span><br><span class="line">            if(dis(point[0],a)&lt;dis(point[0],b))  </span><br><span class="line">                return 1;  </span><br><span class="line">                return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">void graham()  </span><br><span class="line">&#123;  </span><br><span class="line">    int i,k=0;  </span><br><span class="line">    Point temp;  </span><br><span class="line">    for(i=1; i&lt;n; i++)  </span><br><span class="line">        if((point[i].y&lt;point[k].y)||((point[i].y==point[k].y)&amp;&amp;(point[i].x&lt;point[k].x)))  </span><br><span class="line">            k=i;  </span><br><span class="line">    temp=point[0];  </span><br><span class="line">    point[0]=point[k];  </span><br><span class="line">    point[k]=temp;  </span><br><span class="line">    sort(point+1,point+n,cmp);//按极角的大小进行排序  </span><br><span class="line">    stack[0]=point[0];  </span><br><span class="line">    stack[1]=point[1];  </span><br><span class="line">   top=1;  </span><br><span class="line">   i=2;  </span><br><span class="line">     while(i&lt;n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if(multi(stack[top],stack[top-1],point[i])&lt;=0)</span><br><span class="line">        //AB x AC&gt;0 AC在AB的逆时针方向  </span><br><span class="line">        //AB x AC&lt;0 AC在AB的顺时针方向  </span><br><span class="line">        //AB x AC=0 ABC 共线  </span><br><span class="line">            stack[++top]=point[i++];  </span><br><span class="line">        else  </span><br><span class="line">            top--;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我对这个算法的理解是，核心在于判断左右拐，而在判断前要做一些准备工作。</p><p>首先要有一个记录点顺序的结构和记录输入的结构【例如数组】，然后讲点对都记录下来了以后，</p><ul><li>首先找到最左下角的那个顶点（x最小，y最小或与第二小的点相等）</li><li>把这个点和记录输入的第一个点交换，把输入的第一个点放到最后去。</li><li>进行排序.</li><li>根据向量外积大于零或者小于零判断左拐或者右拐，用栈或者数组来完成记录点或者删除点的工作。（需要预先读入两个点）。</li></ul><p>算法到此结束，最后将点对输出和距离和即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSDN 博客搬家&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="sherry0429.github.io/categories/algorithm/"/>
    
    
      <category term="acm" scheme="sherry0429.github.io/tags/acm/"/>
    
      <category term="c" scheme="sherry0429.github.io/tags/c/"/>
    
  </entry>
  
</feed>
