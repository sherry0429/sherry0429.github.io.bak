
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Monster &amp; Flower">
    <title>archives: 2018/2 - Monster &amp; Flower</title>
    <meta name="author" content="Tianyou Pan">
    
    
        <link rel="icon" href="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/favicon.jpg">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="personal blog about tianyou pan&apos;s program travel">
<meta property="og:type" content="blog">
<meta property="og:title" content="Monster &amp; Flower">
<meta property="og:url" content="sherry0429.github.io/archives/2018/02/index.html">
<meta property="og:site_name" content="Monster &amp; Flower">
<meta property="og:description" content="personal blog about tianyou pan&apos;s program travel">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Monster &amp; Flower">
<meta name="twitter:description" content="personal blog about tianyou pan&apos;s program travel">
    
    
        
    
    
        <meta property="og:image" content="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/handface.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-eonj0pe2aabccyzjrtkp7h1yt1tl45l2v3xwpl2nilpuholcj85zrpl3eiid.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Monster &amp; Flower</a>
    </div>
    
        
            <a  class="header-right-icon open-algolia-search"
                href="#search">
        
        
            <i class="fa fa-lg fa-search"></i>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/handface.jpg" alt="author‘s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Tianyou Pan</h4>
                
                    <h5 class="sidebar-profile-bio"><p>光阴似箭，日月如梭，然而，人可以老，力可以衰，心却不能死，理想也不能灭…</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-categories"
                            
                            title="Categories"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-archives"
                            
                            title="Archives"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/sherry0429" target="_blank" rel="noopener" title="Github">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Github</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://stackoverflow.com/users/5557569/sherry0429" target="_blank" rel="noopener" title="Stack Overflow">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/sherry0429@outlook.com"
                            title="Mail"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/11/KMP/">
                            KMP
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-11T15:19:59+08:00">
	
		    2月 11, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/code-template/">code_template</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <a id="more"></a>
<p>hahaha</p>
<!-- excerpt CSDN 博客搬家-->
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 100000</span></span><br><span class="line"><span class="keyword">int</span> T[MAXN],P[MAXM],Next[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeNext</span><span class="params">(<span class="keyword">int</span> M)</span><span class="comment">//找到一个匹配位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;M)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">-1</span> || P[i]==P[j])</span><br><span class="line">		&#123;</span><br><span class="line">            i++,j++;</span><br><span class="line">            <span class="keyword">if</span>(P[i]!=P[j])</span><br><span class="line">				Next[i] = j;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">				Next[i] = Next[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">			j = Next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(<span class="keyword">int</span> N,<span class="keyword">int</span> M)</span><span class="comment">//进行匹配</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;N &amp;&amp; j&lt;M)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[i]==P[j] || j==<span class="number">-1</span>)</span><br><span class="line">			i++,j++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">			j = Next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==M)</span><br><span class="line">		<span class="keyword">return</span> i-M+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,M,C;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;C);</span><br><span class="line">    <span class="keyword">while</span>(C--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;N,&amp;M);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T[i]);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;P[i]);</span><br><span class="line">        <span class="keyword">if</span>(M&gt;N)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">            MakeNext(M);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,KMP(N,M));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/11/KMP/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/11/LeetCode-003-Longest-Substring-Without-Repeating-Characters/">
                            LeetCode #003 Longest Substring Without Repeating Characters
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-11T14:58:00+08:00">
	
		    2月 11, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <!-- excerpt CSDN 博客搬家-->
<p>#003 Longest Substring Without Repeating Characters</p>
<blockquote>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p>
<p>Input: abcabccbb<br>Output: 3<br>题意：找到一个字符串中，没有重复字符的最长子串，返回它的长度</p>
<p>#####思路：</p>
<ol>
<li>做一个一维数组HashTable，下标为字符的ASCII码，值为这个字符在字符串中的位置，初始化为-1</li>
<li>设置一个变量LastPosition表示不重复最长串的第一个元素的下标</li>
<li>遍历字符串，依次检测该字符是否存在HashTable中，例：<br><code>HashTable[&#39;a&#39;]=-1</code>表示该字符第一次出现。<br><code>HashTable[&#39;a&#39;]=2</code>表示该字符上一次出现的位置在str[2].</li>
<li>如果第一次出现该字符a，HashTable[‘a’]=字符’a’在字符串中的位置.</li>
<li>如果已经出现过字符’a’，如果上一次’a’在目前检测串中，则置LastPosition为a的下标（即上一次LastPostion）。否则置LastPosition为当前检测字符的下标（HashTable[temp]）。<br>该下标一定为：<code>LastPosition=std::max(LastPosition,HashTable[temp]);</code></li>
<li>Max为<code>HashTable[temp]-LastPostion</code>所能得到的最大值<br>| a | b | c | d | a |<br>| – |</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>#####代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> LastPosition=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> HashTable[<span class="number">255</span>]=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=(<span class="keyword">int</span>)s[i];</span><br><span class="line">            <span class="keyword">if</span>(HashTable[temp]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                LastPosition=<span class="built_in">std</span>::max(LastPosition,HashTable[temp]);</span><br><span class="line">            &#125;</span><br><span class="line">            HashTable[temp]=i+<span class="number">1</span>;</span><br><span class="line">            Max=<span class="built_in">std</span>::max(Max,HashTable[temp]-LastPosition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>#####知识点</p>
<ol>
<li>字符串中寻找最长符合要求的子串</li>
<li>难点：当检测到重复字符时，应该从何处继续检测</li>
<li>还有一种DP解法如下，其实上面的代码也是DP，DP指通过状态转移来解决问题的一种思路，每一种状态的决定总是与上一次状态有联系，以下代码中，Flag数组就是一种记录状态，而Longest每次依赖于上一次Longest还有Flag数组中的状态，因此说这种解决思路是一种DP思路。这个代码由LeetCode上的prime_tang所写，此处为引用。我询问后，他对DP思路的描述原文如下：<blockquote>
<p>In my understanding, the dynamic programming is: every decision depends on the current status, and immediately cause the transfer of status. In this problem, flag is the status, and we can get the longest every time depends on the previous longest and the flag, so I think it also can be seen as DP solution, even though not obvious compared to the Maximum Subarray problem.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flag(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, longest = <span class="number">0</span>, len = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag[s[i]] &gt;= start) &#123;</span><br><span class="line">                longest = <span class="built_in">std</span>::max(longest, i - start);</span><br><span class="line">                start = flag[s[i]] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag[s[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::max(longest, len - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/11/LeetCode-003-Longest-Substring-Without-Repeating-Characters/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/11/LeetCode-002-Add-Two-Numbers/">
                            LeetCode #002 Add Two Numbers
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-11T14:57:37+08:00">
	
		    2月 11, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <!-- excerpt CSDN 博客搬家-->
<p>#002 Add Two Numbers</p>
<blockquote>
<p>You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8</p>
<p>#####思路：</p>
<ol>
<li>建立一个新的链表List</li>
<li>依次检测两个链表节点是否为空，不为空则检测值</li>
<li>如果检测到值，<code>int value = val1 + val2 + remain;</code></li>
<li>val1=l1-&gt;val,val2=l2-&gt;val,它们被初始化为0,remain为进位值.</li>
<li>将value存入List节点里<br>#####代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> remain = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//new list</span></span><br><span class="line">    ListNode* head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//head node,it is empty.</span></span><br><span class="line">    ListNode* p = head;</span><br><span class="line">    <span class="keyword">if</span>(l1==<span class="literal">NULL</span> &amp;&amp; l2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1==<span class="literal">NULL</span> &amp;&amp; l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l1!=<span class="literal">NULL</span> &amp;&amp; l2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> ||  l2 != <span class="literal">NULL</span>)<span class="comment">//only two list get end,while will be finish.</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> val1 = <span class="number">0</span>, val2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            val1 = l1-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            val2 = l2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = val1 + val2 + remain;</span><br><span class="line">        remain = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(value &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            value -= <span class="number">10</span>;<span class="comment">//value = value % 10</span></span><br><span class="line">            remain = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//build List</span></span><br><span class="line">        ListNode * pos = <span class="keyword">new</span> ListNode(value);</span><br><span class="line">        p-&gt;next = pos;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if ABCDE</span></span><br><span class="line"><span class="comment">    if FGHIG</span></span><br><span class="line"><span class="comment">    AND IF E+G&gt;10</span></span><br><span class="line"><span class="comment">    we need make a new node,it's val is (E+G)%10.</span></span><br><span class="line"><span class="comment">    like this:</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(remain != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pos = <span class="keyword">new</span> ListNode(remain);</span><br><span class="line">        p-&gt;next = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    <span class="comment">//!!!__Don't return head because head is empty,head-&gt;next is first node with val.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>#####知识点</p>
<ol>
<li>如何用尾插法建立链表</li>
<li>同时遍历两个链表并进行相应处理（均遍历到结尾时处理才结束）</li>
<li>当遍历A节点时，得到需要处理A-&gt;next的信息，如何在遍历时延后一步处理。<ol>
<li>方案1：用一个Bool量标记是否应当处理，在建表后的语句中加入处理语句</li>
<li>方案2：类似这种求和，将信息保留在remain中，每次加上remain，无信息则remain=0,否则remain=溢出数.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方案1</span></span><br><span class="line"><span class="keyword">bool</span> deal=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">....<span class="comment">//here you build list</span></span><br><span class="line">	<span class="keyword">if</span>(deal)&#123;</span><br><span class="line">....<span class="comment">//here you deal something</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方案2</span></span><br><span class="line"><span class="keyword">int</span> value = val1 + val2 + remain;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/11/LeetCode-002-Add-Two-Numbers/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/11/LeetCode-001-Two-Num/">
                            LeetCode #001 Two Num
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-11T14:57:22+08:00">
	
		    2月 11, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <!-- excerpt CSDN 博客搬家-->
<p>#01 Two Num</p>
<blockquote>
<p>Given an array of integers, find two numbers such that they add up to a specific target number.<br>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.<br>You may assume that each input would have exactly one solution.</p>
<p>Input: numbers={2, 7, 11, 15}, target=9<br>Output: index1=1, index2=2</p>
<p>#####思路1：</p>
<ol>
<li>用STL Map，将数据存入Map，而后查找First和Target-First是否都存在，如都存在，输出他们的下标。（即First，Target-First对应的Value）.</li>
<li>迭代器iterator两个域,iterator-&gt;first对应Key,iterator-&gt;second对应Value.</li>
<li>循环遍历Nums，检测Map，跳过Nums下标为Map-Value的元素。（重要）<br>#####代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Map;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> solve;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            Map[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (Map[temp]!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="comment">//this if is important</span></span><br><span class="line">                <span class="keyword">if</span>(i == Map[temp])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//Map's value don't need in 'for' fuction.</span></span><br><span class="line">                &#125;</span><br><span class="line">                solve.push_back(i+<span class="number">1</span>);</span><br><span class="line">                solve.push_back(Map[temp]+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> solve;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> solve;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>####思路2</p>
<ol>
<li>分配一个数组空间，将数据拷贝至A</li>
<li>将A数组排序</li>
<li>建立两个查找指针头指针X,尾指针Y,依次相加比较指针所指的值E,F</li>
<li>E大于F Y++</li>
<li>E小于F X++</li>
<li>当指针相等或相交时退出循环</li>
<li>提前退出循环说明找到了E+F=target</li>
<li>遍历nums，当值与找到的E,F相等时,将相应的下标Push进Vector</li>
</ol>
<p>#####代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">int</span>*)a - *(<span class="keyword">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//vector&lt;int&gt;temp;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;index;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            temp[i] = nums[i];</span><br><span class="line">        <span class="comment">//for(int i = 0; i &lt; len;i++)</span></span><br><span class="line">        <span class="comment">//  temp.push_back(nums[i]);</span></span><br><span class="line">        <span class="comment">//sort(temp.begin(),temp.end());</span></span><br><span class="line">        qsort(temp,len,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),compare);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((temp[left] + temp[right]) &gt; target)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((temp[left] + temp[right]) &lt; target)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == temp[left] || nums[i] == temp[right])</span><br><span class="line">                index.push_back(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> []temp;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>#####知识点</p>
<ol>
<li>在一个数组中查找指定元素</li>
<li>对数组元素进行排序</li>
<li>得到排序数组中比某数小或大的区域（该数不一定存在在数组内）</li>
<li>知道一组值，求与这组值有关的另一组值</li>
<li>方法2的一种特殊思路.</li>
</ol>
<p>#####官网给出的Solution</p>
<blockquote>
<p>####O(n2) runtime, O(1) space – Brute force:</p>
<p>The brute force approach is simple. Loop through each element x and find if there is another value that equals to target – x. As finding another value requires looping through the rest of array, its runtime complexity is O(n2).</p>
<p>####O(n) runtime, O(n) space – Hash table:</p>
<p>We could reduce the runtime complexity of looking up a value to O(1) using a hash map that maps a value to its index.</p>
</blockquote>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/11/LeetCode-001-Two-Num/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/11/C-文件流-总结/">
                            C++文件流 总结
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-11T14:54:35+08:00">
	
		    2月 11, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/think/">think</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <!-- excerpt CSDN 博客搬家-->
<h1 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h1><p>首先，需要加<fstream>头文件。（即file stream），在包含这个头文件后，可使用三种类：</fstream></p>
<ul>
<li>ofstream  写文件  （Output File Stream）  <ul>
<li>使用方法: 文件名&lt;&lt;内容&lt;&lt;endl;</li>
</ul>
</li>
<li>ifstream   读文件 （Input File Stream）  <ul>
<li>使用方法:文件名&gt;&gt;内容;</li>
</ul>
</li>
<li>fstream  打开文件供读写  （File Stream） <ul>
<li>利用各种参数达到控制文件读写的目的</li>
</ul>
</li>
</ul>
<h1 id="Same"><a href="#Same" class="headerlink" title="Same"></a>Same</h1><p>每个类都有相同的两种函数功能：</p>
<ul>
<li>X.open(“String”);   <ul>
<li>//String为路径，也可以string str；X.open(str);(用string类，没有引号，但是string本身内容里最后4个单位应为.txt）</li>
<li>如果用fstream创建文件 必须加Ios::out.</li>
</ul>
</li>
<li>X.close();</li>
</ul>
<p>同一时间，同一文件只能由一种类进行操作。若需要换，必须先将此类指针关闭，再用需要的类的指针Open目标文件。</p>
<h1 id="fstream"><a href="#fstream" class="headerlink" title="fstream"></a>fstream</h1><p>fstream的open函数的参数定义了文件的打开模式。总共有如下模式：</p>
<ul>
<li>ios::in 读</li>
<li>ios::out 写</li>
<li>ios::app 从文件末尾开始写</li>
<li>ios::binary       二进制模式</li>
<li>ios::nocreate 打开一个文件时，如果文件不存在，不创建文件。</li>
<li>ios::noreplace  打开一个文件时，如果文件不存在，创建该文件</li>
<li>ios::trunc 打开一个文件，然后清空内容</li>
<li>ios::ate 打开一个文件时，将位置移动到文件尾</li>
</ul>
<p>使用方式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.open(<span class="string">"file.ext"</span>,iso::in|ios::out)</span><br></pre></td></tr></table></figure>
<ul>
<li>默认模式是文本</li>
<li>默认如果文件不存在，那么创建一个新的</li>
<li>多种模式可以混合，用|(按位或)</li>
<li>文件的byte索引从0开始。（就像数组一样）</li>
</ul>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><ul>
<li>good()<ul>
<li>如果文件打开成功</li>
</ul>
</li>
<li>bad() <ul>
<li>打开文件时发生错误</li>
</ul>
</li>
<li>eof() <ul>
<li>到达文件尾</li>
</ul>
</li>
</ul>
<h2 id="Pointers"><a href="#Pointers" class="headerlink" title="Pointers"></a>Pointers</h2><ul>
<li>seekg() </li>
<li>tellg()</li>
<li>seekp()          </li>
<li>tellq()</li>
</ul>
<p>以g结尾的，处理get指针（ifstream），以p结尾的，处理put指针（ofstream）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seekg/p(X,INF);</span><br></pre></td></tr></table></figure>
<p>X为一个数，可为正可为负，INF为一个参数，该参数可为以下：</p>
<ul>
<li>ios::beg  文件头</li>
<li>ios::end  文件尾</li>
<li>ios::cur  当前位置</li>
</ul>
<p>整个函数表示将指针从INF处，移动X个单位。</p>
<p>例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seekg(<span class="number">-1</span>,ios::end);<span class="comment">//把指针从文件尾向前移动一个字节</span></span><br></pre></td></tr></table></figure>
<p>tellg, tellp : 返回一个数，表示此时指针所在的位置。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/11/C-文件流-总结/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/11/AC自动机/">
                            AC自动机
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-11T14:52:54+08:00">
	
		    2月 11, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/reprint/">reprint</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <!-- excerpt CSDN 博客搬家-->
<p>source link: <a href="http://blog.csdn.net/niushuai666/article/details/7002823" target="_blank" rel="noopener">http://blog.csdn.net/niushuai666/article/details/7002823</a></p>
<h1 id="AC自动机简介："><a href="#AC自动机简介：" class="headerlink" title="AC自动机简介："></a>AC自动机简介：</h1><p>##AC自动机的构造：</p>
<ul>
<li><p>构造一棵Trie，作为AC自动机的搜索数据结构。</p>
</li>
<li><p>构造fail指针，使当前字符失配时跳转到具有最长公共前后缀的字符继续匹配。</p>
<p>如同 KMP算法一样， AC自动机在匹配时如果当前字符匹配失败，那么利用fail指针进行跳转。由此可知如果跳转，跳转后的串的前缀，必为跳转前的模式串的后缀并且跳转的新位置的深度（匹配字符个数）一定小于跳之前的节点。所以我们可以利用 bfs在 Trie上面进行 fail指针的求解。</p>
</li>
<li><p>扫描主串进行匹配。</p>
</li>
</ul>
<h2 id="AC自动机详讲："><a href="#AC自动机详讲：" class="headerlink" title="AC自动机详讲："></a>AC自动机详讲：</h2><p>我们给出5个单词，say，she，shr，he，her。给定字符串为yasherhs。问多少个单词在字符串中出现过。</p>
<p><strong>一、Trie</strong></p>
<p>首先我们需要建立一棵Trie。但是这棵Trie不是普通的Trie，而是带有一些特殊的性质。</p>
<p>首先会有3个重要的指针，分别为p, p-&gt;fail, temp。</p>
<p>1.指针p，指向当前匹配的字符。若p指向root，表示当前匹配的字符序列为空。（root是Trie入口，没有实际含义）。</p>
<p>2.指针p-&gt;fail，p的失败指针，指向与字符p相同的结点，若没有，则指向root。</p>
<p>3.指针temp，测试指针（自己命名的，容易理解！~），在建立fail指针时有寻找与p字符匹配的结点的作用，在扫描时作用最大，也最不好理解。</p>
<p>对于Trie树中的一个节点，对应一个序列s[1…m]。此时，p指向字符s[m]。若在下一个字符处失配，即p-&gt;next[s[m+1]] == NULL，则由失配指针跳到另一个节点(p-&gt;fail)处，该节点对应的序列为s[i…m]。若继续失配，则序列依次跳转直到序列为空或出现匹配。在此过程中，p的值一直在变化，但是p对应节点的字符没有发生变化。在此过程中，我们观察可知，最终求得得序列s则为最长公共后缀。另外，由于这个序列是从root开始到某一节点，则说明这个序列有可能是某些序列的前缀。</p>
<p>再次讨论p指针转移的意义。如果p指针在某一字符s[m+1]处失配(即p-&gt;next[s[m+1]] == NULL)，则说明没有单词s[1…m+1]存在。此时，如果p的失配指针指向root，则说明当前序列的任意后缀不会是某个单词的前缀。如果p的失配指针不指向root，则说明序列s[i…m]是某一单词的前缀，于是跳转到p的失配指针，以s[i…m]为前缀继续匹配s[m+1]。</p>
<p>对于已经得到的序列s[1…m]，由于s[i…m]可能是某单词的后缀，s[1…j]可能是某单词的前缀，所以s[1…m]中可能会出现单词。此时，p指向已匹配的字符，不能动。于是，令temp = p，然后依次测试s[1…m], s[i…m]是否是单词。</p>
<p>构造的Trie为：</p>
<p><img src="http://www.cppblog.com/images/cppblog_com/mythit/ac1.jpg" alt="img"></p>
<p><strong>二、构造失败指针</strong></p>
<p>用BFS来构造失败指针，与KMP算法相似的思想。</p>
<p>首先，root入队，第1次循环时处理与root相连的字符，也就是各个单词的第一个字符h和s，因为第一个字符不匹配需要重新匹配，所以第一个字符都指向root（root是Trie入口，没有实际含义）失败指针的指向对应下图中的(1)，(2)两条虚线；第2次进入循环后，从队列中先弹出h，接下来p指向h节点的fail指针指向的节点，也就是root；p=p-&gt;fail也就是p=NULL说明匹配序列为空，则把节点e的fail指针指向root表示没有匹配序列，对应图-2中的(3)，然后节点e进入队列；第3次循环时，弹出的第一个节点a的操作与上一步操作的节点e相同，把a的fail指针指向root，对应图-2中的(4)，并入队；第4次进入循环时，弹出节点h(图中左边那个)，这时操作略有不同。由于p-&gt;next[i]!=NULL(root有h这个儿子节点，图中右边那个)，这样便把左边那个h节点的失败指针指向右边那个root的儿子节点h，对应图-2中的(5)，然后h入队。以此类推：在循环结束后，所有的失败指针就是图-2中的这种形式。</p>
<p><img src="http://www.cppblog.com/images/cppblog_com/mythit/ac2.JPG" alt="img"></p>
<p><strong>三、扫描</strong></p>
<p>构造好Trie和失败指针后，我们就可以对主串进行扫描了。这个过程和KMP算法很类似，但是也有一定的区别，主要是因为AC自动机处理的是多串模式，需要防止遗漏某个单词，所以引入temp指针。</p>
<p>匹配过程分两种情况：(1)当前字符匹配，表示从当前节点沿着树边有一条路径可以到达目标字符，此时只需沿该路径走向下一个节点继续匹配即可，目标字符串指针移向下个字符继续匹配；(2)当前字符不匹配，则去当前节点失败指针所指向的字符继续匹配，匹配过程随着指针指向root结束。重复这2个过程中的任意一个，直到模式串走到结尾为止。</p>
<p> 对照上图，看一下模式匹配这个详细的流程，其中模式串为yasherhs。对于i=0,1。Trie中没有对应的路径，故不做任何操作；i=2,3,4时，指针p走到左下节点e。因为节点e的count信息为1，所以cnt+1，并且讲节点e的count值设置为-1，表示改单词已经出现过了，防止重复计数，最后temp指向e节点的失败指针所指向的节点继续查找，以此类推，最后temp指向root，退出while循环，这个过程中count增加了2。表示找到了2个单词she和he。当i=5时，程序进入第5行，p指向其失败指针的节点，也就是右边那个e节点，随后在第6行指向r节点，r节点的count值为1，从而count+1，循环直到temp指向root为止。最后i=6,7时，找不到任何匹配，匹配过程结束。</p>
<p>到此，AC自动机入门知识就讲完了。HDU 2222入门题必须果断A掉，反正我是参考别人代码敲的。。。</p>
<p>AC自动机貌似还有很多需要优化的地方，等把基础搞定之后再学习一下怎么优化吧。。</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/11/AC自动机/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/11/OpenCV-随笔记录/">
                            OpenCV 随笔记录
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-11T14:52:18+08:00">
	
		    2月 11, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/think/">think</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <!-- excerpt CSDN 博客搬家-->
<p>在实验室里听一点记一点，到时候再总结整理吧。先记下来再说。</p>
<p>一定要记住的page：<a href="http://wiki.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5" target="_blank" rel="noopener">http://wiki.opencv.org.cn/index.php/%E9%A6%96%E9%A1%B5</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     IplImage * test=NULL;</span><br><span class="line">     test = cvLoadImage (&quot;D:\\demo.jpg&quot;);</span><br><span class="line">     cvNamedWindow(&quot;test_demo&quot;,1);</span><br><span class="line">	 cvMoveWindow(&quot;test_demo&quot;,800,10);</span><br><span class="line">     cvShowImage(&quot;test_demo&quot;,test);</span><br><span class="line">     cvWaitKey(0);</span><br><span class="line">     cvDestroyWindow(&quot;test_demo&quot;);</span><br><span class="line">     cvReleaseImage(&amp;test);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已知函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.IplImage *p=NULL;定义图像指针</span><br></pre></td></tr></table></figure>
<p>IplImage是一个类，它包含以下结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IplImage</span><br><span class="line">    &#123;</span><br><span class="line">        int  nSize;         /* IplImage大小，=sizeof(IplImage)*/</span><br><span class="line">        int  ID;            /* 版本 (=0)*/</span><br><span class="line">        int  nChannels;     /* 大多数OPENCV函数支持1,2,3 或 4 个通道 */</span><br><span class="line">        int  alphaChannel;  /* 被OpenCV忽略 */</span><br><span class="line">        int  depth;         /* 像素的位深度: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U,</span><br><span class="line">                               IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F 可支持 */</span><br><span class="line">        char colorModel[4]; /* 被OpenCV忽略 */</span><br><span class="line">        char channelSeq[4]; /* 被OpenCV忽略 */</span><br><span class="line">        int  dataOrder;     /* 0 - 交叉存取颜色通道，对三通道RGB图像，像素存储顺序为BGR BGR BGR ... BGR；</span><br><span class="line">                                     1 - 分开的颜色通道，对三通道RGB图像，像素存储顺序为RRR...R GGG...G BBB...B。</span><br><span class="line">                                  cvCreateImage只能创建交叉存取图像 */</span><br><span class="line">        int  origin;        /* 0 - 顶—左结构,</span><br><span class="line">                               1 - 底—左结构 (Windows bitmaps 风格) */</span><br><span class="line">        int  align;         /* 图像行排列 (4 or 8). OpenCV 忽略它，使用 widthStep 代替 */</span><br><span class="line">        int  width;         /* 图像宽像素数 */</span><br><span class="line">        int  height;        /* 图像高像素数*/</span><br><span class="line">        struct _IplROI *roi;/* 图像感兴趣区域. 当该值非空只对该区域进行处理 */</span><br><span class="line">        struct _IplImage *maskROI; /* 在 OpenCV中必须置NULL */</span><br><span class="line">        void  *imageId;     /* 同上*/</span><br><span class="line">        struct _IplTileInfo *tileInfo; /*同上*/</span><br><span class="line">        int  imageSize;     /* 图像数据大小(在交叉存取格式下imageSize=image-&gt;height*image-&gt;widthStep），单位字节*/</span><br><span class="line">        char *imageData;  /* 指向排列的图像数据 */</span><br><span class="line">        int  widthStep;   /* 排列的图像行大小，以字节为单位 */</span><br><span class="line">        int  BorderMode[4]; /* 边际结束模式, 被OpenCV忽略 */</span><br><span class="line">        int  BorderConst[4]; /* 同上 */</span><br><span class="line">        char *imageDataOrigin; /* 指针指向一个不同的图像数据结构（不是必须排列的），是为了纠正图像内存分配准备的 */</span><br><span class="line">    &#125;</span><br><span class="line">    IplImage;</span><br></pre></td></tr></table></figure>
<p>每定义一个IplImage指针，就定义了一个矩形，矩形的每一行依次为nsize,ID……等等。如图：</p>
<p><img src="http://img.blog.csdn.net/20140707151208062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjUxNDM3Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.cvLoadImage()</span><br></pre></td></tr></table></figure>
<p>cvLoadImage( filename, -1 ); 默认读取图像的原通道数，filename为图像路径</p>
<p>cvLoadImage( filename, 0 ); 强制转化读取图像为灰度图</p>
<p>cvLoadImage( filename, 1 ); 读取彩色图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.cvNameWindow(&quot;Image&quot;,1);命名图像空间</span><br></pre></td></tr></table></figure>
<p>int cvNamedWindow( const char* name, int flags=CV_WINDOW_AUTOSIZE );</p>
<p>函数cvNamedWindow创建一个可以放置图像的窗口.</p>
<p>被创建的窗口可以通过它们的名字被引用.</p>
<p>如果已经存在这个名字的窗口，这个函数将不做任何事情.</p>
<p>若为0表示以固定尺寸显示,此时可以用cvResizeWindow控制窗口大小，这时图像根据窗口大小进行调整，且全铺在窗口上。可以用鼠标拉伸。</p>
<p>若为1，窗口以图像大小进行调整（即使先前设置过窗口大小），也会根据图像大小进行调整，且不可拉伸。</p>
<p><em>*</em>使用了这个函数后，即使没有图像指针，在编译完成后也会生成一个窗口（灰色）。</p>
<p>关于cvResizeWindow(需要注意，这个函数是用来改变窗口大小的，而非改变图像大小。之所以看似图像大小也改变了，实际上是因为在NamedWindow参数里，设置为图像根据窗口进行调整。换句话说，它的原理是通过改变窗口大小——让图像跟着窗口变化——进而改变图像大小，而非直接改变图像大小。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvResizeWindow( const char* name, int width, int height );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>name </p>
<p>将被设置窗口的名字。</p>
</li>
<li><p>width </p>
<p>新的窗口宽度。</p>
</li>
<li><p>height </p>
<p>新的窗口高度。</p>
</li>
</ul>
<p>函数cvResizeWindow改变窗口的大小。</p>
<p>如果想要直接改变图像大小，需要resize函数或者图像金字塔pyrDown,pyrUp(不改变长宽比，一次面积放大4倍或者缩小4分之一）</p>
<p>以下为转载：</p>
<hr>
<p>OpenCV改变图像大小的操作有两类：resize与图像金字塔，但是这两类操作差别还是比较大的。</p>
<p>一、resize</p>
<p>函数原型</p>
<p>void resize(InputArray src, OutputArray dst, Size dsize, double fx=0, double fy=0, int interpolation=INTER_LINEAR )</p>
<p>各个参数的意义比较直观，但是需要注意的是dsize与fx和fy必须不能同时为零，也就是说要么dsize不为零而fx与fy同时可以为0，要么dsize为0而fx与fy不同时为0；resize函数的目标大小可以是任意的大小，可以不保持长宽比率，删除的像素或者新增的像素值通过interpolation（内插）控制；</p>
<p>二、图像金字塔</p>
<p>pyrDown与pyrUp分别表示向下降采样与向上升采样，但是二者并不是互为逆操作；</p>
<p>void pyrDown(InputArray src, OutputArray dst, const Size&amp; dstsize=Size(), int border-</p>
<p>Type=BORDER_DEFAULT )</p>
<p>void pyrUp(InputArray src, OutputArray dst, const Size&amp; dstsize=Size(), int border-</p>
<p>Type=BORDER_DEFAULT )</p>
<p>这两个操作实现图像金字塔的经典操作，他们仅仅是分别代表一次采样操作，也就是说，向下(或者向上)进行相邻层次的金字塔采样，调用一次pyrDown函数只能降低到原图像尺寸的1/2;反之，调用pyrUp目标图像则为原图像尺寸的2倍。因为它们内部都给定了一次采样尺寸的约束。也就是说采样之后，长宽比基本是不变的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void ResizeDemo()</span><br><span class="line">&#123;</span><br><span class="line">         Mat img1=imread(&quot;person_org.jpg&quot;);</span><br><span class="line">         Mat img2;</span><br><span class="line">//将原图像变为32*32，长宽比被改变了</span><br><span class="line">         resize(img1,img2,Size(32,32),0,0,CV_INTER_LINEAR);</span><br><span class="line">         namedWindow(&quot;WindowOrg&quot;);</span><br><span class="line">         namedWindow(&quot;WindowNew&quot;);</span><br><span class="line">         imshow(&quot;WindowOrg&quot;,img1);</span><br><span class="line">         imshow(&quot;WindowNew&quot;,img2);</span><br><span class="line"> </span><br><span class="line">         waitKey(10000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage *Image;</span><br><span class="line">	IplImage *NewImage;</span><br><span class="line">	Image = cvLoadImage(&quot;D:\\1234.jpg&quot;,1);</span><br><span class="line"></span><br><span class="line">	CvSize sz;</span><br><span class="line">	sz = cvGetSize(Image);</span><br><span class="line">	sz.height /= 2;</span><br><span class="line">	sz.width /= 2;</span><br><span class="line">	//if pyrup,</span><br><span class="line">	//sz.height*=2;</span><br><span class="line">	//sz.width*=2;</span><br><span class="line">	//setting height and width.</span><br><span class="line"></span><br><span class="line">	NewImage = cvCreateImage(sz,IPL_DEPTH_8U, 3);</span><br><span class="line">	//Create Image</span><br><span class="line"></span><br><span class="line">	cvPyrDown(Image, NewImage, 7);</span><br><span class="line">	//cvPryup(Image,NewImage,7);</span><br><span class="line">	//若使用这个函数，需要事先建立好一个尺寸为原图一半的图并用IplImage指针指向它.7相当于CV_GAUSSIAN_5x5.</span><br><span class="line"></span><br><span class="line">	cvNamedWindow(&quot;graph1&quot;, 1);</span><br><span class="line">	cvNamedWindow(&quot;graph2&quot;, 1);</span><br><span class="line">	cvShowImage(&quot;graph1&quot;, Image);</span><br><span class="line">	cvShowImage(&quot;graph2&quot;, NewImage);</span><br><span class="line">	cvWaitKey(0);</span><br><span class="line">	cvDestroyAllWindows();</span><br><span class="line">	return 0;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：resize可以一次性将原图像变为任意不为0的尺寸，适合用来做归一化图像操作；而pyrDown与pyrUp适合做长宽比率不变得操作，且调用一次只能长和宽只能变为原来的1/2或者2倍，也即是说面积变为原来的1/4或者4倍。</p>
<p>转载自<a href="http://blog.sina.com.cn/s/blog_4b0020f30101cgok.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4b0020f30101cgok.html</a></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.void cvShowImage( const char* name, const CvArr* image );</span><br></pre></td></tr></table></figure>
<p>Example:</p>
<p>cvShowImage(“Image”,p);</p>
<p>函数cvShowImage 在指定窗口中显示图像.如果窗口创建的时候被设定标志CV_WINDOW_AUTOSIZE,</p>
<p>那么图像将以原始尺寸显示；否则，图像将被伸缩以适合窗口大小.</p>
<p>一条语句只显示一次图像，若后面的语句没有cvWaitKey(0)的话，图像一闪而过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.cvWaitKey(delay)</span><br></pre></td></tr></table></figure>
<p>Example:</p>
<p>cvWaitKey(0);</p>
<p>函数的功能是不断刷新图像，频率时间为delay，单位为ms。</p>
<p>delay为&lt;=0时，无限制等待按键。按键后（在显示出的图片里进行按键），才执行WaitKey之后的语句。另外注意WaitKey单位为毫秒！它的功能可以理解为延时X毫秒后，执行接下来的语句。</p>
<p>函数cvWaitKey无限制的等待按键事件（delay&lt;=0时）；或者延迟”delay”毫秒。返回值为被按键的值，如果超过指定时间则返回-1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.void cvDestroyWindow( const char* name );</span><br></pre></td></tr></table></figure>
<p>Example;</p>
<p>cvDestroyWindow(“Image”);</p>
<p>销毁指定窗口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.cvReleaseImage(&amp;p);//销毁指针</span><br></pre></td></tr></table></figure>
<p>cvReleaseImage函数只是将IplImage*型的变量值赋为NULL，而这个变量本身还是存在的并且在内存中的存储位置不变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.void cvMoveWindow( const char* name, int x, int y );</span><br></pre></td></tr></table></figure>
<p>设定窗口的位置。</p>
<p>name 将被设置的窗口的名字。</p>
<p>x 窗口左上角的x坐标。</p>
<p>y 窗口左上角的y坐标。</p>
<p>函数cvMoveWindow改变窗口的位置。</p>
<p>cvActionTargetMod()</p>
<p>Example:</p>
<p> cv</p>
<p>Get</p>
<p>2D</p>
<p> cv</p>
<p>Create</p>
<p>Image</p>
<p> cv</p>
<p>Name</p>
<p>Window</p>
<p>CV_bitdepth()</p>
<p>S=符号整型</p>
<p>U=无符号整型</p>
<p>F=浮点型</p>
<p>CV_8（位数）U（类型）G（矩阵）1（通道） 一个8位无符号整形单通道矩阵</p>
<p>CV_32FG2 32位浮点型双通道矩阵</p>
<p>图像数据类型：</p>
<p>IPL<em>DEPTH</em><bit_depth>(S|U|F)</bit_depth></p>
<p>IPL_DEPTH_8U 8位无符号整型</p>
<p>头文件：</p>
<cv.h>

<cvaux.h>

<highgui.h>

<ml.h>

<cxcore.h>

<p>基础结构：</p>
<ul>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint" target="_blank" rel="noopener">1 CvPoint</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint2D32f" target="_blank" rel="noopener">2 CvPoint2D32f</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvPoint3D32f" target="_blank" rel="noopener">3 CvPoint3D32f</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSize" target="_blank" rel="noopener">4 CvSize</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSize2D32f" target="_blank" rel="noopener">5 CvSize2D32f</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvRect" target="_blank" rel="noopener">6 CvRect</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvScalar" target="_blank" rel="noopener">7 CvScalar</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvTermCriteria" target="_blank" rel="noopener">8 CvTermCriteria</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvMat" target="_blank" rel="noopener">9 CvMat</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvMatND" target="_blank" rel="noopener">10 CvMatND</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvSparseMat" target="_blank" rel="noopener">11 CvSparseMat</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#IplImage" target="_blank" rel="noopener">12 IplImage</a></li>
<li><a href="http://wiki.opencv.org.cn/index.php/Cxcore%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84#CvArr" target="_blank" rel="noopener">13 CvArr</a></li>
</ul>
<p>其中，CvPoint为二维坐标点整型，2D32F为2维浮点型，以此类推。</p>
<p>CyScalar是一个颜色结构体类，有四个数组元素，分别代表R,G,B,第四个元素通常用来表示透明色.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CvScalar</span><br><span class="line"> &#123;</span><br><span class="line">  double val[4]</span><br><span class="line"> &#125;</span><br><span class="line"> CvScalar;</span><br></pre></td></tr></table></figure>
<p>扩展——</p>
<p>其中Cvpoint</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inline CvPoint cvPoint( int x, int y );</span><br><span class="line">inline CvPoint cvPointFrom32f( CvPoint2D32f point )</span><br></pre></td></tr></table></figure>
<p>分别作用为：返回一个cvPoint值，</p>
<p>将一个2D32f值转换为cvPoint值并返回。</p>
<p>函数原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvLine( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color, int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure>
<p>功能：绘制连接两个点的线段</p>
<ul>
<li><p>img 图像。</p>
</li>
<li><p>pt1 线段的第一个端点。</p>
</li>
<li><p>pt2 线段的第二个端点。</p>
</li>
<li><p>color 线段的颜色。</p>
</li>
<li><p>thickness 线段的粗细程度。</p>
</li>
<li><p>line_type 线段的类型。</p>
<p>8 (or 0) - 8-connected line（8邻接)连接 线。</p>
<p>4 - 4-connected line(4邻接)连接线。</p>
<p>CV_AA - antialiased 线条。</p>
</li>
</ul>
<p>shift 坐标点的小数点位数。</p>
<p>函数cvLine 在图像中的点1和点2之间画一条线段。线段被图像或感兴趣的矩形(ROI rectangle)所裁剪。对于具有整数坐标的non-antialiasing 线条，使用8-连接或者4-连接Bresenham 算法。画粗线条时结尾是圆形的。画 antialiased 线条使用高斯滤波。要指定线段颜色，用户可以使用使用宏CV_RGB( r, g, b )。</p>
<p>而且指定线条颜色的时候用到的宏CV_RGB(r，g，b)定义为#define CV_RGB( r, g, b ) cvScalar( (b), (g), (r), 0 )，由此可见，实际上起作用的颜色是看cvScalar中的b，g，r顺序，线段颜色就不言而喻了</p>
<p>利用CvScalar，CvLine画线:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// qwsds.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;highgui.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CvPoint pt1;</span><br><span class="line">	pt1=cvPoint(100,200);</span><br><span class="line">	printf(&quot;x:%d,y:%d\n&quot;,pt1.x,pt1.y);</span><br><span class="line"></span><br><span class="line">	CvPoint pt2;</span><br><span class="line">	pt2=cvPoint(200,320);</span><br><span class="line">	printf(&quot;x:%d,y:%d\n&quot;,pt2.x,pt2.y);</span><br><span class="line"></span><br><span class="line">	CvScalar color;</span><br><span class="line">	color=cvScalar(100,0,200);//蓝 绿 红。RGB</span><br><span class="line">	printf(&quot;v1:%f v2:%f v3:%f\n&quot;,color.val[0],color.val[1],color.val[2]);</span><br><span class="line"></span><br><span class="line">	IplImage *img=0;</span><br><span class="line">	img=cvLoadImage(&quot;D:\\Blue hills.jpg&quot;);</span><br><span class="line"></span><br><span class="line">	cvLine(img,pt1,pt2,color,2);</span><br><span class="line"></span><br><span class="line">	cvNamedWindow(&quot;draw&quot;);</span><br><span class="line"></span><br><span class="line">	cvShowImage(&quot;draw&quot;,img);</span><br><span class="line"></span><br><span class="line">	cvWaitKey();</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/pre&gt;&lt;pre code_snippet_id=&quot;421021&quot; snippet_file_name=&quot;blog_20140707_14_8402014&quot; name=&quot;code&quot; class=&quot;cpp&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color:#ff0000;&quot;&gt;CvLine&lt;/span&gt;&lt;/strong&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void cvLine( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color,</span><br><span class="line">             int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>img</p>
<p>图像。</p>
</li>
<li><p>pt1</p>
<p>线段的第一个端点。</p>
</li>
<li><p>pt2</p>
<p>线段的第二个端点。</p>
</li>
<li><p>color</p>
<p>线段的颜色。</p>
</li>
<li><p>thickness</p>
<p>线段的粗细程度。</p>
</li>
<li><p>line_type</p>
<p>线段的类型。8 (or 0) - 8-connected line（8邻接)连接 线。4 - 4-connected line(4邻接)连接线。CV_AA - antialiased 线条。</p>
</li>
</ul>
<ul>
<li><p>shift</p>
<p>坐标点的小数点位数。</p>
</li>
</ul>
<p>函数cvLine 在图像中的点1和点2之间画一条线段。线段被图像或感兴趣的矩形(ROI rectangle)所裁剪。对于具有整数坐标的non-antialiasing 线条，使用8-连接或者4-连接Bresenham 算法。画粗线条时结尾是圆形的。画 antialiased 线条使用高斯滤波。要指定线段颜色，用户可以使用使用宏CV_RGB( r, g, b )。</p>
<p>CvSize sz;</p>
<p>设置一个矩形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CvSize sz;</span><br><span class="line">sz=cvSize(640,480);</span><br><span class="line">printf(&quot;width:%d,height:%d\n&quot;,sz.width,sz.height);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IplImage *p;</span><br><span class="line">p=cvCreateImage(sz,IPL_DEPTH_8U,3);//sz矩形的宽，高（将结构体传进去）,深度,颜色通道数）</span><br><span class="line">cvNamedWindow(&quot;Image&quot;);</span><br><span class="line">cvShowImage(&quot;Image&quot;,p);</span><br><span class="line">cvWaitKey(0);</span><br></pre></td></tr></table></figure>
<p>其中cvCreateImage创建了一个矩形！</p>
<p>CvRect矩阵框的偏移量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CvRect</span><br><span class="line"> &#123;</span><br><span class="line">  int x; /* 方形的最左角的x-坐标  */</span><br><span class="line">  int y; /* 方形的最上或者最下角的y-坐标 */</span><br><span class="line">  int width; /* 宽 */</span><br><span class="line">  int height; /* 高 */</span><br><span class="line"> &#125;</span><br><span class="line"> CvRect;</span><br></pre></td></tr></table></figure>
<p>应用：（利用了CvRectangle）</p>
<p>CvRectangle：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void cvRectangle( CvArr* img, CvPoint pt1, CvPoint pt2, CvScalar color,</span><br><span class="line">                  int thickness=1, int line_type=8, int shift=0 );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>img</p>
<p>图像.</p>
</li>
<li><p>pt1</p>
<p>矩形的一个顶点。</p>
</li>
<li><p>pt2</p>
<p>矩形对角线上的另一个顶点</p>
</li>
<li><p>color</p>
<p>线条颜色 (RGB) 或亮度（灰度图像 ）(grayscale image）。</p>
</li>
<li><p>thickness</p>
<p>组成矩形的线条的粗细程度。取负值时（如 CV_FILLED）函数绘制填充了色彩的矩形。</p>
</li>
<li><p>line_type</p>
<p>线条的类型。见cvLine的描述</p>
</li>
<li><p>shift</p>
<p>坐标点的小数点位数。</p>
</li>
</ul>
<p>函数 cvRectangle 通过对角线上的两个顶点绘制矩形。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;highgui.h&quot;</span><br><span class="line"></span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	CvSize sz;//CvSize 数据类型 C大写,定义。</span><br><span class="line">	sz=cvSize(640,480);//给sz赋值。</span><br><span class="line">	printf(&quot;width:%d,height:%d\n&quot;,sz.width,sz.height);</span><br><span class="line">	IplImage *img=0;</span><br><span class="line">	img=cvCreateImage(sz,IPL_DEPTH_8U,3);//创建而不是载入。</span><br><span class="line">	CvRect rect;</span><br><span class="line">	rect=cvRect(50,30,100,150);//左上坐标，长度，宽度。</span><br><span class="line">	CvPoint pt1=cvPoint(rect.x,rect.y);</span><br><span class="line">	CvPoint pt2=cvPoint(rect.x+rect.width,rect.y+rect.height);</span><br><span class="line">	cvRectangle(img,pt1,pt2,cvScalar(0,0,255),2);</span><br><span class="line">	cvNamedWindow(&quot;create&quot;);</span><br><span class="line">	cvShowImage(&quot;create&quot;,img);</span><br><span class="line">	cvWaitKey();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中cvRectangle利用apt1,apt2两个点，和颜色方案cvScalar，以及粗细程度2，将绘制的矩形传递给指针p2,然后在建立的图案区域AAA内显示矩形。</p>
<p>复制图像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IplImage *mp1=cvCloneImage(img);//把图像img复制给mp1.</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;para&quot; style=&quot;margin:15px 0px 5px; text-indent:2em; line-height:24px; font-family:arial,宋体,sans-serif; font-size:14px&quot;&gt;&lt;pre code_snippet_id=&quot;421021&quot; snippet_file_name=&quot;blog_20140707_20_810661&quot; name=&quot;code&quot; class=&quot;cpp&quot; style=&quot;color: rgb(51, 51, 51);&quot;&gt;	cvNamedWindow(&quot;create&quot;);</span><br><span class="line">	cvShowImage(&quot;create&quot;,img);//img需要事先指向图像</span><br><span class="line">	IplImage *p2=cvCloneImage(img);</span><br><span class="line">	cvNamedWindow(&quot;clone&quot;);</span><br><span class="line">	cvShowImage(&quot;clone&quot;,p2);</span><br><span class="line">	cvWaitKey();</span><br></pre></td></tr></table></figure>
<p>​      保存图像到文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int cvSaveImage( const char* filename, const CvArr* image );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>filename </p>
<p>文件名，如果对应的文件已经存在，则将被复盖。</p>
</li>
<li><p>image </p>
<p>要保存的图像。</p>
</li>
</ul>
<p>函数cvSaveImage保存图像到指定文件。图像格式的的选择依赖于filename的扩展名，请参考cvLoadImage。只有8位单通道或者3通道（通道顺序为’BGR’ ）可以使用这个函数保存。如果格式，深度或者通道不符合要求，请先用cvCvtScale 和cvCvtColor转换；或者使用通用的cvSave保存图像为XML或者YAML格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">     IplImage * test=NULL;</span><br><span class="line">     test = cvLoadImage (&quot;D:\\demo.jpg&quot;);</span><br><span class="line">     cvNamedWindow(&quot;test_demo&quot;,1);</span><br><span class="line">	 cvMoveWindow(&quot;test_demo&quot;,800,10);</span><br><span class="line">     cvShowImage(&quot;test_demo&quot;,test);</span><br><span class="line">	 cvSaveImage(&quot;D:\\123.jpg&quot;,test);</span><br><span class="line">     cvWaitKey(0);</span><br><span class="line">     cvDestroyWindow(&quot;test_demo&quot;);</span><br><span class="line">     cvReleaseImage(&amp;test);</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>OpenCV里有两个单词，Image，Window，它们各自代表的是载入的图像(用IplImage指针表示)，放置图像的窗口。<br>1.在存在Window的前提下,即cvNamedWindow(“窗口名”,是否根据Image进行调整的指标.)，<br>2.让IplImage指针指向Image,即cvLoadImage(“Image”,指针名).除去载入的方法外,也可以创建:<br>(1).定义一个CvSize类型的矩形sz.<br>(2).赋予其宽,高.sz=CvSize(640,480)<br>(3).p=cvCreateImage(sz,IPL_DEPTH_8U,3).第二个参数为深度,例为8位无符号整型,3通道.<br>3.再将Image导入Window，才能让Image显示出来,即cvShowImage(Window,image的指针).</p>
<p>另外，除了必要的知识外，大部分函数在使用的时候可以直接在博客开头的Page手册里查阅使用方案，系统全面的文档提供了很高的支持。感觉和Linux查阅技术文档来进行操作有些相同之处。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#iclude&lt;stdio.h&gt;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">	FILE *fp;                  /*定义一个文件指针*/</span><br><span class="line">	int i;</span><br><span class="line">	fp=fopen(&quot;CLIB&quot;, &quot;rb&quot;);    /*打开当前目录名为CLIB的文件只读*/ </span><br><span class="line">	if(fp==NULL)               /*判断文件是否打开成功*/</span><br><span class="line">		puts(&quot;File open error&quot;);/*提示打开不成功*/</span><br><span class="line">	i=fclose(fp);              /*关闭打开的文件*/</span><br><span class="line">	if(i==0)                   /*判断文件是否关闭成功*/</span><br><span class="line">		printf(&quot;O.K&quot;);           /*提示关闭成功*/</span><br><span class="line">	else                </span><br><span class="line">		puts(&quot;File close error&quot;);/*提示关闭不成功*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> int fprintf(FILE <em>stream, char </em>format, <variable-list>);<br>​        int fputs(char <em>string, FILE </em>steam);<br>int fputc(intch, FILE *steam);<br>fprintf() 函数的返回值为实际写入文件中的字符个数(字节数)。如果写错误, 则返回一个负数； fputs()函数返回0时表明将string指针所指的字符串写入文件中的操作成功, 返回非0时,表明写操作失败。  fputc()函数返回一个向文件所写字符的值, 此时写操作成功,否则返回EOF(文件结束结束其值为-1, 在stdio.h中定义)表示写操作错误。   fprintf( ) 函数中格式化的规定与printf( ) 函数相同,所不同的只是fprintf()函数是向文件中写入。而printf()是向屏幕输出。<br>4.文件的顺序读操作函数<br>​        fscanf()、fgets()和fgetc()函数<br>函数fscanf()、fgets()和fgetc()均为文件的顺序读操作函数, 其调用格式 如下:</variable-list></p>
<p>int fscanf(FILE <em>stream, char </em>format, <address-list>);<br>​        char fgets(char <em>string, int n, FILE </em>steam);<br>​        int fgetc(FILE *steam);<br>fscanf()函数的用法与scanf()函数相似,只是它是从文件中读到信息。 fscanf()函数的返回值为EOF(即-1), 表明读错误, 否则读数据成功。  fgets()函数从文件中读取至多n-1个字符(n用来指定字符数), 并把它们放入string指向的字符串中, 在读入之后自动向字符串未尾加一个空字符, 读成功返回string指针,  失败返回一个空指针。  fgetc()函数返回文件当前位置的一个字符,读错误时返回EOF。 </address-list></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void cvSmooth( const CvArr* src, CvArr* dst,</span><br><span class="line">               int smoothtype=CV_GAUSSIAN,</span><br><span class="line">               int param1=3, int param2=0, double param3=0, double param4=0 );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>src</p>
<p>输入图像.</p>
</li>
<li><p>dst</p>
<p>输出图像.</p>
</li>
<li><p>smoothtype</p>
<p>平滑方法:CV_BLUR_NO_SCALE (简单不带尺度变换的模糊) - 对每个象素的 param1×param2 领域求和。如果邻域大小是变化的，可以事先利用函数 cvIntegral 计算积分图像。CV_BLUR (simple blur) - 对每个象素param1×param2邻域 求和并做尺度变换 1/(param1•param2).CV_GAUSSIAN (gaussian blur) - 对图像进行核大小为 param1×param2 的高斯卷积CV_MEDIAN (median blur) - 对图像进行核大小为param1×param1 的中值滤波 (i.e. 邻域是方的).CV_BILATERAL (双向滤波) - 应用双向 3x3 滤波，彩色 sigma=param1，空间 sigma=param2. 关于双向滤波，可参考<a href="http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html" target="_blank" rel="noopener">http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html</a></p>
</li>
</ul>
<ul>
<li><p>param1</p>
<p>平滑操作的第一个参数.</p>
</li>
<li><p>param2</p>
<p>平滑操作的第二个参数. 对于简单/非尺度变换的高斯模糊的情况，如果param2的值 为零，则表示其被设定为param1。</p>
</li>
<li><p>param3</p>
<p>对应高斯参数的 Gaussian sigma (标准差). 如果为零，则标准差由下面的核尺寸计算：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sigma = (n/2 - 1)*0.3 + 0.8, 其中 n=param1 对应水平核,</span><br><span class="line">                                 n=param2 对应垂直核.</span><br></pre></td></tr></table></figure>
<p>对小的卷积核 (3×3 to 7×7) 使用如上公式所示的标准 sigma 速度会快。如果 param3 不为零，而 param1 和 param2 为零，则核大小有 sigma 计算 (以保证足够精确的操作).</p>
<p>函数 cvSmooth 可使用上面任何一种方法平滑图像。每一种方法都有自己的特点以及局限。</p>
<p>没有缩放的图像平滑仅支持单通道图像，并且支持8位到16位的转换(与cvSobel和cvaplace相似)和32位浮点数到32位浮点数的变换格式。</p>
<p>简单模糊和高斯模糊支持 1- 或 3-通道, 8-比特 和 32-比特 浮点图像。这两种方法可以（in-place）方式处理图像。</p>
<p>中值和双向滤波工作于 1- 或 3-通道， 8-位图像，但是不能以 in-place 方式处理图像.</p>
<ul>
<li><p>中值滤波</p>
<p>中值滤波法是一种非线性平滑技术，它将每一象素点的灰度值设置为该点某邻域窗口内的所有象素点灰度值的中值。实现方法：</p>
</li>
</ul>
<ol>
<li>通过从图像中的某个采样窗口取出奇数个数据进行排序</li>
<li>用排序后的中值取代要处理的数据即可</li>
</ol>
<p>中值滤波法对消除椒盐噪音非常有效，在光学测量条纹图象的相位分析处理方法中有特殊作用，但在条纹中心分析方法中作用不大。中值滤波在图像处理中,常用于用来保护边缘信息,是经典的平滑噪声的方法</p>
<ul>
<li>中值滤波原理</li>
</ul>
<p>中值滤波是基于排序统计理论的一种能有效抑制噪声的非线性信号处理技术，中值滤波的基本原理是把数字图像或数字序列中一点的值用该点的一个拎域中各点值的中值代替，让周围的像素值接近的值，从而消除孤立的噪声点。方法是去某种结构的二维滑动模板，将板内像素按照像素值的大小进行排序，生成单调上升（或下降）的为二维数据序列。二维中值滤波输出为g（x,y）=med{f(x-k,y-l),(k,l∈W)} ，其中,f(x,y)，g(x,y)分别为原始图像和处理后图像。W为二维模板，通常为2<em>2，3</em>3区域，也可以是不同的的形状，如线状，圆形，十字形，圆环形等。</p>
<ul>
<li>高斯滤波</li>
</ul>
<p>高斯滤波实质上是一种信号的滤波器，其用途是信号的平滑处理，我们知道数字图像用于后期应用，其噪声是最大的问题，由于误差会累计传递等原因，很多图像处理教材会在很早的时候介绍Gauss滤波器，用于得到信噪比SNR较高的图像（反应真实信号）。于此相关的有Gauss-Lapplace变换，其实就是为了得到较好的图像边缘，先对图像做Gauss平滑滤波，剔除噪声，然后求二阶导矢，用二阶导的过零点确定边缘，在计算时也是频域乘积=&gt;空域卷积。</p>
<p>滤波器就是建立的一个数学模型，通过这个模型来将图像数据进行能量转化，能量低的就排除掉，噪声就是属于低能量部分</p>
<p>其实编程运算的话就是一个模板运算，拿图像的八连通区域来说，中间点的像素值就等于八连通区的像素值的均值，这样达到平滑的效果</p>
<p>若使用理想滤波器，会在图像中产生振铃现象。采用高斯滤波器的话，系统函数是平滑的，避免了振铃现象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例程序：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage *p = cvLoadImage(&quot;D:\\1234.jpg&quot;, 1);</span><br><span class="line">	IplImage *out = cvCreateImage(cvGetSize(p), IPL_DEPTH_8U, 3);</span><br><span class="line">	cvNamedWindow(&quot;cv_in&quot;, 1);</span><br><span class="line">	cvNamedWindow(&quot;cv_out&quot;, 1);</span><br><span class="line">	</span><br><span class="line">	cvShowImage(&quot;cv_in&quot;, p);</span><br><span class="line">	cvWaitKey(1024);</span><br><span class="line">	</span><br><span class="line">	cvSmooth(p, out, CV_GAUSSIAN, 3, 3);//from head file &lt;cv.h&gt;.</span><br><span class="line">	cvShowImage(&quot;cv_out&quot;, out);</span><br><span class="line">	cvWaitKey(1024);</span><br><span class="line"></span><br><span class="line">	//cvReleaseImage(&amp;p);</span><br><span class="line">	cvReleaseImage(&amp;out);</span><br><span class="line">	//加上上述两行就会报错，原因：</span><br><span class="line">	/*</span><br><span class="line">	在写相关程序的时候，在程序的结尾处释放前段自定义的变量。使用函数cvReleaseImage(&amp;pFrame);时程序在调试结束后报错，</span><br><span class="line">	指明是在释放内存时出错。经过看前辈们遇到的相同的问题。先总结如下：</span><br><span class="line"></span><br><span class="line">    cvReleaseImage()和cvCreateImage()相对应的。在程序中如果没有“创建”就不能“释放”。</span><br><span class="line">	所以，如果我们使用的指针不是用cvCreateImage()创建的。</span><br><span class="line">	如果使用cvReleaseImage()就会出现错误。如果大家担心指针不释放会引发内存的错误。</span><br><span class="line">	可以使用pFrame = NULL;来释放内存。</span><br><span class="line">	因为cvReleaseImage()的作用就是将作为参数的那个指针设置为NULL;</span><br><span class="line"></span><br><span class="line">	如修改后，只ReleaseOUT就不会出错.</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	cvDestroyAllWindows();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CvCapture 视频获取结构</span><br></pre></td></tr></table></figure>
<h2 id="cvCreateFileCapture"><a href="#cvCreateFileCapture" class="headerlink" title="cvCreateFileCapture"></a>cvCreateFileCapture</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CvCapture* cvCreateFileCapture( const char* filename );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>filename </p>
<p>视频文件名。</p>
</li>
</ul>
<p>函数cvCreateFileCapture给指定文件中的视频流分配和初始化CvCapture结构。</p>
<p>当分配的结构不再使用的时候，它应该使用cvReleaseCapture函数释放掉。</p>
<h2 id="cvReleaseCapture"><a href="#cvReleaseCapture" class="headerlink" title="cvReleaseCapture"></a>cvReleaseCapture</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void cvReleaseCapture( CvCapture** capture );</span><br></pre></td></tr></table></figure>
<ul>
<li><p>capture </p>
<p>视频获取结构指针。</p>
</li>
</ul>
<p>函数cvReleaseCapture释放由函数cvCreateFileCapture或者cvCreateCameraCapture分配的CvCapture结构。</p>
<p>注:若从capture中使用cvQueryFrame获取图像指针，在releaseCapture的时候同时函数释放图像指针，用户不用再自己释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage *p; </span><br><span class="line">	CvCapture *capture = cvCreateFileCapture(&quot;D:\\123.avi&quot;);</span><br><span class="line">	cvNamedWindow(&quot;Image&quot;, 1);</span><br><span class="line">	while (1)</span><br><span class="line">	&#123;</span><br><span class="line">		p = cvQueryFrame(capture);</span><br><span class="line">		if (!p)</span><br><span class="line">			break;//if can&apos;t load image,p is NULL,and break.</span><br><span class="line">		cvShowImage(&quot;Image&quot;, p);</span><br><span class="line">		char c = cvWaitKey(1024);</span><br><span class="line">		if (c == 27)</span><br><span class="line">			break;//if you press Esc,c will get 27.</span><br><span class="line">	&#125;</span><br><span class="line">	cvReleaseCapture(&amp;capture);</span><br><span class="line">	cvReleaseImage(&amp;p);</span><br><span class="line">	cvDestroyWindow(Image);</span><br><span class="line">	return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像像素的获取：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 访问图像像素.cpp : 定义控制台应用程序的入口点。</span><br><span class="line">//way:</span><br><span class="line">//IplImage *Img = cvCreateImage(cvSize(640, 580), IPL_DEPTH_8U, 3);</span><br><span class="line">//1.间接访问:get*D,set*D...</span><br><span class="line">//2.直接访问:((*uchar)ImageData+i*Image-&gt;width)[j]=111;</span><br><span class="line">/*</span><br><span class="line">单通道：</span><br><span class="line">IplImage*img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,1);</span><br><span class="line">int height     =img-&gt;height; </span><br><span class="line">int width=img-&gt;width;  </span><br><span class="line">int step       =img-&gt;widthStep/sizeof(uchar); </span><br><span class="line">uchar* data    =(uchar*)img-&gt;imageData; </span><br><span class="line">data[i*step+j]=111;</span><br><span class="line">多通道：</span><br><span class="line">IplImage*img=cvCreateImage(cvSize(640,480),IPL_DEPTH_8U,3);  </span><br><span class="line">int height     =img-&gt;height; </span><br><span class="line">int width      =img-&gt;width;  </span><br><span class="line">int step       =img-&gt;widthStep/sizeof(uchar); </span><br><span class="line">int channels   =img-&gt;nChannels;  </span><br><span class="line">uchar* data    =(uchar*)img-&gt;imageData; </span><br><span class="line">data[i*step+j*channels+k]=111;</span><br><span class="line">如果为浮点型矩阵，而非字节型，那就把uchar改为float.</span><br><span class="line">*/</span><br><span class="line">//3.利用宏:CV_IMAGE_ELEM</span><br><span class="line">//单通道:CV_IMAGE_ELEM(img,uchar,i,j)=111; img为IplImage指针</span><br><span class="line">//多通道:CV_IMAGE_ELEM(srcimg,uchar,i,j*3+0)=111;</span><br><span class="line"></span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage *Image = cvCreateImage(cvSize(640,480), IPL_DEPTH_8U, 3);</span><br><span class="line">	CvScalar color;</span><br><span class="line">	int i, j;</span><br><span class="line">	for (i = 0; i &lt; 50; i++)//循环使i*j区域内的点全部变为黑色.</span><br><span class="line">	&#123;</span><br><span class="line">		for (j = 50; j &lt; 100; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			color = cvGet2D(Image, i, j);//get(x,y)&apos;s color.cal[0],color.cal[1].</span><br><span class="line"></span><br><span class="line">			//printf(&quot;cal0:%d\ncal1:%d\ncal2:%d\n&quot;, color.val[0], color.val[1], color.val[2]);</span><br><span class="line">			//若为单通道图像，只修改color.val[0]即可.</span><br><span class="line">			color.val[0] = 0;</span><br><span class="line">			color.val[1] = 0;</span><br><span class="line">			color.val[2] = 0;</span><br><span class="line">			cvSet2D(Image, i, j, color);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cvNamedWindow(&quot;ImageA&quot;, 1);</span><br><span class="line">	cvShowImage(&quot;ImageA&quot;, Image);</span><br><span class="line">	cvWaitKey(0);</span><br><span class="line">	cvDestroyAllWindows();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而cvSetXD中，固定参数为IplImage指针，X个Int类型的参数表示图上的坐标，以及可以将每个坐标的颜色分配修改的Scalar类。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像的边缘检测（根据像素梯度）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdafx.h&gt;</span><br><span class="line">#include &lt;highgui.h&gt;</span><br><span class="line">#include &lt;cv.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage *Image;</span><br><span class="line">	IplImage *out;</span><br><span class="line">	Image = cvLoadImage(&quot;D:\\1234.jpg&quot;, 0);</span><br><span class="line">	out = cvCreateImage(cvGetSize(Image), IPL_DEPTH_8U, 1);</span><br><span class="line">	cvNamedWindow(&quot;ImageA&quot;, 1);</span><br><span class="line">	cvNamedWindow(&quot;ImageB&quot;, 1);</span><br><span class="line">	cvCanny(Image, out, 50, 75, 3);</span><br><span class="line">	//cvCanny的第一个第二个参数均为指向单通道图片的IplImage.</span><br><span class="line">	//第三,第四个参数为阀值，一个大一个小，应当根据图像的梯度设定.</span><br><span class="line">	//第五个参数为canny算子3.</span><br><span class="line">	cvShowImage(&quot;ImageB&quot;, out);</span><br><span class="line">	cvWaitKey(0);</span><br><span class="line">	cvDestroyAllWindows();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>canny算子实质：如果一个像素的梯度大与上限值，则被认为是边缘像素，如果小于下限阈值，则被抛弃，那么如果该点的梯度位于两者之间，则当其与高于上限值的像素点连接时我们才保留，否则删除。另：当两个阀值等比例同时增大时（比如从50，150增加到100，300，比例并未改变），则图像上的杂点变少（边缘更加清晰）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于梯度的计算：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用自：http://www.cnblogs.com/justany/archive/2012/11/23/2782660.html</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像的边缘图像的边缘从数学上是如何表示的呢？图像的边缘上，邻近的像素值应当显著地改变了。而在数学上，导数是表示改变快慢的一种方法。梯度值的大变预示着图像中内容的显著变化了。用更加形象的图像来解释,假设我们有一张一维图形。下图中灰度值的“跃升”表示边缘的存在：　　　　使用一阶微分求导我们可以更加清晰的看到边缘“跃升”的存在(这里显示为高峰值)：　　　　由此我们可以得出：边缘可以通过定位梯度值大于邻域的相素的方法找到。 卷积卷积可以近似地表示求导运算。那么卷积是什么呢？卷积是在每一个图像块与某个算子（核）之间进行的运算。核？！核就是一个固定大小的数值数组。该数组带有一个锚点 ，一般位于数组中央。 可是这怎么运算啊？假如你想得到图像的某个特定位置的卷积值，可用下列方法计算：将核的锚点放在该特定位置的像素上，同时，核内的其他值与该像素邻域的各像素重合；将核内各值与相应像素值相乘，并将乘积相加；将所得结果放到与锚点对应的像素上；对图像所有像素重复上述过程。用公式表示上述过程如下：　　　　在图像边缘的卷积怎么办呢？计算卷积前，OpenCV通过复制源图像的边界创建虚拟像素，这样边缘的地方也有足够像素计算卷积了。 近似梯度比如内核为3时。首先对x方向计算近似导数：然后对y方向计算近似导数：然后计算梯度：当然你也可以写成：求梯度的例程序：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;#include &quot;opencv2/imgproc/imgproc.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int main( int argc, char** argv )&#123;</span><br><span class="line"></span><br><span class="line">    Mat src, src_gray;</span><br><span class="line">    Mat grad;</span><br><span class="line">    char* window_name = &quot;求解梯度&quot;;</span><br><span class="line">    int scale = 1;</span><br><span class="line">    int delta = 0;</span><br><span class="line">    int ddepth = CV_16S;</span><br><span class="line"></span><br><span class="line">    int c;</span><br><span class="line"></span><br><span class="line">    src = imread( argv[1] );</span><br><span class="line"></span><br><span class="line">    if( !src.data )&#123; </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //高斯模糊</span><br><span class="line">    GaussianBlur( src, src, Size(3,3), 0, 0, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">    //转成灰度图</span><br><span class="line">    cvtColor( src, src_gray, CV_RGB2GRAY );</span><br><span class="line"></span><br><span class="line">    namedWindow( window_name, CV_WINDOW_AUTOSIZE );</span><br><span class="line"></span><br><span class="line">    Mat grad_x, grad_y;</span><br><span class="line">    Mat abs_grad_x, abs_grad_y;</span><br><span class="line"></span><br><span class="line">    Sobel( src_gray, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_x, abs_grad_x );</span><br><span class="line"></span><br><span class="line">    Sobel( src_gray, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_y, abs_grad_y );</span><br><span class="line"></span><br><span class="line">    addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );</span><br><span class="line"></span><br><span class="line">    imshow( window_name, grad );</span><br><span class="line"></span><br><span class="line">    waitKey(0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>Sobel函数</p>
<blockquote>
<p>索贝尔算子（Sobel operator）计算。</p>
<ul>
<li>C++:<code></code>void <code>Sobel</code>(InputArray src, OutputArray dst, int ddepth, int dx, int dy, int ksize=3, double scale=1, double delta=0, intborderType=BORDER_DEFAULT )</li>
</ul>
</blockquote>
<p>代码注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在x方向求图像近似导数</span><br><span class="line">Sobel( src_gray, grad_x, ddepth, 1, 0, 3, scale, delta, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">//在y方向求图像近似导数</span><br><span class="line">Sobel( src_gray, grad_y, ddepth, 0, 1, 3, scale, delta, BORDER_DEFAULT );</span><br></pre></td></tr></table></figure>
<p>如果我们打印上面两个输出矩阵，可以看到grad_x和grad_y中的元素有正有负。</p>
<p>当然，正方向递增就是正的，正方向递减则是负值。</p>
<p>这很重要，我们可以用来判断梯度方向。</p>
<p>convertScaleAbs函数</p>
<blockquote>
<p>线性变换转换输入数组元素成8位无符号整型。</p>
<ul>
<li>C++:<code></code>void <code>convertScaleAbs</code>(InputArray src, OutputArray dst, double alpha=1, double beta=0)</li>
</ul>
<p>对于每个输入数组的元素函数<code>convertScaleAbs</code> 进行三次操作依次是：缩放，得到一个绝对值，转换成无符号8位类型。</p>
<p><img src="http://docs.opencv.org/_images/math/5ca28093f0a8eca32bcf6d54a644b4bcaa07ad72.png" alt="\texttt{dst} (I)= \texttt{saturate\_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} +  \texttt{beta} |)"></p>
<p>对于多通道矩阵，该函数对各通道独立处理。如果输出不是8位，将调用<code>Mat::convertTo</code>方法并计算结果的绝对值，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; Mat_&lt;float&gt; A(30,30);</span><br><span class="line">&gt; randu(A, Scalar(-100), Scalar(100));</span><br><span class="line">&gt; Mat_&lt;float&gt; B = A*5 + 3;</span><br><span class="line">&gt; B = abs(B);</span><br><span class="line">&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>为了能够用图像显示，提供一个直观的图形，我们利用该方法，将-256 — 255的导数值，转成0 — 255的无符号8位类型。</p>
<p>addWeighted函数</p>
<blockquote>
<p>计算两个矩阵的加权和。</p>
<ul>
<li>C++:<code></code>void <code>addWeighted</code>(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, intdtype=-1)</li>
</ul>
<p>函数<code>addWeighted</code> 两个数组的加权和公式如下：</p>
<p>　　　　<img src="http://docs.opencv.org/_images/math/160c3479896ac799bb5c7d260a052e6b35c463ef.png" alt="\texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +  \texttt{gamma} )"></p>
<p>在多通道情况下，每个通道是独立处理的，该函数可以被替换成一个函数表达式：</p>
<p>　　　　dst = src1<em>alpha + src2</em>beta + gamma;</p>
</blockquote>
<p>利用convertScaleAbs和addWeighted，我们可以对梯度进行一个可以用图像显示的近似表达。</p>
<p>这样我们就可以得到下面的效果：</p>
<p><img src="http://docs.opencv.org/_images/Sobel_Derivatives_Tutorial_Result.jpg" alt="Result of applying Sobel operator to lena.jpg"></p>
<p>梯度方向</p>
<p>但有时候边界还不够，我们希望得到图片色块之间的关系，或者研究样本的梯度特征来对机器训练识别物体时候，我们还需要梯度的方向。</p>
<p>二维平面的梯度定义为：</p>
<p>　　　　<img src="http://pic002.cnblogs.com/images/2012/372204/2012112220142684.jpg" alt="img"></p>
<p>这很好理解，其表明颜色增长的方向与x轴的夹角。</p>
<p>但Sobel算子对于沿x轴和y轴的排列表示的较好，但是对于其他角度表示却不够精确。这时候我们可以使用Scharr滤波器。</p>
<p>Scharr滤波器的内核为：</p>
<p>　　　　<img src="http://docs.opencv.org/_images/math/d1340f7bb6665e67c94c196809095f23054fca2c.png" alt="G_{x} = \begin{bmatrix}-3 &amp; 0 &amp; +3  \\-10 &amp; 0 &amp; +10  \\-3 &amp; 0 &amp; +3\end{bmatrix}G_{y} = \begin{bmatrix}-3 &amp; -10 &amp; -3  \\0 &amp; 0 &amp; 0  \\+3 &amp; +10 &amp; +3\end{bmatrix}"></p>
<p>这样能提供更好的角度信息，现在我们修改原程序，改为使用Scharr滤波器进行计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;#include &quot;opencv2/imgproc/imgproc.hpp&quot;</span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace cv;</span><br><span class="line"></span><br><span class="line">int main( int argc, char** argv )&#123;</span><br><span class="line"></span><br><span class="line">    Mat src, src_gray;</span><br><span class="line">    Mat grad;</span><br><span class="line">    char* window_name = &quot;梯度计算&quot;;</span><br><span class="line">    int scale = 1;</span><br><span class="line">    int delta = 0;</span><br><span class="line">    int ddepth = CV_16S;</span><br><span class="line"></span><br><span class="line">    int c;</span><br><span class="line"></span><br><span class="line">    src = imread( argv[1] );</span><br><span class="line"></span><br><span class="line">    if( !src.data )&#123; </span><br><span class="line">        return -1; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GaussianBlur( src, src, Size(3,3), 0, 0, BORDER_DEFAULT );</span><br><span class="line"></span><br><span class="line">    cvtColor( src, src_gray, CV_RGB2GRAY );</span><br><span class="line"></span><br><span class="line">    namedWindow( window_name, CV_WINDOW_AUTOSIZE );</span><br><span class="line"></span><br><span class="line">    Mat grad_x, grad_y;</span><br><span class="line">    Mat abs_grad_x, abs_grad_y;</span><br><span class="line"></span><br><span class="line">    //改为Scharr滤波器计算x轴导数</span><br><span class="line">    Scharr( src_gray, grad_x, ddepth, 1, 0, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_x, abs_grad_x );</span><br><span class="line"></span><br><span class="line">    //改为Scharr滤波器计算y轴导数</span><br><span class="line">    Scharr( src_gray, grad_y, ddepth, 0, 1, scale, delta, BORDER_DEFAULT );</span><br><span class="line">    convertScaleAbs( grad_y, abs_grad_y );</span><br><span class="line"></span><br><span class="line">    addWeighted( abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad );</span><br><span class="line"></span><br><span class="line">    imshow( window_name, grad );</span><br><span class="line"></span><br><span class="line">    waitKey(0);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;&lt;/span&gt;&lt;strong style=&quot;font-size:24px;&quot;&gt;</span><br><span class="line">&lt;/strong&gt;</span><br></pre></td></tr></table></figure>
<p>Scharr函数接受参数与Sobel函数相似，这里就不叙述了。</p>
<p>下面我们通过divide函数就能得到一个x/y的矩阵。</p>
<blockquote>
<p>对两个输入数组的每个元素执行除操作。</p>
<ul>
<li>C++:<code></code>void <code>divide</code>(InputArray src1, InputArray src2, OutputArray dst, double scale=1, int dtype=-1)</li>
</ul>
<ul>
<li>C++:<code></code>void <code>divide</code>(double scale, InputArray src2, OutputArray dst, int dtype=-1)</li>
</ul>
<p>该函数对两个数组进行除法：</p>
<p>　　<img src="http://docs.opencv.org/_images/math/b95a5073fc087b8fc404bc7795982e1570891bd3.png" alt="\texttt{dst(I) = saturate(src1(I)*scale/src2(I))}"></p>
<p>或则只是缩放系数除以一个数组：</p>
<p>　　<img src="http://docs.opencv.org/_images/math/8d762e1a527b3613404ec26a98faffd43d1ceb78.png" alt="\texttt{dst(I) = saturate(scale/src2(I))}"></p>
<p>这种情况如果src2是0，那么dst也是0。不同的通道是独立处理的。</p>
</blockquote>
</cxcore.h></ml.h></highgui.h></cvaux.h></cv.h>
                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/11/OpenCV-随笔记录/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/11/HDU-1247-字典树/">
                            HDU 1247 字典树
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-11T14:51:50+08:00">
	
		    2月 11, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <!-- excerpt CSDN 博客搬家-->
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 26</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">NumTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    NumTree ans[MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NumTree <span class="title">init</span><span class="params">(NumTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    T=<span class="keyword">new</span> struct node;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;tag=<span class="number">0</span>;</span><br><span class="line">        T-&gt;ans[i]=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T,S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            S=<span class="keyword">new</span> struct node;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                S-&gt;ans[j]=<span class="literal">NULL</span>;</span><br><span class="line">                S-&gt;tag=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q-&gt;ans[id]=S;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Q-&gt;tag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Stack;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;tag &amp;&amp; i&lt;len)<span class="comment">//find sepraste point</span></span><br><span class="line">        &#123;</span><br><span class="line">            Stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!Stack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now=Stack.front();</span><br><span class="line">        now++;</span><br><span class="line">        <span class="keyword">bool</span> OK=<span class="literal">true</span>;</span><br><span class="line">        Stack.pop();</span><br><span class="line">        Q=T;</span><br><span class="line">        <span class="keyword">while</span>(str[now])</span><br><span class="line">        &#123;</span><br><span class="line">            id=str[now++]-<span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span>(Q-&gt;ans[id]==<span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                OK=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(OK &amp;&amp; Q-&gt;tag)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">50011</span>][<span class="number">20</span>];</span><br><span class="line">    NumTree T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    T=init(T);</span><br><span class="line">    <span class="keyword">while</span>(gets(str[x]) &amp;&amp; str[x][<span class="number">0</span>]!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(T,str[x]);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>;u&lt;x;u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(find(T,str[u])==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;str[u]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>搞了一下午····</p>
<p>不得不说还是有一些收获，RE的次数最多，</p>
<p>这里要说一下，RE分两种，一种越界，一种是栈溢出，</p>
<p>这里在定义str的时候，</p>
<p>如果定义str[50001][100],就会栈溢出，可见字典树对字符长度的要求很高，不能太长。</p>
<p>整个代码的思路就是在insert同时的时候标记，一个字符如果是一个字符串的结尾字符，那么标记，</p>
<p>在find的时候，如果找到了一个标记，找到了A个标记，说明这个字符串里含有A个字符串，但无法确定这A个字符串是否是紧邻的，这里需要用STACK或者QUEUE，最好还是用STACK，依次记录有标记的下标，然后从后往前开始查询，</p>
<p>这里还有一个小细节，在查询的时候now++,因为top回来的now是一个字符的结尾，重新遍历的时候应该是从找到标记的字符的后一个字符开始。</p>
<p>然后如果有两个以上标记是怎么回事呢？</p>
<p>如果</p>
<p>abcdefg</p>
<p>1001001</p>
<p>有三个标记，这时候从最后一个1开始找，然后从倒数第二个1找，而这里的1代表，至少字典里有a,abcd,abcdefg三个字符串（也可能有defg,bcd等等），也就是说我从标记的下一个字符开始找起，标记的前半部分已经肯定在字符串里了（也就是组成该字符串的前半段），只需要证明从标记开始的字符串也在字典树里，那么就满足该字符串由两个字符串构成，输出即可。</p>
<p>这题还有一个思路，就是把每一个字符串在不同位置“砍一刀”，变成两个字符串，然后find(str1)find(str2),如果都能找到，那么就说明它（这个字符串）有两个字符串构成，这个代码我也实现了，但是不知道为什么一直RE，可能是迭代或者递归的层数太多了（find要递归，如果字符串很长的话，也要砍很多刀）。暂时我还没有想到比较好的优化方案。砍刀也许可以用二分查找实现，但那仍然依赖输入。对效率提升不一定十分明显。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 26</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">NumTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NumTree ans[MAX];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NumTree <span class="title">init</span><span class="params">(NumTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    T=<span class="keyword">new</span> struct node;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">        T-&gt;ans[i]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T,S=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            S=<span class="keyword">new</span> struct node;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX;j++)</span><br><span class="line">                S-&gt;ans[j]=<span class="literal">NULL</span>;</span><br><span class="line">            Q-&gt;ans[id]=S;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(NumTree T,<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NumTree Q=T;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">int</span> i,id;</span><br><span class="line">    <span class="keyword">int</span> tag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=str[i]-<span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span>(Q-&gt;ans[id]!=<span class="literal">NULL</span>)</span><br><span class="line">            Q=Q-&gt;ans[id];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tag=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(NumTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;ans[i]!=<span class="literal">NULL</span>)</span><br><span class="line">            FreeTree(T-&gt;ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">50011</span>][<span class="number">100</span>];</span><br><span class="line">    NumTree T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    T=init(T);</span><br><span class="line">    <span class="keyword">while</span>(gets(str[x]) &amp;&amp; str[x][<span class="number">0</span>]!=<span class="string">'\0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(T,str[x]);</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">for</span>(u=<span class="number">0</span>;u&lt;x;u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(str[u]);</span><br><span class="line">        <span class="keyword">char</span> str1[<span class="number">100</span>],str2[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span>(k&lt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">                str1[i]=str[u][i];</span><br><span class="line">            str1[i]=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;i&lt;len;i++,j++)</span><br><span class="line">                str2[j]=str[u][i];</span><br><span class="line">            str2[j]=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(find(T,str1) &amp;&amp; find(T,str2))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str[u]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//FreeTree(T);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/11/HDU-1247-字典树/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/11/HDU-3790-双权最短路/">
                            HDU 3790 双权最短路
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-11T14:51:35+08:00">
	
		    2月 11, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <!-- excerpt CSDN 博客搬家-->
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 99999</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> cost[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=MAX;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=MAX;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">map</span>[i][j]=<span class="number">0</span>;</span><br><span class="line">				cost[i][j]=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">map</span>[i][j]=INF;</span><br><span class="line">				cost[i][j]=INF;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">int</span> next,minc;</span><br><span class="line">	<span class="keyword">int</span> dist[MAX],visit[MAX],value[MAX];</span><br><span class="line">	<span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dist[i]=<span class="built_in">map</span>[start][i];</span><br><span class="line">		value[i]=cost[start][i];</span><br><span class="line">	&#125;</span><br><span class="line">	visit[start]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		minc=INF;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visit[j] &amp;&amp; minc&gt;dist[j])</span><br><span class="line">			&#123;</span><br><span class="line">				minc=dist[j];</span><br><span class="line">				next=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		visit[next]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!visit[j] &amp;&amp; <span class="built_in">map</span>[next][j]&lt;INF)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(dist[j]&gt;dist[next]+<span class="built_in">map</span>[next][j])</span><br><span class="line">				&#123;</span><br><span class="line">					dist[j]=dist[next]+<span class="built_in">map</span>[next][j];</span><br><span class="line">					value[j]=value[next]+cost[next][j];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(dist[j]==(dist[next]+<span class="built_in">map</span>[next][j]))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(value[j]&gt;value[next]+cost[next][j])</span><br><span class="line">						value[j]=value[next]+cost[next][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,dist[end],value[end]);</span><br><span class="line">	<span class="comment">//cout&lt;&lt;dist[end]&lt;&lt;' '&lt;&lt;value[end]&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> start,end;</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x,y;</span><br><span class="line">			<span class="keyword">int</span> time,<span class="built_in">cos</span>;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;time&gt;&gt;<span class="built_in">cos</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">map</span>[x][y]&gt;time)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">map</span>[x][y]=<span class="built_in">map</span>[y][x]=time;</span><br><span class="line">				cost[x][y]=cost[y][x]=<span class="built_in">cos</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[x][y]==time)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(cost[x][y]&gt;<span class="built_in">cos</span>)</span><br><span class="line">					cost[x][y]=cost[y][x]=<span class="built_in">cos</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;start&gt;&gt;end;</span><br><span class="line">		dijkstra(start,end);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这种题需要注意的就两点，特别重要的两点，初始化，和输入的设置（if语句），再就是Dijastra在更新时候的代码语句设置了。</p>
<p>这道题我在Virtual judge上做的，有一个很奇怪的情况。。。就是如果用cout,那就RE了，但用printf,就AC了（G++提交），然后如果用cin,cout组合，用C++提交，就WA了=，=</p>
<p>不懂是为什么=，=感觉好神奇</p>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/11/HDU-3790-双权最短路/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom" itemscope itemType="http://schema.org/BlogPosting">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title" itemprop="headline">
                    
                        <a class="link-unstyled" href="/2018/02/11/HDU2544-Floyd/">
                            HDU2544 Floyd
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time itemprop="datePublished" datetime="2018-02-11T14:51:17+08:00">
	
		    2月 11, 2018
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/algorithm/">algorithm</a>


    
</div>

            </div>
            
                <div class="postShorten-content" itemprop="articleBody">
                    <!-- excerpt CSDN 博客搬家-->
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 9999999</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j)</span><br><span class="line">				<span class="built_in">map</span>[i][j]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[j][i]=INF;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j,k;</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">map</span>[i][j]&gt;<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j])</span><br><span class="line">					<span class="built_in">map</span>[i][j]=<span class="built_in">map</span>[i][k]+<span class="built_in">map</span>[k][j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> x,y;</span><br><span class="line">			<span class="keyword">int</span> price;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;price;</span><br><span class="line">			x--,y--;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">map</span>[x][y]&gt;price)</span><br><span class="line">				<span class="built_in">map</span>[x][y]=<span class="built_in">map</span>[y][x]=price;</span><br><span class="line">		&#125;</span><br><span class="line">		floyd();</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">map</span>[<span class="number">0</span>][n<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码本身不难，Floyd实现只是三个循环，但这道题需要注意的一些小问题让我WA了不少次.</p>
<ul>
<li>初始化，MAX和INF这两个预编译参数最好分开来写。</li>
<li>对Map的初始化需要考虑对角线上的元素为零，其余为INF，此外，每次初始化循环上限应为MAX，而非输入的顶点数。</li>
<li>input过程中，根据输入时刻更新Map[x][y]的值（即cin&gt;&gt;后的if语句）</li>
</ul>

                    
                        

                    
                    
                        <p>
                            <a href="/2018/02/11/HDU2544-Floyd/#post-footer" class="postShorten-excerpt_link link">
                                评论和共享
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
        
          <li class="pagination-next">
            <a class="btn btn--default btn--small" href="/archives/2018/02/page/2/">
              <span>Next</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">第 1 页 共 3 页</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2018 Tianyou Pan. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/handface.jpg" alt="author‘s picture"/>
        
            <h4 id="about-card-name">Tianyou Pan</h4>
        
            <div id="about-card-bio"><p>光阴似箭，日月如梭，然而，人可以老，力可以衰，心却不能死，理想也不能灭…</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>Java Developer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                China.SiChuan
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://blogimage-1253148269.cos.ap-chengdu.myqcloud.com/zongsi.png');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-t6ztvrkwotqq30w08guadl2mq4yn3gvnrzqwy1ojd4f6nrkqjn6kcdzdwznj.min.js"></script>
<!--SCRIPTS END-->



    </body>
</html>
